"use strict";
/* Minify Order(1) */
window.TK = {};
window.TK.AutoTypeSelection = true;
window.TK.Initialize = function (obj, parentObj, nameChildObj, selfObj, taggedObjects) {
    var reserved = ['Parent', 'Sibling', 'Add', 'AddMultiple', 'Clear', 'Near', 'Remove', 'SetHTML', '_'];
	var allObjs = [obj];
	var inits = [];
    var copyObj = {};
    var defaultInnerHTML = null;
    var type = obj._;
    if (!taggedObjects)
        taggedObjects = {};
    var childTagged = {};

	// Allow types to point to different objects (overriding their properties)
	while (type && (typeof type != "string" || type.indexOf(".") > 0)) {
		if (typeof type == "string") {
			type = eval(type);
        }
		allObjs.push(type);
		type = type._;

	}
	// Allow classname to be specified (example: div.orange)    
	var className = null;
	/*if (type && type.indexOf && type.indexOf(".") >= 0) {
		className = type.substr(type.indexOf(".") + 1);
		type = type.substr(0, type.indexOf("."));
		if (type == "")
			type = null;
	}*/
	// Default type (div, unless name ends with Input, Button, Select or Label)
	if (!type) {
		type = "div";
		if (nameChildObj && window.TK.AutoTypeSelection) {
            var autoTypes = ["Input", "TextButton", "Button", "Select", "Label", "Span", "Textarea", "H1", "H2", "H3", "H4"];
			var endsWith = function (s, has) {
				if (!s || !has || s.length < has)
					return false;
				return s.substr(s.length - has.length) == has;
			};
			for (var i = 0; i < autoTypes.length; i++) {
                if (endsWith(nameChildObj, autoTypes[i])) {
                    if (autoTypes[i] == "TextButton") {
                        defaultInnerHTML = nameChildObj.substr(0, nameChildObj.length - 10);
                        type = "button";
                    } else {
                        type = autoTypes[i].toLowerCase();
                    }
					break;
				}
			}
		}
	}
	// Actually create the element (or empty object, in case its a component with no DOM representation)
	var copyObj = type != "component" ? document.createElement(type) : {};
    copyObj._ = type;

    if (type == "button") {
        copyObj.type = "button"; // Prevent Buttons to automatically become submit buttons in case they are located in a form
    }

	// Go through all levels of elements, set (and override) properties. Keep all child elements and Init functions in a seperate list
    var elements = {};
    var resolveProperties = [];
	for (var i = allObjs.length - 1; i >= 0; i--) {
		for (var propName in allObjs[i]) {
			if (propName == "style" && copyObj.appendChild) {
				for (var styleName in allObjs[i].style) {
					copyObj.style[styleName] = allObjs[i].style[styleName];
				}
				continue;
			}
			if (reserved.indexOf(propName) >= 0)
				continue;
            if (propName == "Elements") {
                for (var elementName in allObjs[i][propName]) {
                    if (typeof allObjs[i][propName][elementName] === 'string') {
                        elements[elementName] = {
                            HTML: allObjs[i][propName][elementName]
                        };
                    } else if (typeof allObjs[i][propName][elementName] === 'function') {
                        elements[elementName] = {
                            onclick: allObjs[i][propName][elementName]
                        };
                    } else {
                        elements[elementName] = allObjs[i][propName][elementName];
                    }
                }
            } else {
                if (allObjs[i][propName] && allObjs[i][propName].ToolkitPropertyReference)
                    resolveProperties.push(propName);
                
                if (copyObj["__RecursiveProperties" + propName]) {
                    // We're going to copy all settings recursively                    
                    window.TK.RecursiveCopy(allObjs[i], copyObj, propName);
                } else {
                    if (allObjs[i][propName] !== undefined)
                        copyObj[propName] = allObjs[i][propName];
                }
			}
			if (propName == "Init")
				inits.push(copyObj[propName]);
		}
	}

	// Set the classname (Automatically adds a Element-Name class, and any custom classes)
	if (type != "component" && (nameChildObj || className)) {
		if (!copyObj.className)
			copyObj.className = "";
		copyObj.className += " " + (nameChildObj ? "Element-" + nameChildObj : "") + (className ? " " + className : "");
	}

	if (nameChildObj) {
		copyObj._Name = nameChildObj;
    }

    if (copyObj._Self) // When set to true, this forces this element to be marked as 'Self'
        selfObj = copyObj;
    
    if (defaultInnerHTML && (!copyObj.innerHTML || copyObj.innerHTML == "")) {
        copyObj.innerHTML = defaultInnerHTML;
    }
    
    if (copyObj._Position && copyObj.style) {
        var isSet = function (a) {
            return !(a === null || a === undefined);
        };
        var p = TK.ParsePosition(copyObj._Position); // top,right,bottom,left,width,height[,relative]
        copyObj.style.top = isSet(p[0]) ? p[0] : "";
        copyObj.style.right = isSet(p[1]) ? p[1] : "";
        copyObj.style.bottom = isSet(p[2]) ? p[2] : "";
        copyObj.style.left = isSet(p[3]) ? p[3] : "";        

        if (isSet(p[4]))
            copyObj.style.width = p[4];
        if (isSet(p[5]))
            copyObj.style.height = p[5];

        copyObj.style.position = isSet(p[6]) ? p[6] : "absolute";
    }

    for (var name in taggedObjects) {
        copyObj["$"+name] = taggedObjects[name]; // Tagged parent objects always start with a $ to make them easy to recognize
    }

    if (copyObj._Tag) {
        if (copyObj._Tag === true && nameChildObj)
            copyObj._Tag = nameChildObj;
        
        var tag = copyObj._Tag.substr(0, 1) == "$" ? copyObj._Tag.substr(1) : copyObj._Tag;
        taggedObjects[tag] = copyObj;
    }

    //if (nameChildObj)
    //    taggedObjects["Element_"+nameChildObj] = copyObj; // Speed up the 'Near' method. TODO: Need to test .Add performance impact first

	// Add extra helper functions
	copyObj.Add = function (obj, nameChildObj) {
		// Add single child element
        var copyTagged = {};
        for (var tagName in taggedObjects) {
            if (childTagged[tagName]) // Make sure we don't pass other siblings childs
                continue;
            copyTagged[tagName] = taggedObjects[tagName];
        }
        return window.TK.Initialize(obj, this, nameChildObj, null, copyTagged);
	};
	copyObj.AddMultiple = function (obj, propertyArray, syncPropertyName, useVariable) {
		// Add multiple child elements
		var newObjs = [];
		var allNewObjIds = [];
		var existingObjIds = [];
		if (syncPropertyName) {
			existingObjIds = this.Elements.ToArray().Select(function (a) { return useVariable ? a[useVariable][syncPropertyName] : a[syncPropertyName]; });
		}
		for (var i = 0; i < propertyArray.length; i++) {
			if (syncPropertyName) {
				var objId = propertyArray[i][syncPropertyName];
				allNewObjIds.push(objId);
				var existingIndex = existingObjIds.indexOf(objId);
				if (existingIndex >= 0) { // Already exists
					existingObjIds.splice(existingIndex, 1);
					continue;
				}
			}
			var toInitialize = propertyArray[i];
			if (useVariable) {
				toInitialize = { _: obj };
				toInitialize[useVariable] = propertyArray[i];
			} else {
				toInitialize._ = obj;
            }

            var copyTagged = {};
            for (var tagName in taggedObjects) {
                if (childTagged[tagName]) // Make sure we don't pass other siblings childs
                    continue;
                copyTagged[tagName] = taggedObjects[tagName];
            }
            newObjs.push(window.TK.Initialize(toInitialize, this, null, null, copyTagged));
		}
		if (syncPropertyName) {
			// Remove all old child elements which aren't in the new propertyArray 
			for (var childName in this.Elements) {
				if (typeof this.Elements[childName] != "function" && allNewObjIds.indexOf(useVariable ? this.Elements[childName][useVariable][syncPropertyName] : this.Elements[childName][syncPropertyName]) < 0) {
					this.Elements[childName].Remove();
				}
			}
		}
		return newObjs;
	};

	copyObj.Remove = function (onlyExecuteCallback) {
		if (this.Destroy) {
			this.Destroy();
		}
		for (var childName in this.Elements) {
			if (this.Elements[childName].Remove)
				this.Elements[childName].Remove(true);
		}
		if (onlyExecuteCallback)
			return;

		if (this.Parent) {
			if (this.parentNode)
				this.parentNode.removeChild(this);

			for (var childName in this.Parent.Elements) {
				if (this.Parent.Elements[childName] == this) {
					delete this.Parent.Elements[childName];
					break;
				}
			}
			delete this.Parent;
		} else {
			if (this.parentNode && this.parentNode.removeChild)
				this.parentNode.removeChild(this);
		}
	};
	copyObj.Clear = function () {
		this.Elements.ToArray().Select(function (a) { a.Remove(); });
	};
	copyObj.Near = function (name) {
        // Find the nearest element with this name, or classname, or id
        if (name.substr(0, 1) == "$") { // Search by tag            
            var tmp = this;
            while (tmp) {
                if (tmp[name])
                    return tmp[name];
                tmp = tmp.Parent;
            }
        }

        var curEle = this;
        var findName = name;
        if (name.substr(0, 1) != "." && name.substr(0, 1) != "#") {
            if (curEle.Elements && curEle.Elements[name])
                return curEle.Elements[name]; // Direct child
            if (curEle["$$" + name])
                return curEle["$$" + name]; // Child somewhere in the tree
            if (curEle["$" + name])
                return curEle["$" + name]; // One of the parents
            findName = ".Element-" + findName;
        }		
		var found = curEle.querySelector(findName);
		if (found)
			return found;
        while (curEle.Parent || curEle.parentNode) {            
			curEle = curEle.Parent ? curEle.Parent : curEle.parentNode;
			if (curEle._Name == name)
                return curEle;
            if (curEle["$$" + name])
                return curEle["$$" + name];
            if (curEle["$" + name])
                return curEle["$" + name];
            /*if (curEle["$$Element_" + name])   // Speed up the 'Near' method. TODO: Need to test .Add performance impact first
                return curEle["$$Element_" + name];
            if (curEle["$Element_" + name])
                return curEle["$Element_" + name]; */ 

            if (curEle.className && "." + curEle.className == name)
                return curEle;
            if (curEle.Elements && curEle.Elements[name])
                return curEle.Elements[name];
			var found = curEle.querySelector(findName);
			if (found)
				return found;
		}
		return null;
    };
    copyObj.DetachElementFromParent = function () {
        // This appends the div to the document.body element with a fixed position on the same position using getBoundingClientRect
        if (!this.getBoundingClientRect)
            return;
        var rect = this.getBoundingClientRect();
        if (!rect || isNaN(rect.top) || isNaN(rect.left))
            return;
        this.style.position = "fixed";
        this.style.top = rect.top + "px";
        this.style.left = rect.left + "px";
        document.body.appendChild(this);
    };
    var getReference = function (capture, observingObject) {
        var curObj = copyObj;
        if (typeof capture == "function") {
            return capture(copyObj);            
        }

        if (capture.indexOf(":") >= 0) {
            curObj = copyObj.Near(capture.substr(0, capture.indexOf(":")));
            if (!curObj)
                return "";
            capture = capture.substr(capture.indexOf(":") + 1);
        }

        if (capture != "") {
            while (capture.indexOf(".") > 0) {
                var part = capture.substr(0, capture.indexOf("."));
                if (part == "Parent")
                    curObj = parentObj;
                else
                    curObj = curObj[part];
                capture = capture.substr(capture.indexOf(".") + 1);
            }
            if (observingObject) {
                // Add a getter/setter structure to the property we want to observe, when changed, call the object's FieldUpdate function
                curObj["__Orig" + capture] = curObj[capture];
                Object.defineProperty(curObj, capture, {
                    get: function () {
                        return this["__Orig" + capture];
                    },
                    set: function (value) {
                        this["__Orig" + capture] = value;
                        if (observingObject.Obj.FieldUpdate) {
                            observingObject.Obj.FieldUpdate(observingObject.Name, value);
                        }
                    }
                });
            }
            curObj = curObj[capture];
        }
        return curObj;
    };

    copyObj.SetHTML = function (html) {
        var injectChildsObj = {};
        var injectChilds = false;

        this.innerHTML = html.replace(/\$([\ \-\#\:\w\.]*?)\$/g, function (match, capture) {
            var curObj = getReference(capture);

            if (curObj && curObj.tagName) { // Reference added to a HTML element
                var rnd = "placeholder-" + Math.floor(Math.random() * 1000000) + "-" + Math.floor(Math.random() * 1000000) + "-" + Math.floor(Math.random() * 1000000);
                injectChildsObj[rnd] = curObj;
                injectChilds = true;
                return "<span id=\"" + rnd + "\" class=\"tkInternalPlaceHolder\"></span>";
            }
            return curObj;
        });

        if (injectChilds) {
            var items = this.querySelectorAll(".tkInternalPlaceHolder");
            for (var i = 0; i < items.length; i++) {
                var elementToAdd = injectChildsObj[items[i].id];
                items[i].parentNode.insertBefore(elementToAdd, items[i]);
                items[i].parentNode.removeChild(items[i]);
            }
        }
    };

	copyObj.Elements = {};
	copyObj.Elements.ToArray = function () {
		var arr = [];
		for (var propName in this) {
			if (typeof this[propName] != "function")
				arr.push(this[propName]);
		}
		return arr;
    };

    // Set the 'Self' property, which will always point to the main object added with .Add or TK.Initialize
    if (!selfObj)
        selfObj = copyObj;
    if (copyObj.Self === undefined)
        copyObj.Self = selfObj;

	// Create all sub elements    
    for (var name in elements) {
        var copyTagged = {};
        for (var tagName in taggedObjects)
            copyTagged[tagName] = taggedObjects[tagName];        
        window.TK.Initialize(elements[name], copyObj, name, selfObj, copyTagged);

        // The copyTagged object is now expanded with child objects, we will just keep the new childs
        for (var name in copyTagged) {
            if (taggedObjects[name] == copyTagged[name])
                continue; // Old one we've already added as parent, or it is ourself
            childTagged[name] = copyTagged[name];
        }
    }

    for (var name in childTagged) {
        copyObj["$$" + name] = childTagged[name];
        taggedObjects[name] = childTagged[name]; // Will also add it to our tagged object (but only at this step), so any of the didn't get the child elements of their siblings.
    }


	// Add this element to the child elements of a parent element (and get a reference to it)
	if (parentObj) {
        copyObj.Parent = parentObj;
        copyObj.Sibling = parentObj.Elements;
        parentObj.Elements[nameChildObj ? nameChildObj : ("ele"+Math.random().toString())] = copyObj;
		if (copyObj.appendChild && parentObj.appendChild) {
			// This and parent element are html nodes
			parentObj.appendChild(copyObj);
		}
    }

    // Special HTML template support. Variables in the same object can be including using their $PropertyName$ , $Parent.Sub.PropertyName$ etc. also works
    // You can also reference to other elements, which will be appended at the correct locations.
    if (copyObj.HTML) {
        copyObj.SetHTML(copyObj.HTML);
    }    

    // Use TK.P("Parent.PropertyName") in a template to reference to a object on runtime
    for (var i = 0; i < resolveProperties.length; i++) {
        var p = copyObj[resolveProperties[i]];
        if (!p.ToolkitPropertyReference)
            continue;
        if (p.Observe) {
            // Attach getter/setter to the property we are looking at, so it can call our 'FieldChange' function
            getReference(p.ToolkitPropertyReference, { Name: resolveProperties[i], Obj: copyObj });

            // Attach an getter to the current object, to always retrieve the latest value
            var attachGetter = function (referencePath) {
                Object.defineProperty(copyObj, resolveProperties[i], {
                    get: function () {
                        return getReference(referencePath);
                    }
                });
            };
            attachGetter(p.ToolkitPropertyReference);
        } else {
            copyObj[resolveProperties[i]] = getReference(p.ToolkitPropertyReference);
        }
    }

	// Call all init functions of inheritance objects, lowest level goes first, all the 'overrides' go after
	for (var i = 0; i < inits.length; i++) {
		inits[i].call(copyObj);
	}
	return copyObj;
};
window.TK.P = function (name, observe) {
    return { ToolkitPropertyReference: name, Observe: observe };
};
window.TK.RecursiveCopy = function (objSource, objTarget, singleProperty) {
    for (var n in objSource) {
        if (objSource[n] === undefined || (singleProperty && n != singleProperty))
            continue;
        if (!(objSource[n] instanceof Object) || typeof objSource[n] == "function") {
            objTarget[n] = objSource[n];        
        } else if (Array.isArray(objSource[n])) {            
            if (!objTarget[n])
                objTarget[n] = [];
            for (var i = 0; i < objSource[n].length; i++) {
                objTarget[n].push(objSource[n][i]);
            }            
        } else {
            if (!objTarget[n])
                objTarget[n] = {};            
            window.TK.RecursiveCopy(objSource[n], objTarget[n]);
        }
    }
};
window.TK.ParsePosition = function (p) {
    if (!p)
        return [];
    // Parse a _Position property and returns an array with all values
    // Supported:
    // - [top,right,bottom,left,width,height,tags]
    // - L10 T20 W200 H400
    // - L10 T20 R10 B10
    // - X10 Y20 W200 H400 relative
    // - [100, 200, "50px","10%", null, null, "relative"]

    if (p.substr) {
        if (p.indexOf(",") >= 0) { // 'old' style
            p = p.split(/,/g);
        } else {
            var newP = [];
            var matches = p.match(/[XYLTRBWH][\d\-\.]+(%|px|pt|vw|vh)?/g);
            for (var i = 0; i < matches.length; i++) {
                p = p.replace(matches[i], "");
                var c = matches[i].substr(0, 1);
                var v = matches[i].substr(1);
                if (c == "X" || c == "L")
                    newP[3] = v;
                else if (c == "Y" || c == "T")
                    newP[0] = v;
                else if (c == "R")
                    newP[1] = v;
                else if (c == "B")
                    newP[2] = v;
                else if (c == "W")
                    newP[4] = v;
                else if (c == "H")
                    newP[5] = v;
            }

            // Rest are tags, we'll put them all in the [6] position
            if (p.trim)
                p = p.trim();
            if (p)
                newP[6] = p;
            p = newP;
        }
    } else {
        p = p.slice(); // Don't edit the existing array object as it might be observed
    }

    for (var i = 0; i < p.length; i++) {
        if (p[i] !== null && p[i] !== undefined && !p[i].substr) {
            p[i] = p[i].toString() + "px"; // Convert numbers to px
        }
    }
    return p;
};

/// Helper functions
window.SvgPath = function (d, width, height, color, strokeWidth) {        
    if (!color) color = "#333";
    if (!strokeWidth) strokeWidth = 3;
    return '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" viewBox="0 0 ' + width + ' ' + height + '" width="' + width + '" height="' + height + '" ><path d="' + d + '" stroke="' + color + '" stroke-linecap="round" stroke-width="' + strokeWidth+'" fill="none"/></svg>';
};
window.ConvertFromASPTime = function (a) {
    if (a && a.length && a.length > 6 && a.substr(0, 6) == "/Date(") {
        var dateObj = new Date(parseInt(a.substr(6, a.length - 2)));
        return dateObj.toISOString();
    }
    return "";
};
window.ConvertToASPTime = function (a) {
    if (a == "")
        return "";
    var time = new Date(a).getTime();
    return "\\/Date(" + time + ")\\/";
};

"use strict";
/* Minify Order(5) */

window.ajax = function () {
    var obj = this;
    this.timeout = 30000;
    this.timeoutChecker = null;
    this.ajaxObject = null;
    this.busy = false;
    this.queue = [];
    this.currentRequestInfo = null; // url, callback etc.
    this.retryCount = 0;
    this.maxRetries = 3;
    this.cached = {};
    this.allowEmptyResponse = false;
    this.showServerErrors = true;
    this.saveResults = false;
    this.cacheResults = false;
    this.executeScriptTags = true;
    this.parseJSONResponse = false;
    this.errorHandler = null; // function(statusCode,responseText) {}
    this.extraHeaders = []; // [ ["Content-Type", "application/json"] ]
    this.beforeRequest = null; // function(requestInfo, callBackExecuteRequest(requestInfo) ) {}

    this.getSetting = function (name, requestInfo) {
        if (!requestInfo)
            requestInfo = this.currentRequestInfo;
        if (requestInfo && requestInfo.extraSettings && requestInfo.extraSettings[name] !== undefined) {
            return requestInfo.extraSettings[name];
        }
        return this[name];
    };
    this.initComponent = function () {
        this.ajaxObject = this.getAvailableAjaxObject();
        if (!this.ajaxObject) // could not init any ajax object
            return;

        // set event handlers
        this.ajaxObject.onreadystatechange = function () {
            if (obj.ajaxObject.readyState !== 4 || obj.ajaxObject.status == 0)
                return;

            if (obj.timeoutChecker) {
                clearTimeout(obj.timeoutChecker);
                obj.timeoutChecker = null;
            }

            if (obj.ajaxObject.status !== 200) {
                if (obj.ajaxObject.status >= 400) {
                    var errorHandler = obj.getSetting("errorHandler");
                    if (errorHandler)
                        errorHandler(obj.ajaxObject.status, obj.ajaxObject.responseText);
                    else if (obj.getSetting("showServerErrors"))
                        alert('Server error, returned code: ' + obj.ajaxObject.status); // mostly unrecoverable server error
                    obj.nextRequest();
                } else
                    obj.retryLast(); // retry, sometimes IE returns some unusual number for failed requests
                return;
            }
            var responseIsText = (!obj.ajaxObject.responseType || obj.ajaxObject.responseType === "" || obj.ajaxObject.responseType == "text");

            try {
                // Response is required since bad requests can sometimes give an empty response
                if (responseIsText && obj.ajaxObject.responseText == "" && !obj.getSetting("allowEmptyResponse")) {
                    obj.retryLast();
                    return;
                }
            } catch (r) {
                obj.retryLast(); // Sometimes the responseText is unreadable, also retry
                return;
            }

            // Everything seems to be ok! 
            var curReq = obj.currentRequestInfo;

            obj.retryCount = 0;

            var callBacks = [];            
            if (curReq.callBack)
                callBacks.push(curReq.callBack);

            var pageCacheHash = responseIsText && (obj.getSetting("saveResults") || obj.getSetting("cacheResults")) ? "page" + obj.hashString(curReq.get) : "";
            if (responseIsText && obj.getSetting("saveResults")) {
                window.localStorage[pageCacheHash] = obj.ajaxObject.responseText;
            }

            if (responseIsText && obj.getSetting("cacheResults")) {
                if (obj.cached[pageCacheHash] !== undefined && Array.isArray(obj.cached[pageCacheHash]))
                    callBacks = callBacks.concat(obj.cached[pageCacheHash]); // There were possibly multiple calls waiting for this response
                obj.cached[pageCacheHash] = obj.ajaxObject.responseText;
            }

            // check for callback            
            for (var i = 0; i < callBacks.length; i++) {
                let cb = callBacks[i];

                var responseData = null;
                if (responseIsText) {
                    responseData = obj.ajaxObject.responseText;
                    if (obj.getSetting("parseJSONResponse") && responseData && (responseData.substr(0, 1) == "{" || responseData.substr(0, 1) == "\"" || responseData.substr(0, 1) == "[")) {
                        responseData = JSON.parse(responseData);
                    }
                } else {
                    responseData = obj.ajaxObject.response;
                }
                obj.executeCallBack(cb, responseData, curReq);                
            }
            obj.nextRequest();
        };
        this.ajaxObject.onerror = function (error) {
            var errorHandler = obj.getSetting("errorHandler");
            if (errorHandler)
                errorHandler(0, null);
            obj.nextRequest();
        };
    };
    this.executeCallBack = function (callBack, responseData, request) {
        // Do this as a timeout, so it doesn't mess with our ajax code
        setTimeout(function () { callBack(responseData, request.get, request.post, request.callBackData); }, 1);                
    }

    this.getAvailableAjaxObject = function () {
        // Modern browsers
        if (window.XMLHttpRequest)
            return new XMLHttpRequest();

        // IE Specific
        if (window.ActiveXObject) {
            try {
                return new ActiveXObject("Msxml2.XMLHTTP");
            } catch (r) { }
            try {
                return new ActiveXObject("Microsoft.XMLHTTP");
            } catch (r) { }
        }
    };

    this.hashString = function (string) {
        var hash = 0;
        if (string.length == 0)
            return hash;

        for (var i = 0; i < string.length; i++) {
            var char = string.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32bit integer
        }
        return hash;
    };
    this.clearSaved = function () {
        for (var item in window.localStorage) {
            if (item.substr(0, 4) == "page") {
                delete window.localStorage[item];
            }
        }
    };
    this.clearCached = function () {
        this.cached = {};
    };
    //redo current request
    this.retryLast = function () {
        if (this.getSetting("saveResults") && window.localStorage["page" + this.hashString(this.currentRequestInfo.get)]) {
            console.log("Using saved results");
            // Use saved result instead
            if (this.currentRequestInfo.callBack) {
                // make a copy since the callback is called in timeout (currentRequestInfo can be changed)
                var curReq = this.currentRequestInfo;
                var content = window.localStorage["page" + this.hashString(this.currentRequestInfo.get)];
                if (this.getSetting("parseJSONResponse") && content && (content.substr(0, 1) == "{" || content.substr(0, 1) == "\"" || content.substr(0, 1) == "[")) {
                    content = JSON.parse(content);
                }
                obj.executeCallBack(curReq.callBack, content, curReq);                
            }
            this.nextRequest();
            return;
        }
        this.busy = false;
        this.retryCount++;
        if (this.retryCount > this.getSetting("maxRetries")) {
            this.retryCount = 0;
            this.nextRequest();
            return;
        }
        if (this.currentRequestInfo)
            this.do(this.currentRequestInfo.get, this.currentRequestInfo.post, this.currentRequestInfo.callBack, this.currentRequestInfo.callBackData, this.currentRequestInfo.extraSettings);
    };

    // Prepare everything for a next request (and even do them if there is something in the queue)
    this.nextRequest = function () {
        this.busy = false;
        if (this.queue.length == 0) {
            return;
        }

        var nextRequestInfo = this.queue.shift();
        this.do(nextRequestInfo.get, nextRequestInfo.post, nextRequestInfo.callBack, nextRequestInfo.callBackData, nextRequestInfo.extraSettings);
    };
    this.do = function (get, post, callBack, callBackData, extraSettings) {
        if (!this.ajaxObject) {
            this.initComponent();
        }

        if (extraSettings) {
            var orig = extraSettings;
            extraSettings = JSON.parse(JSON.stringify(extraSettings)); // Clone to make sure we don't override any settings for the next request
            if (orig.errorHandler)
                extraSettings.errorHandler = orig.errorHandler;
        }

        var requestInfo = { get: get, post: post, callBack: callBack, callBackData: callBackData, extraSettings: extraSettings };

        var beforeRequest = this.getSetting("beforeRequest", requestInfo);
        if (beforeRequest) { 
            beforeRequest(requestInfo, function (requestInfo) {
                if (!requestInfo.extraSettings)
                    requestInfo.extraSettings = {};
                requestInfo.extraSettings.beforeRequest = null;
                obj.do(requestInfo.get, requestInfo.post, requestInfo.callBack, requestInfo.callBackData, requestInfo.extraSettings);
            });
            return;
        }

        if (extraSettings && extraSettings.cacheResults) {
            var pageHash = ["page" + this.hashString(get)];
            var content = this.cached[pageHash];
            var done = 0;
            if (content !== undefined && Array.isArray(content)) {
                // This request is already on its way, add us to the callbacks
                content.push(callBack);
                done = 1;
            } else if (content) {
                if (callBack) {
                    if (!(typeof post === "string" || post instanceof String) && this.parseJSONResponse !== false && content && (content.substr(0, 1) == "{" || content.substr(0, 1) == "\"" || content.substr(0, 1) == "[")) {
                        content = JSON.parse(content);
                    }
                    obj.executeCallBack(callBack, content, requestInfo);
                }
                done = 1;
            } else {
                // We will execute this request, so add a temp array all next callback can be added to
                if (!this.busy)
                    this.cached[pageHash] = [];
            }

            if (done) {
                if (!this.busy)
                    this.nextRequest();
                return;
            }
        }

        if (this.busy) {
            this.queue.push(requestInfo);
            return;
        }

        this.busy = true;
        this.currentRequestInfo = requestInfo;
        if (post == null) {
            this.ajaxObject.open('GET', get, true);
        } else {
            this.ajaxObject.open('POST', get, true);
        }
        
        var extraHeaders = this.getSetting("extraHeaders");
        for (var i = 0; i < extraHeaders.length; i++) {
            this.ajaxObject.setRequestHeader(extraHeaders[i][0], extraHeaders[i][1]);
        }

        if (this.ajaxObject.responseType !== this.undefined && this.getSetting("responseType"))
            this.ajaxObject.responseType = this.getSetting("responseType");

        this.timeoutChecker = setTimeout(function () {
            obj.timeoutChecker = null;
            try { // try to cancel
                obj.ajaxObject.abort();
            } catch (errie) { }
            obj.retryLast();
        }, this.getSetting("timeout"));

        if (post == null) {
            this.ajaxObject.send(); // get
        } else {
            if (post instanceof FormData) { // Post form data (including file uploads)
                this.ajaxObject.send(post);
                return;
            } else if (!(typeof post === "string" || post instanceof String)) {
                // We can only put text in our post data
                post = JSON.stringify(post);
                if (!this.currentRequestInfo.extraSettings)
                    this.currentRequestInfo.extraSettings = {};
                if (this.currentRequestInfo.extraSettings.parseJSONResponse == undefined)
                    this.currentRequestInfo.extraSettings.parseJSONResponse = true;
            }
            this.ajaxObject.setRequestHeader("Content-Type", post.length > 0 && post.substr(0, 1) == "{" ? "application/json" : "application/x-www-form-urlencoded");
            this.ajaxObject.setRequestHeader("Content-Size", post.length);
            if (post.length > 0 && post.substr(0, 1) == "{") {
                post = post.replace(/"\/Date\((\d*)\)\/"/g, "\"\\/Date($1)\\/\"");
            }
            this.ajaxObject.send(post);
        }

    };

    /* Extra handy functions */
    this.doAjaxToDiv = function (get, post, divName, extraSettings) {
        var obj = this;
        this.do(get, post, function (txt) {
            document.getElementById(divName).innerHTML = txt;
            if (obj.getSetting("executeScriptTags")) {
                obj.executeScripts(txt);
            }
        }, null, extraSettings);
    };

    this.doAjaxToDivElement = function (get, post, divElement, extraSettings) {
        var obj = this;
        this.do(get, post, function (txt) {
            divElement.innerHTML = txt;
            if (obj.getSetting("executeScriptTags")) {
                obj.executeScripts(txt);
            }
        }, null, extraSettings);
    };

    this.doAjaxFormSubmit = function (formElement, callBack, submitButton, extraSettings) {
        /*if (window.FormData) { // We can use the FormData api            
            var fd = new FormData(formElement);
            if (submitButton && submitButton.name) {
                fd.append(fd.name, fd.value);
            }
            this.do(formElement.action, fd, callBack, null, extraSettings);
            return fd;
        }*/
        var inputs = "";
        for (var i = 0; i < formElement.length; i++) {
            if (formElement[i].type == "submit" && submitButton != formElement[i])
                continue;

            if ((formElement[i].type == "checkbox" || formElement[i].type == "radio") && !formElement[i].checked)
                continue;

            if (formElement[i].multiple && formElement[i].options && formElement[i].name) {
                for (var j = 0; j < formElement[i].options.length; j++) {
                    if (formElement[i].options[j].selected && formElement[i].options[j].value) {
                        inputs += "&" + formElement[i].name + "=" + this.URLEncode(formElement[i].options[j].value);
                    }
                }
                continue;
            }

            if (formElement[i].value && formElement[i].name) {
                inputs += "&" + formElement[i].name + "=" + this.URLEncode(formElement[i].value);
            }
        }
        this.do(formElement.action, inputs, callBack, null, extraSettings);
    };

    this.doAjaxFormSubmitToDiv = function (formElement, divName, submitButton, extraSettings) {
        var obj = this;
        this.doAjaxFormSubmit(formElement, function (pTxt) {
            document.getElementById(divName).innerHTML = pTxt;
            if (obj.getSetting("executeScriptTags")) {
                obj.executeScripts(pTxt);
            }
        }, submitButton, extraSettings);
    };
    this.doFileUpload = function (url, nameFormField, blobOrFileElement, blobFileName, callBack, callBackData, extraSettings) {
        var fd = new FormData();
        fd.append(nameFormField, blobOrFileElement, blobFileName);
        this.do(url, fd, callBack, callBackData, extraSettings);
    };
    this.executeScripts = function (data) {
        while (data.indexOf("<script") >= 0 && data.indexOf("</script>") >= 0) {
            var script = data.substr(data.indexOf("<script") + 7);
            script = script.substr(script.indexOf(">") + 1);
            script = script.substring(0, script.indexOf("</script>"));
            try {
                eval(script);
            } catch (errie) {
                console.log("Error executing script:");
                console.log(errie);
            }
            data = data.substr(data.indexOf("</script>") + 9);
        }
    };
    // URL Encoding script
    this.gethex = function (decimal) {
        var hexchars = "0123456789ABCDEFabcdef";
        return "%" + hexchars.charAt(decimal >> 4) + hexchars.charAt(decimal & 0xF);
    };

    this.URLEncode = function (decoded) {
        var unreserved = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_.~";
        var encoded = "";
        for (var i = 0; i < decoded.length; i++) {
            var ch = decoded.charAt(i);

            if (unreserved.indexOf(ch) != -1) {
                encoded = encoded + ch;
            } else {
                var charcode = decoded.charCodeAt(i);
                if (charcode < 128) {
                    encoded = encoded + this.gethex(charcode);
                } else if (charcode > 127 && charcode < 2048) {
                    encoded = encoded + this.gethex((charcode >> 6) | 0xC0);
                    encoded = encoded + this.gethex((charcode & 0x3F) | 0x80);
                } else if (charcode > 2047 && charcode < 65536) {
                    encoded = encoded + this.gethex((charcode >> 12) | 0xE0);
                    encoded = encoded + this.gethex(((charcode >> 6) & 0x3F) | 0x80);
                    encoded = encoded + this.gethex((charcode & 0x3F) | 0x80);
                } else if (charcode > 65535) {
                    encoded = encoded + this.gethex((charcode >> 18) | 0xF0);
                    encoded = encoded + this.gethex(((charcode >> 12) & 0x3F) | 0x80);
                    encoded = encoded + this.gethex(((charcode >> 6) & 0x3F) | 0x80);
                    encoded = encoded + this.gethex((charcode & 0x3F) | 0x80);
                }
            }
        }
        return encoded;
    };
};

window.Ajax = new ajax();"use strict";
/* Minify Order(5) */
// Extra array functions, inspired by LinqToSql
Array.prototype.Where = function (func) {
    var items = [];
    for (var i = 0; i < this.length; i++) {
        if (func(this[i], i))
            items.push(this[i]);
    }
    return items;
};

Array.prototype.First = function (func) {
    if (!func)
        return this[0];
    for (var i = 0; i < this.length; i++) {
        if (func(this[i], i))
            return this[i];
    }
};

Array.prototype.Take = function (count) {
    var items = [];
    for (var i = 0; i < this.length && i < count; i++) {
        items.push(this[i]);
    }
    return items;
};

Array.prototype.Skip = function (count) {
    var items = [];
    for (var i = count; i < this.length; i++) {
        items.push(this[i]);
    }
    return items;
};

Array.prototype.OrderBy = function (func) {
    if (!func)
        func = function (a) { return a; };
    return this.sort(function (a, b) {        
        var a2 = func(a), b2 = func(b);

        if (a2 === null || a2 === undefined)
            a2 = 0;
        if (b2 === null || b2 === undefined)
            b2 = 0;

        if (a2.localeCompare && b2.localeCompare) { // Both are string
            return a2.localeCompare(b2);
        } else if (a2.localeCompare) { // Only a2 is a string
            return a2.localeCompare(b2.toString());
        } else if (b2.localeCompare) {
            return a2.toString().localeCompare(b2); // Only b2 is a string
        }
        return a2 - b2;
    });
};
Array.prototype.OrderByDesc = function (func) {
    return this.OrderBy(func).reverse();
};

Array.prototype.Select = function (func) {
    var items = [];
    for (var i = 0; i < this.length; i++)
        items.push(func(this[i], i));
    return items;
};

Array.prototype.Max = function (func) {
    if (!func)
        func = function (a) { return a; };
    var highest = null;
    for (var i = 0; i < this.length; i++) {
        var value = func(this[i], i);
        if (highest == null || value > highest)
            highest = value;
    }
    return highest;
};

Array.prototype.Min = function (func) {
    if (!func)
        func = function (a) { return a; };
    var lowest = null;
    for (var i = 0; i < this.length; i++) {
        var value = func(this[i], i);
        if (lowest == null || value < lowest)
            lowest = value;
    }
    return lowest;
};

Array.prototype.Average = function (func) {
    if (!func)
        func = function (a) { return a; };
    var average = null;
    var averageCount = 0;
    for (var i = 0; i < this.length; i++) {
        var value = func(this[i], i);
        average = (average * averageCount + value) / (averageCount + 1);
        averageCount++;
    }
    return average;
};

Array.prototype.Unique = function (func) {
    if (!func)
        func = function (a) { return a; };
    var items = [];
    var uniqueKeys = [];
    for (var i = 0; i < this.length; i++) {
        var key = func ? func(this[i], i) : this[i];
        if (uniqueKeys.indexOf(key) < 0) {
            items.push(this[i]);
            uniqueKeys.push(key);
        }
    }
    return items;
};

Array.prototype.Randomize = function () {
    var items = this.slice();
    var currentIndex = items.length, temporaryValue, randomIndex;

    while (0 !== currentIndex) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;

        temporaryValue = items[currentIndex];
        items[currentIndex] = items[randomIndex];
        items[randomIndex] = temporaryValue;
    }
    return items;
};/* Minify Order(50) */
if (!window.Svg) { window.Svg = {}; }
var s="<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 256 256\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xml:space=\"preserve\" style=\"fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;\">";
window.Svg["Icons"]={
"Settings":s+"<path id=\"Settings\" d=\"M177.713,43.467C169.733,38.774 161.128,35.235 152.155,32.954L141.008,48.644C132.263,47.211 123.341,47.233 114.602,48.709L103.379,33.074C94.417,35.399 85.83,38.98 77.873,43.712L81.085,62.689C73.888,67.859 67.594,74.183 62.459,81.406L43.467,78.287C38.774,86.267 35.235,94.872 32.954,103.845L48.644,114.992C47.211,123.737 47.233,132.659 48.709,141.398L33.074,152.621C35.399,161.583 38.98,170.17 43.712,178.127L62.689,174.915C67.859,182.112 74.183,188.406 81.406,193.541L78.287,212.533C86.267,217.226 94.872,220.765 103.845,223.046L114.992,207.356C123.737,208.789 132.659,208.767 141.398,207.291L152.621,222.926C161.583,220.601 170.17,217.02 178.127,212.288L174.915,193.311C182.112,188.141 188.406,181.817 193.541,174.594L212.533,177.713C217.226,169.733 220.765,161.128 223.046,152.155L207.356,141.008C208.789,132.263 208.767,123.341 207.291,114.602L222.926,103.379C220.601,94.417 217.02,85.83 212.288,77.873L193.311,81.085C188.141,73.888 181.817,67.594 174.594,62.459L177.713,43.467ZM144.042,89.002C165.565,97.855 175.852,122.518 166.998,144.042C158.145,165.565 133.482,175.852 111.958,166.998C90.435,158.145 80.148,133.482 89.002,111.958C97.855,90.435 122.518,80.148 144.042,89.002Z\" style=\"fill:rgb(68,68,68);\"/></svg>",
"Home":s+"<g id=\"Home\"><path d=\"M110.831,232.444L71.594,232.444C61.156,232.444 52.681,223.969 52.681,213.53L52.681,125.266C54.068,88.011 204.749,86.997 203.309,125.266L203.309,213.53C203.309,223.969 194.834,232.444 184.395,232.444L145.169,232.444L145.169,182.372C145.169,177.634 141.323,173.788 136.584,173.788L119.416,173.788C114.677,173.788 110.831,177.634 110.831,182.372L110.831,232.444Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M246.598,146.415C252.806,123.335 131.065,9.056 125.259,30.023L115.168,38.348C122.368,29.8 242.85,148.331 234.74,157.92L246.598,146.415Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M9.402,146.415C3.194,123.335 124.935,9.056 130.741,30.023L140.832,38.348C133.632,29.8 13.15,148.331 21.26,157.92L9.402,146.415Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Hamburger":s+"<g id=\"Hamburger\"><path d=\"M239.702,121.385C239.702,117.734 236.738,114.77 233.087,114.77L22.913,114.77C19.262,114.77 16.298,117.734 16.298,121.385L16.298,134.615C16.298,138.266 19.262,141.23 22.913,141.23L233.087,141.23C236.738,141.23 239.702,138.266 239.702,134.615L239.702,121.385Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M239.702,201.385C239.702,197.734 236.738,194.77 233.087,194.77L22.913,194.77C19.262,194.77 16.298,197.734 16.298,201.385L16.298,214.615C16.298,218.266 19.262,221.23 22.913,221.23L233.087,221.23C236.738,221.23 239.702,218.266 239.702,214.615L239.702,201.385Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M239.702,41.385C239.702,37.734 236.738,34.77 233.087,34.77L22.913,34.77C19.262,34.77 16.298,37.734 16.298,41.385L16.298,54.615C16.298,58.266 19.262,61.23 22.913,61.23L233.087,61.23C236.738,61.23 239.702,58.266 239.702,54.615L239.702,41.385Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Close":s+"<g id=\"Close\"><path d=\"M233.212,223.857C235.793,221.275 235.793,217.084 233.212,214.502L41.498,22.788C38.916,20.207 34.725,20.207 32.143,22.788L22.788,32.143C20.207,34.725 20.207,38.916 22.788,41.498L214.502,233.212C217.084,235.793 221.275,235.793 223.857,233.212L233.212,223.857Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M32.143,233.212C34.725,235.793 38.916,235.793 41.498,233.212L233.212,41.498C235.793,38.916 235.793,34.725 233.212,32.143L223.857,22.788C221.275,20.207 217.084,20.207 214.502,22.788L22.788,214.502C20.207,217.084 20.207,221.275 22.788,223.857L32.143,233.212Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Resize":s+"<g id=\"Resize\"><path d=\"M239.702,219.857C239.702,216.206 236.738,213.242 233.087,213.242L22.913,213.242C19.262,213.242 16.298,216.206 16.298,219.857L16.298,233.087C16.298,236.738 19.262,239.702 22.913,239.702L233.087,239.702C236.738,239.702 239.702,236.738 239.702,233.087L239.702,219.857Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M233.087,239.702C236.738,239.702 239.702,236.738 239.702,233.087L239.702,22.913C239.702,19.262 236.738,16.298 233.087,16.298L219.857,16.298C216.206,16.298 213.242,19.262 213.242,22.913L213.242,233.087C213.242,236.738 216.206,239.702 219.857,239.702L233.087,239.702Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M114.558,106.693C116.715,104.536 116.715,101.034 114.558,98.877L90.368,74.687C88.211,72.53 84.709,72.53 82.552,74.687L74.736,82.503C72.579,84.66 72.579,88.163 74.736,90.32L98.926,114.509C101.082,116.666 104.585,116.666 106.742,114.509L114.558,106.693Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M97.86,113.488L113.488,97.86L178.73,163.102L193.242,148.59L193.242,193.242L148.59,193.242L163.102,178.73L97.86,113.488Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Move":s+"<g id=\"Move\"><path d=\"M116.949,116.256L139.051,116.256L139.051,208.522L159.574,208.522L128,240.096L96.426,208.522L116.949,208.522L116.949,116.256Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M139.051,139.744L116.949,139.744L116.949,47.478L96.426,47.478L128,15.904L159.574,47.478L139.051,47.478L139.051,139.744Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M139.744,116.949L139.744,139.051L47.478,139.051L47.478,159.574L15.904,128L47.478,96.426L47.478,116.949L139.744,116.949Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M116.256,139.051L116.256,116.949L208.522,116.949L208.522,96.426L240.096,128L208.522,159.574L208.522,139.051L116.256,139.051Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Copy":s+"<g id=\"Copy\"><path d=\"M201.934,233.21C204.789,233.21 207.108,230.891 207.108,228.036L207.108,61.836C207.108,58.98 204.789,56.662 201.934,56.662L95.634,56.662C92.778,56.662 90.459,58.98 90.459,61.836L90.459,228.036C90.459,230.891 92.778,233.21 95.634,233.21L201.934,233.21ZM183.671,213.49C186.527,213.49 188.846,211.172 188.846,208.316L188.846,81.556C188.846,78.7 186.527,76.382 183.671,76.382L113.896,76.382C111.04,76.382 108.722,78.7 108.722,81.556L108.722,208.316C108.722,211.172 111.04,213.49 113.896,213.49L183.671,213.49Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M83.064,198.41L60.93,198.41C58.075,198.41 55.756,196.092 55.756,193.236L55.756,27.036C55.756,24.181 58.075,21.862 60.93,21.862L167.23,21.862C170.086,21.862 172.405,24.181 172.405,27.036L172.405,51.343L154.142,51.343L154.142,46.756C154.142,43.9 151.824,41.582 148.968,41.582L79.193,41.582C76.337,41.582 74.018,43.9 74.018,46.756L74.018,173.516C74.018,176.372 76.337,178.69 79.193,178.69L83.064,178.69L83.064,198.41Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"User":s+"<g id=\"User\"><path d=\"M163.283,112.94C188.45,129.786 205.696,164.082 205.696,203.611C205.696,210.279 205.205,216.799 204.268,223.111C186.689,206.044 159.054,195.035 128,195.035C96.946,195.035 69.311,206.044 51.732,223.111C50.795,216.799 50.304,210.279 50.304,203.611C50.304,164.082 67.55,129.786 92.717,112.94C102.109,121.275 114.468,126.34 128,126.34C141.532,126.34 153.891,121.275 163.283,112.94Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M128,32.889C150.221,32.889 168.261,50.93 168.261,73.151C168.261,95.371 150.221,113.412 128,113.412C105.779,113.412 87.739,95.371 87.739,73.151C87.739,50.93 105.779,32.889 128,32.889ZM103.324,84.138C109.984,89.819 118.598,93.247 128,93.247C137.402,93.247 146.016,89.819 152.676,84.138C148.463,93.575 138.994,100.159 128,100.159C117.006,100.159 107.537,93.575 103.324,84.138Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Meter":s+"<g id=\"Meter\"><path d=\"M232.235,68.38C240.808,68.38 247.767,75.34 247.767,83.912L247.767,156.395C247.767,164.967 240.807,171.927 232.235,171.927L23.765,171.927C15.193,171.927 8.233,164.967 8.233,156.395L8.233,83.912C8.233,75.34 15.192,68.38 23.765,68.38L232.235,68.38ZM219.849,82.798L36.151,82.798C29.966,82.798 24.945,87.82 24.945,94.004L24.945,146.302C24.945,152.487 29.966,157.509 36.151,157.509L219.849,157.509C226.034,157.509 231.055,152.487 231.055,146.302L231.055,94.004C231.055,87.82 226.034,82.798 219.849,82.798Z\" style=\"fill:rgb(68,68,68);\"/><g><path d=\"M38.011,125.409L38.011,114.862C38.011,108.722 39.54,103.87 42.599,100.308C45.658,96.745 49.824,94.964 55.097,94.964C60.37,94.964 64.542,96.745 67.613,100.308C70.683,103.87 72.218,108.722 72.218,114.862L72.218,125.409C72.218,131.55 70.683,136.407 67.613,139.981C64.542,143.556 60.37,145.343 55.097,145.343C49.824,145.343 45.658,143.556 42.599,139.981C39.54,136.407 38.011,131.55 38.011,125.409ZM51.687,112.05L51.687,128.222C51.687,131.151 52.824,132.616 55.097,132.616C57.394,132.616 58.542,131.151 58.542,128.222L58.542,112.05C58.542,109.12 57.394,107.655 55.097,107.655C52.824,107.655 51.687,109.12 51.687,112.05Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/><path d=\"M86.133,125.409L86.133,114.862C86.133,108.722 87.662,103.87 90.721,100.308C93.779,96.745 97.945,94.964 103.219,94.964C108.492,94.964 112.664,96.745 115.734,100.308C118.805,103.87 120.34,108.722 120.34,114.862L120.34,125.409C120.34,131.55 118.805,136.407 115.734,139.981C112.664,143.556 108.492,145.343 103.219,145.343C97.945,145.343 93.779,143.556 90.721,139.981C87.662,136.407 86.133,131.55 86.133,125.409ZM99.809,112.05L99.809,128.222C99.809,131.151 100.945,132.616 103.219,132.616C105.516,132.616 106.664,131.151 106.664,128.222L106.664,112.05C106.664,109.12 105.516,107.655 103.219,107.655C100.945,107.655 99.809,109.12 99.809,112.05Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/><path d=\"M134.255,125.409L134.255,114.862C134.255,108.722 135.784,103.87 138.843,100.308C141.901,96.745 146.067,94.964 151.341,94.964C156.614,94.964 160.786,96.745 163.856,100.308C166.927,103.87 168.462,108.722 168.462,114.862L168.462,125.409C168.462,131.55 166.927,136.407 163.856,139.981C160.786,143.556 156.614,145.343 151.341,145.343C146.067,145.343 141.901,143.556 138.843,139.981C135.784,136.407 134.255,131.55 134.255,125.409ZM147.931,112.05L147.931,128.222C147.931,131.151 149.067,132.616 151.341,132.616C153.638,132.616 154.786,131.151 154.786,128.222L154.786,112.05C154.786,109.12 153.638,107.655 151.341,107.655C149.067,107.655 147.931,109.12 147.931,112.05Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/><rect x=\"192.713\" y=\"96.159\" width=\"13.605\" height=\"47.988\" style=\"fill:rgb(68,68,68);\"/></g></g></svg>",
"Barcode":s+"<g id=\"Barcode\"><path d=\"M192.155,179.415C194.447,179.415 196.309,177.554 196.309,175.261L196.309,68.061C196.309,65.768 194.447,63.906 192.155,63.906L183.845,63.906C181.553,63.906 179.691,65.768 179.691,68.061L179.691,175.261C179.691,177.554 181.553,179.415 183.845,179.415L192.155,179.415Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M162.155,192.094C164.447,192.094 166.309,190.232 166.309,187.939L166.309,68.061C166.309,65.768 164.447,63.906 162.155,63.906L153.845,63.906C151.553,63.906 149.691,65.768 149.691,68.061L149.691,187.939C149.691,190.232 151.553,192.094 153.845,192.094L162.155,192.094Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M132.155,192.094C134.447,192.094 136.309,190.232 136.309,187.939L136.309,68.061C136.309,65.768 134.447,63.906 132.155,63.906L123.845,63.906C121.553,63.906 119.691,65.768 119.691,68.061L119.691,187.939C119.691,190.232 121.553,192.094 123.845,192.094L132.155,192.094Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M102.155,179.415C104.447,179.415 106.309,177.554 106.309,175.261L106.309,68.061C106.309,65.768 104.447,63.906 102.155,63.906L93.845,63.906C91.553,63.906 89.691,65.768 89.691,68.061L89.691,175.261C89.691,177.554 91.553,179.415 93.845,179.415L102.155,179.415Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M72.155,179.415C74.447,179.415 76.309,177.554 76.309,175.261L76.309,68.061C76.309,65.768 74.447,63.906 72.155,63.906L63.845,63.906C61.553,63.906 59.691,65.768 59.691,68.061L59.691,175.261C59.691,177.554 61.553,179.415 63.845,179.415L72.155,179.415Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M91.038,244.583L34.282,244.583C21.588,244.583 11.282,234.277 11.282,221.583L11.282,164.962L29.501,164.962L29.501,207.008C29.501,217.691 38.174,226.364 48.857,226.364L91.038,226.364L91.038,244.583ZM164.962,226.364L203.707,226.364C214.39,226.364 223.063,217.691 223.063,207.008L223.063,164.962L241.282,164.962L241.282,221.583C241.282,234.277 230.977,244.583 218.282,244.583L164.962,244.583L164.962,226.364ZM164.962,14.583L218.282,14.583C230.977,14.584 241.282,24.89 241.282,37.583L241.282,91.038L223.063,91.038L223.063,52.159C223.063,41.476 214.391,32.803 203.707,32.802L164.962,32.802L164.962,14.583ZM91.038,14.583L91.038,32.802L48.857,32.802C38.173,32.803 29.501,41.476 29.501,52.159L29.501,91.038L11.282,91.038L11.282,37.583C11.282,24.89 21.587,14.584 34.282,14.583L91.038,14.583Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Route":s+"<g id=\"Route\"><path d=\"M83.6,148.135C84.65,147.085 84.65,145.379 83.6,144.328L43.447,104.176C42.397,103.125 40.691,103.125 39.64,104.176L35.834,107.983C34.783,109.033 34.783,110.739 35.834,111.789L75.986,151.942C77.037,152.992 78.742,152.992 79.793,151.942L83.6,148.135Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M39.64,151.942C40.691,152.992 42.397,152.992 43.447,151.942L83.6,111.789C84.65,110.739 84.65,109.033 83.6,107.983L79.793,104.176C78.742,103.125 77.037,103.125 75.986,104.176L35.834,144.328C34.783,145.379 34.783,147.085 35.834,148.135L39.64,151.942Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M208.991,56.973C210.042,55.923 210.042,54.217 208.991,53.167L168.839,13.014C167.788,11.964 166.082,11.964 165.032,13.014L161.225,16.821C160.175,17.871 160.175,19.577 161.225,20.628L201.378,60.78C202.428,61.831 204.134,61.831 205.184,60.78L208.991,56.973Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M165.032,60.78C166.082,61.831 167.788,61.831 168.839,60.78L208.991,20.628C210.042,19.577 210.042,17.871 208.991,16.821L205.184,13.014C204.134,11.964 202.428,11.964 201.378,13.014L161.225,53.167C160.175,54.217 160.175,55.923 161.225,56.973L165.032,60.78Z\" style=\"fill:rgb(68,68,68);\"/><circle cx=\"152.319\" cy=\"231.439\" r=\"9.269\" style=\"fill:rgb(68,68,68);\"/><circle cx=\"144.098\" cy=\"204.26\" r=\"9.269\" style=\"fill:rgb(68,68,68);\"/><circle cx=\"128.545\" cy=\"179.765\" r=\"9.269\" style=\"fill:rgb(68,68,68);\"/><circle cx=\"106.517\" cy=\"160.825\" r=\"9.269\" style=\"fill:rgb(68,68,68);\"/><circle cx=\"104.971\" cy=\"101.655\" r=\"9.269\" style=\"fill:rgb(68,68,68);\"/><circle cx=\"133.914\" cy=\"98.229\" r=\"9.269\" style=\"fill:rgb(68,68,68);\"/><circle cx=\"160.043\" cy=\"90.386\" r=\"9.269\" style=\"fill:rgb(68,68,68);\"/><circle cx=\"181.363\" cy=\"74.341\" r=\"9.269\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Find":s+"<g id=\"Find\"><path d=\"M96.236,24.018C135.605,24.018 167.567,55.98 167.567,95.348C167.567,134.716 135.605,166.678 96.236,166.678C56.868,166.678 24.906,134.716 24.906,95.348C24.906,55.98 56.868,24.018 96.236,24.018ZM96.236,37.881C127.953,37.881 153.703,63.631 153.703,95.348C153.703,127.065 127.953,152.815 96.236,152.815C64.52,152.815 38.77,127.065 38.77,95.348C38.77,63.631 64.52,37.881 96.236,37.881Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M229.158,220.692C231.739,218.11 231.739,213.918 229.158,211.337L153.102,135.281C150.52,132.699 146.329,132.699 143.747,135.281L134.392,144.636C131.811,147.217 131.811,151.409 134.392,153.99L210.448,230.046C213.03,232.628 217.221,232.628 219.803,230.046L229.158,220.692Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Popout":s+"<g id=\"Popout\"><path d=\"M133.31,64.585L133.31,80.419L85.301,80.419C76.437,80.42 69.242,87.615 69.242,96.478L69.242,171.419C69.242,180.283 76.438,187.478 85.301,187.478L160.243,187.478C169.106,187.478 176.302,180.283 176.302,171.419L176.302,123.41L192.135,123.41L192.135,182.503C192.135,193.988 182.811,203.312 171.326,203.312L74.218,203.312C62.733,203.312 53.409,193.988 53.409,182.503L53.409,85.394C53.409,73.91 62.732,64.586 74.218,64.585L133.31,64.585Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M152.113,95.302C149.956,93.145 146.454,93.145 144.297,95.302L118.864,120.735C116.707,122.892 116.707,126.394 118.864,128.551L126.68,136.367C128.837,138.524 132.339,138.524 134.496,136.367L159.929,110.934C162.086,108.777 162.086,105.275 159.929,103.118L152.113,95.302Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M158.594,112.314L142.965,96.686L172.451,67.2L157.939,52.688L202.591,52.688L202.591,97.34L188.08,82.828L158.594,112.314Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Download":s+"<g id=\"Download\"><path d=\"M133.561,100.501C136.611,100.501 139.088,98.025 139.088,94.974L139.088,59.006C139.088,55.956 136.611,53.479 133.561,53.479L122.507,53.479C119.457,53.479 116.981,55.956 116.981,59.006L116.981,94.974C116.981,98.025 119.457,100.501 122.507,100.501L133.561,100.501Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M116.949,93.054L139.051,93.054L139.051,134.753L159.574,134.753L128,166.327L96.426,134.753L116.949,134.753L116.949,93.054Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M207.196,182.676C207.196,179.025 204.232,176.061 200.581,176.061L55.419,176.061C51.768,176.061 48.804,179.025 48.804,182.676L48.804,195.906C48.804,199.557 51.768,202.521 55.419,202.521L200.581,202.521C204.232,202.521 207.196,199.557 207.196,195.906L207.196,182.676Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Upload":s+"<g id=\"Upload\"><path d=\"M122.439,119.305C119.389,119.305 116.912,121.782 116.912,124.832L116.912,160.8C116.912,163.851 119.389,166.327 122.439,166.327L133.493,166.327C136.543,166.327 139.019,163.851 139.019,160.8L139.019,124.832C139.019,121.782 136.543,119.305 133.493,119.305L122.439,119.305Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M139.051,126.753L116.949,126.753L116.949,85.053L96.426,85.053L128,53.479L159.574,85.053L139.051,85.053L139.051,126.753Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M207.196,182.676C207.196,179.025 204.232,176.061 200.581,176.061L55.419,176.061C51.768,176.061 48.804,179.025 48.804,182.676L48.804,195.906C48.804,199.557 51.768,202.521 55.419,202.521L200.581,202.521C204.232,202.521 207.196,199.557 207.196,195.906L207.196,182.676Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Warning":s+"<path id=\"Warning\" d=\"M128,27.284C183.587,27.284 228.716,72.413 228.716,128C228.716,183.587 183.587,228.716 128,228.716C72.413,228.716 27.284,183.587 27.284,128C27.284,72.413 72.413,27.284 128,27.284ZM128,175.059C135.302,175.059 141.23,180.987 141.23,188.288C141.23,195.59 135.302,201.518 128,201.518C120.698,201.518 114.77,195.59 114.77,188.288C114.77,180.987 120.698,175.059 128,175.059ZM128.265,54.482L127.735,54.482C120.58,54.482 114.77,60.292 114.77,67.447L114.77,152.094C114.77,159.249 120.58,165.059 127.735,165.059L128.265,165.059C135.42,165.059 141.23,159.249 141.23,152.094L141.23,67.447C141.23,60.292 135.42,54.482 128.265,54.482Z\" style=\"fill:rgb(68,68,68);\"/></svg>",
"Help":s+"<path id=\"Help\" d=\"M128,27.284C183.587,27.284 228.716,72.413 228.716,128C228.716,183.587 183.587,228.716 128,228.716C72.413,228.716 27.284,183.587 27.284,128C27.284,72.413 72.413,27.284 128,27.284ZM126.84,201.518C122.91,201.518 119.478,200.239 116.547,197.682C113.615,195.124 112.149,191.547 112.149,186.95C112.149,182.871 113.566,179.44 116.402,176.656C119.237,173.872 122.716,172.48 126.84,172.48C130.9,172.48 134.315,173.872 137.085,176.656C139.856,179.44 141.242,182.871 141.242,186.95C141.242,191.482 139.792,195.043 136.892,197.633C133.993,200.223 130.642,201.518 126.84,201.518ZM79.673,95.077C79.673,88.926 81.638,82.695 85.569,76.382C89.5,70.069 95.234,64.841 102.773,60.698C110.312,56.554 119.108,54.482 129.16,54.482C138.503,54.482 146.751,56.214 153.903,59.678C161.056,63.142 166.581,67.852 170.479,73.808C174.378,79.765 176.327,86.24 176.327,93.232C176.327,98.735 175.215,103.559 172.992,107.702C170.769,111.846 168.127,115.423 165.067,118.434C162.006,121.445 156.513,126.511 148.587,133.633C146.396,135.64 144.641,137.404 143.32,138.926C141.999,140.447 141.016,141.839 140.372,143.102C139.727,144.364 139.228,145.627 138.874,146.889C138.519,148.152 137.988,150.369 137.279,153.542C136.054,160.275 132.221,163.642 125.777,163.642C122.426,163.642 119.607,162.541 117.32,160.34C115.032,158.139 113.889,154.869 113.889,150.531C113.889,145.093 114.726,140.382 116.402,136.401C118.077,132.419 120.3,128.923 123.071,125.912C125.841,122.901 129.579,119.324 134.283,115.181C138.406,111.555 141.387,108.819 143.223,106.974C145.059,105.129 146.606,103.073 147.862,100.807C149.119,98.541 149.747,96.081 149.747,93.426C149.747,88.247 147.83,83.876 143.996,80.315C140.162,76.754 135.217,74.974 129.16,74.974C122.072,74.974 116.853,76.771 113.502,80.364C110.151,83.957 107.316,89.25 104.996,96.243C102.806,103.559 98.649,107.217 92.528,107.217C88.92,107.217 85.875,105.938 83.394,103.381C80.913,100.823 79.673,98.055 79.673,95.077Z\" style=\"fill:rgb(68,68,68);\"/></svg>",
"Message":s+"<path id=\"Message\" d=\"M31.531,117.021C31.531,82.686 74.757,54.809 128,54.809C181.243,54.809 224.469,82.686 224.469,117.021C224.469,135.655 211.517,153.308 189.175,165.125L195.528,201.191L153.548,177.012C145.224,178.486 136.632,179.233 128,179.233C74.757,179.233 31.531,151.357 31.531,117.021Z\" style=\"fill:rgb(68,68,68);\"/></svg>",
"Favorite":s+"<path id=\"Favorite\" d=\"M128,77.646C146.049,45.893 182.148,45.893 200.197,61.77C218.247,77.646 218.247,109.399 200.197,141.153C187.563,164.968 155.074,188.782 128,204.659C100.926,188.782 68.437,164.968 55.802,141.153C37.753,109.399 37.753,77.646 55.802,61.77C73.852,45.893 109.95,45.893 128,77.646Z\" style=\"fill:rgb(68,68,68);\"/></svg>",
"Dashboard":s+"<g id=\"Dashboard\"><path d=\"M171.203,63.749C171.203,60.99 168.963,58.749 166.203,58.749L37.212,58.749C34.453,58.749 32.212,60.99 32.212,63.749L32.212,148.489C32.212,151.248 34.453,153.489 37.212,153.489L166.203,153.489C168.963,153.489 171.203,151.248 171.203,148.489L171.203,63.749Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M223.788,167.489C223.788,164.729 221.547,162.489 218.788,162.489L37.212,162.489C34.453,162.489 32.212,164.729 32.212,167.489L32.212,192.251C32.212,195.01 34.453,197.251 37.212,197.251L218.788,197.251C221.547,197.251 223.788,195.01 223.788,192.251L223.788,167.489Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M223.788,63.749C223.788,60.99 221.547,58.749 218.788,58.749L185.969,58.749C183.209,58.749 180.969,60.99 180.969,63.749L180.969,96.522C180.969,99.281 183.209,101.522 185.969,101.522L218.788,101.522C221.547,101.522 223.788,99.281 223.788,96.522L223.788,63.749Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M223.788,115.716C223.788,112.956 221.547,110.716 218.788,110.716L185.969,110.716C183.209,110.716 180.969,112.956 180.969,115.716L180.969,148.489C180.969,151.248 183.209,153.489 185.969,153.489L218.788,153.489C221.547,153.489 223.788,151.248 223.788,148.489L223.788,115.716Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Sync":s+"<g id=\"Sync\"><path d=\"M155.824,31.805C130.683,25.068 103.895,28.595 81.354,41.609C34.414,68.709 18.331,128.731 45.432,175.671L70.929,160.95C51.959,128.092 63.217,86.077 96.075,67.106C111.853,57.996 130.605,55.528 148.204,60.243L155.824,31.805Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M190.398,56.588L142.615,77.927L159.686,14.217L190.398,56.588Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M100.176,224.195C125.317,230.932 152.105,227.405 174.646,214.391C221.586,187.291 237.669,127.269 210.568,80.329L185.071,95.05C204.041,127.908 192.783,169.923 159.925,188.894C144.147,198.004 125.395,200.472 107.796,195.757L100.176,224.195Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M65.602,199.412L113.385,178.073L96.314,241.783L65.602,199.412Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"SyncError":s+"<g id=\"SyncError\"><path d=\"M155.824,31.805C130.683,25.068 103.895,28.595 81.354,41.609C34.414,68.709 18.331,128.731 45.432,175.671L70.929,160.95C51.959,128.092 63.217,86.077 96.075,67.106C111.853,57.996 130.605,55.528 148.204,60.243L155.824,31.805Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M190.398,56.588L142.615,77.927L159.686,14.217L190.398,56.588Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M133.459,227.222C122.377,228.116 111.12,227.128 100.176,224.195L107.796,195.757C112.06,196.899 116.392,197.62 120.733,197.927C122.561,208.81 127.031,218.803 133.459,227.222ZM193.72,120.548C192.589,111.814 189.749,103.154 185.071,95.05L210.568,80.329C219.889,96.473 224.102,114.164 223.708,131.532C214.962,125.627 204.742,121.742 193.72,120.548Z\" style=\"fill:rgb(68,68,68);\"/><path id=\"ErrorAlarrt\" d=\"M186.473,131.897C216.786,131.897 241.396,156.508 241.396,186.821C241.396,217.134 216.786,241.744 186.473,241.744C156.16,241.744 131.549,217.134 131.549,186.821C131.549,156.508 156.16,131.897 186.473,131.897ZM186.473,212.483C190.455,212.483 193.687,215.716 193.687,219.698C193.687,223.68 190.455,226.912 186.473,226.912C182.491,226.912 179.258,223.68 179.258,219.698C179.258,215.716 182.491,212.483 186.473,212.483ZM186.617,146.729L186.329,146.729C182.426,146.729 179.258,149.897 179.258,153.799L179.258,199.96C179.258,203.862 182.426,207.03 186.329,207.03L186.617,207.03C190.519,207.03 193.687,203.862 193.687,199.96L193.687,153.799C193.687,149.897 190.519,146.729 186.617,146.729Z\" style=\"fill:rgb(255,153,71);\"/><path d=\"M65.602,199.412L113.385,178.073L96.314,241.783L65.602,199.412Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"ErrorAlarrt":s+"<path id=\"ErrorAlarrt\" d=\"M186.473,131.897C216.786,131.897 241.396,156.508 241.396,186.821C241.396,217.134 216.786,241.744 186.473,241.744C156.16,241.744 131.549,217.134 131.549,186.821C131.549,156.508 156.16,131.897 186.473,131.897ZM186.473,212.483C190.455,212.483 193.687,215.716 193.687,219.698C193.687,223.68 190.455,226.912 186.473,226.912C182.491,226.912 179.258,223.68 179.258,219.698C179.258,215.716 182.491,212.483 186.473,212.483ZM186.617,146.729L186.329,146.729C182.426,146.729 179.258,149.897 179.258,153.799L179.258,199.96C179.258,203.862 182.426,207.03 186.329,207.03L186.617,207.03C190.519,207.03 193.687,203.862 193.687,199.96L193.687,153.799C193.687,149.897 190.519,146.729 186.617,146.729Z\" style=\"fill:rgb(255,153,71);\"/></svg>",
"Report":s+"<g id=\"Report\"><path d=\"M239.702,200.633C239.702,196.983 236.738,194.019 233.087,194.019L22.913,194.019C19.262,194.019 16.298,196.983 16.298,200.633L16.298,213.863C16.298,217.514 19.262,220.478 22.913,220.478L233.087,220.478C236.738,220.478 239.702,217.514 239.702,213.863L239.702,200.633Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M36.143,220.478C39.794,220.478 42.758,217.514 42.758,213.863L42.758,42.137C42.758,38.486 39.794,35.522 36.143,35.522L22.913,35.522C19.262,35.522 16.298,38.486 16.298,42.137L16.298,213.863C16.298,217.514 19.262,220.478 22.913,220.478L36.143,220.478Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M82.602,174.019C86.253,174.019 89.217,171.055 89.217,167.404L89.217,74.321C89.217,70.67 86.253,67.706 82.602,67.706L69.372,67.706C65.722,67.706 62.758,70.67 62.758,74.321L62.758,167.404C62.758,171.055 65.722,174.019 69.372,174.019L82.602,174.019Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M122.602,174.019C126.253,174.019 129.217,171.055 129.217,167.404L129.217,95.293C129.217,91.642 126.253,88.678 122.602,88.678L109.372,88.678C105.722,88.678 102.758,91.642 102.758,95.293L102.758,167.404C102.758,171.055 105.722,174.019 109.372,174.019L122.602,174.019Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M162.602,174.019C166.253,174.019 169.217,171.055 169.217,167.404L169.217,59.248C169.217,55.597 166.253,52.633 162.602,52.633L149.372,52.633C145.722,52.633 142.758,55.597 142.758,59.248L142.758,167.404C142.758,171.055 145.722,174.019 149.372,174.019L162.602,174.019Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M202.602,174.019C206.253,174.019 209.217,171.055 209.217,167.404L209.217,111.24C209.217,107.589 206.253,104.625 202.602,104.625L189.372,104.625C185.722,104.625 182.758,107.589 182.758,111.24L182.758,167.404C182.758,171.055 185.722,174.019 189.372,174.019L202.602,174.019Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Back":s+"<g id=\"Back\"><path d=\"M154.35,133.561C154.35,136.611 156.827,139.088 159.877,139.088L194.087,139.088C197.137,139.088 199.613,136.611 199.613,133.561L199.613,122.507C199.613,119.457 197.137,116.981 194.087,116.981L159.877,116.981C156.827,116.981 154.35,119.457 154.35,122.507L154.35,133.561Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M166.176,116.949L166.176,139.051L87.96,139.051L87.96,159.574L56.387,128L87.96,96.426L87.96,116.949L166.176,116.949Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M128,20.888C187.117,20.888 235.112,68.883 235.112,128C235.112,187.117 187.117,235.112 128,235.112C68.883,235.112 20.888,187.117 20.888,128C20.888,68.883 68.883,20.888 128,20.888ZM128,42.31C175.293,42.31 213.69,80.707 213.69,128C213.69,175.293 175.293,213.69 128,213.69C80.707,213.69 42.31,175.293 42.31,128C42.31,80.707 80.707,42.31 128,42.31Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Next":s+"<g id=\"Next\"><path d=\"M101.65,122.439C101.65,119.389 99.173,116.912 96.123,116.912L61.913,116.912C58.863,116.912 56.387,119.389 56.387,122.439L56.387,133.493C56.387,136.543 58.863,139.019 61.913,139.019L96.123,139.019C99.173,139.019 101.65,136.543 101.65,133.493L101.65,122.439Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M89.824,139.051L89.824,116.949L168.04,116.949L168.04,96.426L199.613,128L168.04,159.574L168.04,139.051L89.824,139.051Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M128,20.888C187.117,20.888 235.112,68.883 235.112,128C235.112,187.117 187.117,235.112 128,235.112C68.883,235.112 20.888,187.117 20.888,128C20.888,68.883 68.883,20.888 128,20.888ZM128,42.31C175.293,42.31 213.69,80.707 213.69,128C213.69,175.293 175.293,213.69 128,213.69C80.707,213.69 42.31,175.293 42.31,128C42.31,80.707 80.707,42.31 128,42.31Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"OK":s+"<g id=\"OK\"><path d=\"M76.087,122.629C73.93,124.786 73.93,128.289 76.087,130.445L111.695,166.054C113.852,168.211 117.355,168.211 119.511,166.054L127.328,158.238C129.484,156.081 129.484,152.578 127.328,150.422L91.719,114.813C89.562,112.656 86.06,112.656 83.903,114.813L76.087,122.629Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M111.622,166.054C113.778,168.211 117.281,168.211 119.438,166.054L179.913,105.578C182.07,103.422 182.07,99.919 179.913,97.762L172.097,89.946C169.94,87.789 166.438,87.789 164.281,89.946L103.805,150.422C101.649,152.578 101.649,156.081 103.805,158.238L111.622,166.054Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M128,20.888C187.117,20.888 235.112,68.883 235.112,128C235.112,187.117 187.117,235.112 128,235.112C68.883,235.112 20.888,187.117 20.888,128C20.888,68.883 68.883,20.888 128,20.888ZM128,42.31C175.293,42.31 213.69,80.707 213.69,128C213.69,175.293 175.293,213.69 128,213.69C80.707,213.69 42.31,175.293 42.31,128C42.31,80.707 80.707,42.31 128,42.31Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Cancel":s+"<g id=\"Cancel\"><path d=\"M97.762,166.054C99.919,168.211 103.422,168.211 105.578,166.054L166.054,105.578C168.211,103.422 168.211,99.919 166.054,97.762L158.238,89.946C156.081,87.789 152.578,87.789 150.422,89.946L89.946,150.422C87.789,152.578 87.789,156.081 89.946,158.238L97.762,166.054Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M166.054,158.238C168.211,156.081 168.211,152.578 166.054,150.422L105.578,89.946C103.422,87.789 99.919,87.789 97.762,89.946L89.946,97.762C87.789,99.919 87.789,103.422 89.946,105.578L150.422,166.054C152.578,168.211 156.081,168.211 158.238,166.054L166.054,158.238Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M128,20.888C187.117,20.888 235.112,68.883 235.112,128C235.112,187.117 187.117,235.112 128,235.112C68.883,235.112 20.888,187.117 20.888,128C20.888,68.883 68.883,20.888 128,20.888ZM128,42.31C175.293,42.31 213.69,80.707 213.69,128C213.69,175.293 175.293,213.69 128,213.69C80.707,213.69 42.31,175.293 42.31,128C42.31,80.707 80.707,42.31 128,42.31Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Text":s+"<g id=\"Text\"><path d=\"M92.733,209.127C92.445,213.464 92.445,218.09 92.445,222.715C104.541,222.715 117.79,222.427 129.915,222.427C141.745,222.427 155.834,222.715 166.185,222.715C166.185,218.38 166.472,213.175 166.472,209.127L140.018,208.262L140.882,49.654C165.61,49.654 170.785,49.654 178.549,50.517C183.724,50.805 185.162,52.532 185.449,55.699L190.05,83.908C195.51,83.333 201.257,82.757 206.142,82.181C205.567,66.349 204.705,50.517 203.843,35.002C197.521,35.002 190.625,35.002 178.836,35.29L81.213,35.29C69.693,35.29 60.189,35.002 54.717,35.002C53.565,50.599 52.989,66.745 51.837,82.603C57.021,83.179 62.781,83.467 67.965,84.042L72.573,55.986C73.149,52.82 74.301,51.093 79.773,50.517C86.397,49.941 92.445,49.366 117.213,49.366L117.213,207.11C117.213,207.686 116.925,208.262 116.061,208.262L92.733,209.127Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/></g></svg>",
"Table":s+"<g id=\"Table\"><path d=\"M27.287,88.511C27.287,91.271 29.643,93.511 32.544,93.511L223.456,93.511C226.357,93.511 228.713,91.271 228.713,88.511L228.713,63.749C228.713,60.99 226.357,58.749 223.456,58.749L32.544,58.749C29.643,58.749 27.287,60.99 27.287,63.749L27.287,88.511Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M27.287,192.251C27.287,195.01 29.528,197.251 32.287,197.251L65.106,197.251C67.866,197.251 70.106,195.01 70.106,192.251L70.106,159.478C70.106,156.719 67.866,154.478 65.106,154.478L32.287,154.478C29.528,154.478 27.287,156.719 27.287,159.478L27.287,192.251Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M80.106,192.251C80.106,195.01 82.347,197.251 85.106,197.251L117.925,197.251C120.685,197.251 122.925,195.01 122.925,192.251L122.925,159.478C122.925,156.719 120.685,154.478 117.925,154.478L85.106,154.478C82.347,154.478 80.106,156.719 80.106,159.478L80.106,192.251Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M27.287,140.284C27.287,143.044 29.528,145.284 32.287,145.284L65.106,145.284C67.866,145.284 70.106,143.044 70.106,140.284L70.106,107.511C70.106,104.752 67.866,102.511 65.106,102.511L32.287,102.511C29.528,102.511 27.287,104.752 27.287,107.511L27.287,140.284Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M80.106,140.284C80.106,143.044 82.347,145.284 85.106,145.284L117.925,145.284C120.685,145.284 122.925,143.044 122.925,140.284L122.925,107.511C122.925,104.752 120.685,102.511 117.925,102.511L85.106,102.511C82.347,102.511 80.106,104.752 80.106,107.511L80.106,140.284Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M80.106,192.251C80.106,195.01 82.347,197.251 85.106,197.251L117.925,197.251C120.685,197.251 122.925,195.01 122.925,192.251L122.925,159.478C122.925,156.719 120.685,154.478 117.925,154.478L85.106,154.478C82.347,154.478 80.106,156.719 80.106,159.478L80.106,192.251Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M133.075,192.251C133.075,195.01 135.316,197.251 138.075,197.251L170.894,197.251C173.654,197.251 175.894,195.01 175.894,192.251L175.894,159.478C175.894,156.719 173.654,154.478 170.894,154.478L138.075,154.478C135.316,154.478 133.075,156.719 133.075,159.478L133.075,192.251Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M185.894,192.251C185.894,195.01 188.135,197.251 190.894,197.251L223.713,197.251C226.473,197.251 228.713,195.01 228.713,192.251L228.713,159.478C228.713,156.719 226.473,154.478 223.713,154.478L190.894,154.478C188.135,154.478 185.894,156.719 185.894,159.478L185.894,192.251Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M133.075,140.284C133.075,143.044 135.316,145.284 138.075,145.284L170.894,145.284C173.654,145.284 175.894,143.044 175.894,140.284L175.894,107.511C175.894,104.752 173.654,102.511 170.894,102.511L138.075,102.511C135.316,102.511 133.075,104.752 133.075,107.511L133.075,140.284Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M185.894,140.284C185.894,143.044 188.135,145.284 190.894,145.284L223.713,145.284C226.473,145.284 228.713,143.044 228.713,140.284L228.713,107.511C228.713,104.752 226.473,102.511 223.713,102.511L190.894,102.511C188.135,102.511 185.894,104.752 185.894,107.511L185.894,140.284Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M185.894,192.251C185.894,195.01 188.135,197.251 190.894,197.251L223.713,197.251C226.473,197.251 228.713,195.01 228.713,192.251L228.713,159.478C228.713,156.719 226.473,154.478 223.713,154.478L190.894,154.478C188.135,154.478 185.894,156.719 185.894,159.478L185.894,192.251Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Gauge":s+"<g id=\"Gauge\"><path d=\"M227.08,171.278C227.08,116.558 182.72,72.198 128,72.198C73.28,72.198 28.92,116.558 28.92,171.278L53.69,171.278C53.69,130.238 86.96,96.968 128,96.968C169.04,96.968 202.31,130.238 202.31,171.278L227.08,171.278Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M136.298,161.895C141.476,166.474 141.963,174.397 137.383,179.576C132.804,184.755 124.881,185.241 119.702,180.661C114.524,176.082 114.037,168.159 118.617,162.98C123.196,157.802 131.119,157.315 136.298,161.895Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M172.483,127.675C173.384,126.657 173.288,125.099 172.269,124.198L168.579,120.934C167.56,120.034 166.002,120.129 165.101,121.148L125.217,166.25C124.316,167.268 124.412,168.826 125.431,169.727L129.121,172.991C130.14,173.892 131.698,173.796 132.599,172.777L172.483,127.675Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Donut":s+"<g id=\"Donut\"><path d=\"M226.944,119.584C224.186,66.952 180.705,25.69 128,25.69C110.608,25.69 93.522,30.268 78.46,38.964L90.845,60.416C102.142,53.894 114.956,50.46 128,50.46C167.529,50.46 200.139,81.406 202.208,120.881L226.944,119.584Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M71.17,43.608C52.089,56.969 38.325,76.626 32.296,99.126L56.222,105.537C60.744,88.662 71.067,73.919 85.378,63.899L71.17,43.608Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M30.426,107.565C29.424,113.245 28.92,119.002 28.92,124.77C28.92,179.453 73.316,223.85 128,223.85C181.374,223.85 225.157,181.57 227.019,128.228L202.265,127.363C200.867,167.37 168.031,199.08 128,199.08C86.987,199.08 53.69,165.782 53.69,124.77C53.69,120.444 54.068,116.126 54.819,111.866L30.426,107.565Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Left":s+"<g id=\"Left\"><path d=\"M51.003,139.685L98.736,198.893L83.141,211.466L15.852,128L83.141,44.534L98.736,57.107L51.003,116.315L240.148,116.315L240.148,139.685L51.003,139.685Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Right":s+"<g id=\"Right\"><path d=\"M240.148,128L172.859,211.466L157.264,198.893L204.997,139.685L15.852,139.685L15.852,116.315L204.997,116.315L157.264,57.107L172.859,44.534L240.148,128Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Up":s+"<g id=\"Up\"><path d=\"M128,15.852L211.466,83.141L198.893,98.736L139.685,51.003L139.685,240.148L116.315,240.148L116.315,51.003L57.107,98.736L44.534,83.141L128,15.852Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"TextIncrease":s+"<g id=\"TextIncrease\"><path d=\"M191.733,115.849L231.18,147.651L225.238,155.022L197.255,132.462L197.255,221.856L186.21,221.856L186.21,132.462L158.227,155.022L152.285,147.651L191.733,115.849Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M65.716,208.268C65.428,212.605 65.428,217.231 65.428,221.856C77.524,221.856 90.773,221.568 102.897,221.568C114.727,221.568 128.816,221.856 139.167,221.856C139.167,217.521 139.455,212.316 139.455,208.268L113.001,207.403L113.865,48.795C138.592,48.795 143.768,48.795 151.531,49.658C156.707,49.946 158.144,51.673 158.432,54.84L163.033,83.049C168.492,82.474 174.24,81.898 179.125,81.322C178.55,65.49 177.688,49.658 176.826,34.143C170.504,34.143 163.607,34.143 151.819,34.431L54.196,34.431C42.676,34.431 33.172,34.143 27.7,34.143C26.548,49.74 25.972,65.886 24.82,81.744C30.004,82.32 35.764,82.608 40.948,83.183L45.556,55.127C46.132,51.961 47.284,50.234 52.756,49.658C59.38,49.082 65.428,48.507 90.196,48.507L90.196,206.251C90.196,206.827 89.908,207.403 89.044,207.403L65.716,208.268Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/></g></svg>",
"TextDecrease":s+"<g id=\"TextDecrease\"><path d=\"M191.733,221.857L152.285,190.054L158.227,182.684L186.21,205.243L186.21,115.849L197.255,115.849L197.255,205.243L225.238,182.684L231.18,190.054L191.733,221.857Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M74.917,211.717C74.702,214.953 74.702,218.405 74.702,221.856C83.728,221.856 93.615,221.642 102.662,221.642C111.49,221.642 122.004,221.856 129.728,221.856C129.728,218.621 129.943,214.737 129.943,211.717L110.202,211.071L110.847,92.714C129.299,92.714 133.161,92.714 138.954,93.358C142.816,93.573 143.889,94.862 144.104,97.225L147.537,118.275C151.611,117.846 155.9,117.416 159.545,116.987C159.116,105.172 158.473,93.358 157.83,81.781C153.112,81.781 147.966,81.781 139.169,81.996L66.32,81.996C57.724,81.996 50.631,81.781 46.548,81.781C45.688,93.419 45.259,105.468 44.399,117.301C48.267,117.731 52.566,117.946 56.434,118.375L59.873,97.439C60.303,95.077 61.162,93.788 65.246,93.358C70.189,92.928 74.702,92.499 93.184,92.499L93.184,210.212C93.184,210.641 92.969,211.071 92.324,211.071L74.917,211.717Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/></g></svg>",
"Down":s+"<g id=\"Down\"><path d=\"M139.685,15.852L139.685,204.997L198.893,157.264L211.466,172.859L128,240.148L44.534,172.859L57.107,157.264L116.315,204.997L116.315,15.852L139.685,15.852Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"TextItalic":s+"<g id=\"TextItalic\"><path d=\"M126.933,210.319L94.702,210.319L119.633,91.052L151.865,91.052L126.933,210.319ZM155.234,74.88L123.002,74.88L129.067,45.681L161.298,45.681L155.234,74.88Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/></g></svg>",
"TextBold":s+"<g id=\"TextBold\"><path d=\"M59.045,210.319L59.045,45.681L124.855,45.681C137.883,45.681 147.597,46.223 153.999,47.309C160.4,48.395 166.127,50.66 171.181,54.104C176.235,57.548 180.446,62.133 183.815,67.861C187.185,73.588 188.869,80.008 188.869,87.121C188.869,94.833 186.792,101.908 182.636,108.347C178.481,114.785 172.847,119.615 165.734,122.834C175.767,125.754 183.479,130.733 188.869,137.771C194.26,144.808 196.955,153.081 196.955,162.59C196.955,170.077 195.214,177.358 191.733,184.433C188.251,191.508 183.497,197.161 177.47,201.391C171.443,205.621 164.012,208.223 155.178,209.196C149.811,209.776 137.102,210.146 117.048,210.305L115.085,210.319L59.045,210.319ZM124.169,182.579C135.509,182.559 142.738,182.222 145.856,181.569C150.798,180.671 154.822,178.481 157.929,175C161.036,171.518 162.59,166.857 162.59,161.018C162.59,156.076 161.392,151.883 158.996,148.439C156.6,144.995 153.138,142.487 148.608,140.915C144.078,139.343 134.252,138.557 119.128,138.557L92.287,138.557L92.287,182.58L123.059,182.58L124.169,182.579ZM116.445,111.152C128.014,111.13 135.272,110.944 138.22,110.593C143.91,109.919 148.383,107.954 151.64,104.697C154.897,101.44 156.525,97.154 156.525,91.838C156.525,86.747 155.122,82.61 152.314,79.428C149.506,76.246 145.332,74.318 139.792,73.645C136.498,73.27 127.027,73.083 111.379,73.083L92.287,73.083L92.287,111.154L114.074,111.154L116.445,111.152Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/></g></svg>",
"TextUnderline":s+"<g id=\"TextUnderline\"><g><path d=\"M76.632,44.599L102.646,44.599L102.646,114.378C102.646,125.451 102.968,132.629 103.612,135.909C104.726,141.182 107.377,145.416 111.566,148.609C115.755,151.802 121.482,153.398 128.747,153.398C136.129,153.398 141.695,151.89 145.445,148.872C149.195,145.855 151.45,142.149 152.212,137.755C152.973,133.361 153.354,126.067 153.354,115.872L153.354,44.599L179.368,44.599L179.368,112.269C179.368,127.736 178.665,138.663 177.259,145.049C175.852,151.436 173.26,156.826 169.481,161.22C165.702,165.614 160.649,169.115 154.321,171.722C147.993,174.329 139.732,175.633 129.538,175.633C117.234,175.633 107.904,174.212 101.547,171.37C95.19,168.529 90.166,164.838 86.475,160.297C82.784,155.756 80.353,150.996 79.181,146.016C77.482,138.634 76.632,127.736 76.632,113.324L76.632,44.599Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/><rect x=\"63.713\" y=\"192.506\" width=\"129.979\" height=\"18.895\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/></g></g></svg>",
"TextAlignLeft":s+"<g id=\"TextAlignLeft\"><path d=\"M37.077,71.468C37.077,73.96 39.204,75.982 41.823,75.982L214.177,75.982C216.796,75.982 218.923,73.96 218.923,71.468L218.923,49.113C218.923,46.622 216.796,44.599 214.177,44.599L41.823,44.599C39.204,44.599 37.077,46.622 37.077,49.113L37.077,71.468Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M37.077,116.608C37.077,119.099 38.601,121.122 40.477,121.122L163.944,121.122C165.82,121.122 167.344,119.099 167.344,116.608L167.344,94.253C167.344,91.762 165.82,89.739 163.944,89.739L40.477,89.739C38.601,89.739 37.077,91.762 37.077,94.253L37.077,116.608Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M37.077,161.747C37.077,164.239 39.204,166.261 41.823,166.261L214.177,166.261C216.796,166.261 218.923,164.239 218.923,161.747L218.923,139.392C218.923,136.902 216.796,134.878 214.177,134.878L41.823,134.878C39.204,134.878 37.077,136.902 37.077,139.392L37.077,161.747Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M37.077,206.887C37.077,209.379 38.601,211.401 40.477,211.401L163.944,211.401C165.82,211.401 167.344,209.379 167.344,206.887L167.344,184.532C167.344,182.041 165.82,180.018 163.944,180.018L40.477,180.018C38.601,180.018 37.077,182.041 37.077,184.532L37.077,206.887Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"TextAlignRight":s+"<g id=\"TextAlignRight\"><path d=\"M37.077,71.468C37.077,73.96 39.204,75.982 41.823,75.982L214.177,75.982C216.796,75.982 218.923,73.96 218.923,71.468L218.923,49.113C218.923,46.622 216.796,44.599 214.177,44.599L41.823,44.599C39.204,44.599 37.077,46.622 37.077,49.113L37.077,71.468Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M88.656,116.608C88.656,119.099 90.18,121.122 92.056,121.122L215.523,121.122C217.399,121.122 218.923,119.099 218.923,116.608L218.923,94.253C218.923,91.762 217.399,89.739 215.523,89.739L92.056,89.739C90.18,89.739 88.656,91.762 88.656,94.253L88.656,116.608Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M37.077,161.747C37.077,164.239 39.204,166.261 41.823,166.261L214.177,166.261C216.796,166.261 218.923,164.239 218.923,161.747L218.923,139.392C218.923,136.902 216.796,134.878 214.177,134.878L41.823,134.878C39.204,134.878 37.077,136.902 37.077,139.392L37.077,161.747Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M88.656,206.887C88.656,209.379 90.18,211.401 92.056,211.401L215.523,211.401C217.399,211.401 218.923,209.379 218.923,206.887L218.923,184.532C218.923,182.041 217.399,180.018 215.523,180.018L92.056,180.018C90.18,180.018 88.656,182.041 88.656,184.532L88.656,206.887Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"TextAlignCenter":s+"<g id=\"TextAlignCenter\"><path d=\"M37.077,71.468C37.077,73.96 39.204,75.982 41.823,75.982L214.177,75.982C216.796,75.982 218.923,73.96 218.923,71.468L218.923,49.113C218.923,46.622 216.796,44.599 214.177,44.599L41.823,44.599C39.204,44.599 37.077,46.622 37.077,49.113L37.077,71.468Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M62.866,116.608C62.866,119.099 64.39,121.122 66.266,121.122L189.734,121.122C191.61,121.122 193.134,119.099 193.134,116.608L193.134,94.253C193.134,91.762 191.61,89.739 189.734,89.739L66.266,89.739C64.39,89.739 62.866,91.762 62.866,94.253L62.866,116.608Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M37.077,161.747C37.077,164.239 39.204,166.261 41.823,166.261L214.177,166.261C216.796,166.261 218.923,164.239 218.923,161.747L218.923,139.392C218.923,136.902 216.796,134.878 214.177,134.878L41.823,134.878C39.204,134.878 37.077,136.902 37.077,139.392L37.077,161.747Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M62.866,206.887C62.866,209.379 64.39,211.401 66.266,211.401L189.734,211.401C191.61,211.401 193.134,209.379 193.134,206.887L193.134,184.532C193.134,182.041 191.61,180.018 189.734,180.018L66.266,180.018C64.39,180.018 62.866,182.041 62.866,184.532L62.866,206.887Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"TextList":s+"<g id=\"TextList\"><circle cx=\"43.377\" cy=\"78\" r=\"11.633\" style=\"fill:rgb(68,68,68);\"/><path d=\"M224.256,72.184C224.256,68.974 221.65,66.367 218.44,66.367L78.37,66.367C75.159,66.367 72.553,68.974 72.553,72.184L72.553,83.816C72.553,87.026 75.159,89.633 78.37,89.633L218.44,89.633C221.65,89.633 224.256,87.026 224.256,83.816L224.256,72.184Z\" style=\"fill:rgb(68,68,68);\"/><circle cx=\"43.377\" cy=\"128\" r=\"11.633\" style=\"fill:rgb(68,68,68);\"/><path d=\"M224.256,122.184C224.256,118.974 221.65,116.367 218.44,116.367L78.37,116.367C75.159,116.367 72.553,118.974 72.553,122.184L72.553,133.816C72.553,137.026 75.159,139.633 78.37,139.633L218.44,139.633C221.65,139.633 224.256,137.026 224.256,133.816L224.256,122.184Z\" style=\"fill:rgb(68,68,68);\"/><circle cx=\"43.377\" cy=\"178\" r=\"11.633\" style=\"fill:rgb(68,68,68);\"/><path d=\"M224.256,172.184C224.256,168.974 221.65,166.367 218.44,166.367L78.37,166.367C75.159,166.367 72.553,168.974 72.553,172.184L72.553,183.816C72.553,187.026 75.159,189.633 78.37,189.633L218.44,189.633C221.65,189.633 224.256,187.026 224.256,183.816L224.256,172.184Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"TextIndent":s+"<g id=\"TextIndent\"><path d=\"M228.389,42.221C228.389,39.011 225.783,36.404 222.573,36.404L82.503,36.404C79.292,36.404 76.686,39.011 76.686,42.221L76.686,53.853C76.686,57.063 79.292,59.67 82.503,59.67L222.573,59.67C225.783,59.67 228.389,57.063 228.389,53.853L228.389,42.221Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M228.389,82.221C228.389,79.011 225.783,76.404 222.573,76.404L82.503,76.404C79.292,76.404 76.686,79.011 76.686,82.221L76.686,93.853C76.686,97.063 79.292,99.67 82.503,99.67L222.573,99.67C225.783,99.67 228.389,97.063 228.389,93.853L228.389,82.221Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M228.389,122.221C228.389,119.011 225.783,116.404 222.573,116.404L82.503,116.404C79.292,116.404 76.686,119.011 76.686,122.221L76.686,133.853C76.686,137.063 79.292,139.67 82.503,139.67L222.573,139.67C225.783,139.67 228.389,137.063 228.389,133.853L228.389,122.221Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M95.881,173.941L82.668,157.551L96.316,146.548L125.761,183.072L96.316,219.596L82.668,208.592L95.881,192.203L27.611,192.203L27.611,173.941L95.881,173.941Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"TextOutdent":s+"<g id=\"TextOutdent\"><path d=\"M27.611,42.221C27.611,39.011 30.217,36.404 33.427,36.404L173.497,36.404C176.708,36.404 179.314,39.011 179.314,42.221L179.314,53.853C179.314,57.063 176.708,59.67 173.497,59.67L33.427,59.67C30.217,59.67 27.611,57.063 27.611,53.853L27.611,42.221Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M27.611,82.221C27.611,79.011 30.217,76.404 33.427,76.404L173.497,76.404C176.708,76.404 179.314,79.011 179.314,82.221L179.314,93.853C179.314,97.063 176.708,99.67 173.497,99.67L33.427,99.67C30.217,99.67 27.611,97.063 27.611,93.853L27.611,82.221Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M27.611,122.221C27.611,119.011 30.217,116.404 33.427,116.404L173.497,116.404C176.708,116.404 179.314,119.011 179.314,122.221L179.314,133.853C179.314,137.063 176.708,139.67 173.497,139.67L33.427,139.67C30.217,139.67 27.611,137.063 27.611,133.853L27.611,122.221Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M160.119,173.941L173.332,157.551L159.684,146.548L130.239,183.072L159.684,219.596L173.332,208.592L160.119,192.203L228.389,192.203L228.389,173.941L160.119,173.941Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"TextQuoteBlock":s+"<g id=\"TextQuoteBlock\"><path d=\"M235.315,88.576C235.315,79.251 227.744,71.68 218.419,71.68L37.581,71.68C28.256,71.68 20.685,79.251 20.685,88.576L20.685,167.424C20.685,176.749 28.256,184.32 37.581,184.32L218.419,184.32C227.744,184.32 235.315,176.749 235.315,167.424L235.315,88.576ZM198.834,138.989C210.635,130.896 219.822,118.757 219.822,103.331C219.822,92.457 214.367,85.882 205.17,85.882C197.97,85.882 191.058,90.687 191.058,99.791C191.058,107.63 196.818,110.665 200.85,110.665C205.17,110.665 206.034,109.906 208.338,107.883C208.05,116.229 204.018,125.586 193.65,133.931L198.834,138.989ZM158.834,138.989C170.635,130.896 179.822,118.757 179.822,103.331C179.822,92.457 174.367,85.882 165.17,85.882C157.97,85.882 151.058,90.687 151.058,99.791C151.058,107.63 156.818,110.665 160.85,110.665C165.17,110.665 166.034,109.906 168.338,107.883C168.05,116.229 164.018,125.586 153.65,133.931L158.834,138.989Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"TextCodeBlock":s+"<g id=\"TextCodeBlock\"><g><path d=\"M235.315,88.576C235.315,79.251 227.744,71.68 218.419,71.68L37.581,71.68C28.256,71.68 20.685,79.251 20.685,88.576L20.685,167.424C20.685,176.749 28.256,184.32 37.581,184.32L218.419,184.32C227.744,184.32 235.315,176.749 235.315,167.424L235.315,88.576ZM159.45,143.805L173.911,80.742L182.317,80.742L167.697,143.805L159.45,143.805ZM186.022,135.859L186.022,124.087L213.988,112.606L186.022,101.25L186.022,89.561L226.099,107.656L226.099,117.64L186.022,135.859ZM155.745,135.818L115.708,117.64L115.708,107.573L155.745,89.478L155.745,101.333L127.819,112.481L155.745,124.046L155.745,135.818Z\" style=\"fill:rgb(68,68,68);\"/></g></g></svg>",
"Card":s+"<g id=\"Card\"><path d=\"M229.456,43.598C229.456,26.8 215.818,13.161 199.02,13.161L56.98,13.161C40.182,13.161 26.544,26.8 26.544,43.598L26.544,212.402C26.544,229.2 40.182,242.839 56.98,242.839L199.02,242.839C215.818,242.839 229.456,229.2 229.456,212.402L229.456,43.598ZM153.84,142.181L165.371,140.782C165.738,143.721 166.727,145.968 168.338,147.523C169.949,149.077 171.9,149.854 174.189,149.854C176.648,149.854 178.718,148.922 180.4,147.056C182.081,145.191 182.922,142.676 182.922,139.51C182.922,136.514 182.117,134.14 180.506,132.388C178.895,130.636 176.93,129.759 174.613,129.759C173.087,129.759 171.264,130.056 169.144,130.65L170.458,120.941C173.68,121.026 176.139,120.327 177.835,118.843C179.531,117.359 180.379,115.388 180.379,112.929C180.379,110.837 179.757,109.17 178.513,107.926C177.27,106.683 175.616,106.061 173.553,106.061C171.518,106.061 169.78,106.767 168.338,108.181C166.897,109.594 166.021,111.657 165.71,114.37L154.73,112.505C155.493,108.746 156.645,105.743 158.185,103.496C159.725,101.249 161.873,99.483 164.629,98.197C167.385,96.911 170.472,96.268 173.892,96.268C179.743,96.268 184.434,98.133 187.967,101.864C190.878,104.916 192.334,108.364 192.334,112.208C192.334,117.663 189.352,122.015 183.389,125.266C186.95,126.029 189.797,127.739 191.931,130.395C194.065,133.052 195.132,136.26 195.132,140.019C195.132,145.474 193.139,150.123 189.154,153.967C185.169,157.81 180.209,159.732 174.274,159.732C168.649,159.732 163.986,158.114 160.283,154.878C156.581,151.642 154.433,147.41 153.84,142.181ZM88.17,158.672L76.257,158.672L76.257,113.777C71.905,117.846 66.775,120.857 60.868,122.807L60.868,111.996C63.977,110.979 67.355,109.05 71,106.209C74.646,103.369 77.148,100.055 78.504,96.268L88.17,96.268L88.17,158.672ZM146.208,147.607L146.208,158.672L104.45,158.672C104.902,154.49 106.259,150.526 108.52,146.781C110.781,143.036 115.246,138.069 121.916,131.879C127.286,126.877 130.579,123.485 131.794,121.704C133.434,119.246 134.253,116.815 134.253,114.413C134.253,111.756 133.54,109.714 132.112,108.287C130.685,106.859 128.714,106.146 126.198,106.146C123.711,106.146 121.733,106.895 120.263,108.393C118.793,109.89 117.945,112.378 117.719,115.854L105.849,114.667C106.555,108.11 108.774,103.404 112.505,100.55C116.236,97.695 120.899,96.268 126.495,96.268C132.628,96.268 137.447,97.921 140.952,101.228C144.456,104.535 146.208,108.647 146.208,113.565C146.208,116.363 145.707,119.026 144.703,121.556C143.7,124.086 142.11,126.735 139.934,129.505C138.493,131.342 135.892,133.985 132.133,137.433C128.374,140.881 125.993,143.17 124.99,144.301C123.987,145.431 123.174,146.534 122.552,147.607L146.208,147.607Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Link":s+"<g id=\"Link\"><path d=\"M158.977,112.432C161.103,110.305 161.103,106.853 158.977,104.727L151.273,97.023C149.147,94.897 145.695,94.897 143.568,97.023L97.023,143.568C94.897,145.695 94.897,149.147 97.023,151.273L104.727,158.977C106.853,161.103 110.305,161.103 112.432,158.977L158.977,112.432Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M122.652,108.436C117.197,102.035 117.494,92.397 123.544,86.347L168.61,41.28C174.972,34.918 185.303,34.918 191.665,41.28L214.72,64.335C221.082,70.697 221.082,81.028 214.72,87.39L169.653,132.456C163.603,138.506 153.965,138.803 147.564,133.348L159.103,121.809C161.569,121.713 164.007,120.725 165.888,118.844L201.107,83.624C205.071,79.66 205.071,73.223 201.107,69.259L186.741,54.893C182.777,50.929 176.34,50.929 172.376,54.893L137.156,90.112C135.275,91.993 134.287,94.431 134.191,96.897L122.652,108.436Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M133.348,147.564C138.803,153.965 138.506,163.603 132.456,169.653L87.39,214.72C81.028,221.082 70.697,221.082 64.335,214.72L41.28,191.665C34.918,185.303 34.918,174.972 41.28,168.61L86.347,123.544C92.397,117.494 102.035,117.197 108.436,122.652L96.897,134.191C94.431,134.287 91.993,135.275 90.112,137.156L54.893,172.376C50.929,176.34 50.929,182.777 54.893,186.741L69.259,201.107C73.223,205.071 79.66,205.071 83.624,201.107L118.844,165.888C120.725,164.007 121.713,161.569 121.809,159.103L133.348,147.564Z\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"Image":s+"<g id=\"Image\"><path d=\"M223.788,66.059C223.788,62.025 220.701,58.749 216.896,58.749L39.104,58.749C35.301,58.749 32.212,62.025 32.212,66.059L32.212,189.941C32.212,193.975 35.301,197.251 39.104,197.251L216.896,197.251C220.701,197.251 223.788,193.975 223.788,189.941L223.788,66.059ZM209.947,76.188C209.947,72.814 207.305,70.074 204.051,70.074L51.949,70.074C48.696,70.074 46.053,72.814 46.053,76.188L46.053,179.812C46.053,183.186 48.696,185.926 51.949,185.926L204.051,185.926C207.305,185.926 209.947,183.186 209.947,179.812L209.947,76.188Z\" style=\"fill:rgb(68,68,68);\"/><path d=\"M138.989,119L130.925,118.816C136.207,131.852 146.841,142.518 162.01,151.073C171.515,156.434 171.431,167.784 166.53,177.467L193.236,177.571C191.51,167.278 188.086,152.914 176.061,148.658C154.509,141.03 140.208,131.687 138.989,119Z\" style=\"fill:rgb(68,68,68);\"/><circle cx=\"187.335\" cy=\"91.427\" r=\"12.793\" style=\"fill:rgb(68,68,68);\"/><ellipse cx=\"78.283\" cy=\"122.884\" rx=\"16.043\" ry=\"13.527\" style=\"fill:rgb(68,68,68);\"/><ellipse cx=\"91.809\" cy=\"104.22\" rx=\"18.77\" ry=\"14.313\" style=\"fill:rgb(68,68,68);\"/><ellipse cx=\"104.579\" cy=\"119.315\" rx=\"20.133\" ry=\"16.096\" style=\"fill:rgb(68,68,68);\"/><rect x=\"87.623\" y=\"128\" width=\"12.373\" height=\"48.466\" style=\"fill:rgb(68,68,68);\"/></g></svg>",
"TextParagraph":s+"<g id=\"TextParagraph\"><path d=\"M122.983,46.901C142.141,46.951 154.692,47.774 160.64,49.37C170.073,51.84 177.972,57.212 184.336,65.485C190.7,73.758 193.882,84.446 193.882,97.548C193.882,107.656 192.047,116.153 188.379,123.041C184.71,129.929 180.049,135.339 174.397,139.269C168.744,143.2 162.998,145.802 157.158,147.075C149.47,148.598 138.445,149.383 124.081,149.431L122.681,149.433L101.006,149.433L101.006,211.538L67.764,211.538L67.764,46.899L121.108,46.899L122.983,46.901ZM120.415,121.467C132.845,121.414 141.199,120.554 145.478,118.886C149.896,117.164 153.358,114.469 155.867,110.8C158.375,107.132 159.629,102.864 159.629,97.998C159.629,92.008 157.869,87.067 154.35,83.173C150.832,79.28 146.377,76.847 140.986,75.873C137.018,75.125 129.044,74.75 117.065,74.75L101.006,74.75L101.006,121.469L119.199,121.469L120.415,121.467Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/></g></svg>",
"TextHeader1":s+"<g id=\"TextHeader1\"><path d=\"M99.191,199.875L99.191,137.277L42.55,137.277L42.55,199.875L13.644,199.875L13.644,56.711L42.55,56.711L42.55,113.059L99.191,113.059L99.191,56.711L128.097,56.711L128.097,199.875L99.191,199.875Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/><path d=\"M222.14,199.875L194.699,199.875L194.699,96.457C184.751,105.759 173.041,112.657 159.568,117.152L159.25,117.258L159.25,92.355C166.411,90.012 174.191,85.568 182.589,79.025C190.988,72.482 196.75,64.849 199.875,56.125L222.14,56.125L222.14,199.875Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/></g></svg>",
"TextHeader2":s+"<g id=\"TextHeader2\"><path d=\"M94.78,199.875L94.78,137.277L38.139,137.277L38.139,199.875L9.233,199.875L9.233,56.711L38.139,56.711L38.139,113.059L94.78,113.059L94.78,56.711L123.686,56.711L123.686,199.875L94.78,199.875Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/><path d=\"M195.44,56.128C209.253,56.245 220.134,60.052 228.081,67.551C236.154,75.168 240.19,84.641 240.19,95.969C240.19,102.414 239.035,108.55 236.723,114.377C234.412,120.204 230.75,126.307 225.737,132.688C222.417,136.919 216.427,143.007 207.768,150.949C199.109,158.892 193.624,164.165 191.313,166.77C189.074,169.292 187.247,171.754 185.834,174.155L185.698,174.387L240.19,174.387L240.19,199.875L143.999,199.875C145.04,190.24 148.165,181.109 153.374,172.482C158.582,163.856 168.869,152.414 184.233,138.156C196.603,126.633 204.188,118.82 206.987,114.719C210.763,109.055 212.651,103.456 212.651,97.922C212.651,91.802 211.007,87.098 207.719,83.811C204.483,80.574 200.032,78.931 194.367,78.88L194.096,78.879C188.367,78.879 183.81,80.604 180.425,84.055C177.092,87.451 175.147,93.056 174.591,100.868L174.565,101.242L147.221,98.508C148.849,83.404 153.96,72.564 162.553,65.988C171.013,59.515 181.555,56.228 194.177,56.127L194.78,56.125L195.44,56.128Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/></g></svg>",
"TextHeader3":s+"<g id=\"TextHeader3\"><path d=\"M94.78,199.875L94.78,137.277L38.139,137.277L38.139,199.875L9.233,199.875L9.233,56.711L38.139,56.711L38.139,113.059L94.78,113.059L94.78,56.711L123.686,56.711L123.686,199.875L94.78,199.875Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/><path d=\"M193.045,56.126C206.374,56.192 217.077,60.489 225.151,69.016C231.857,76.047 235.21,83.99 235.21,92.844C235.21,105.409 228.341,115.435 214.604,122.922C222.807,124.68 229.367,128.618 234.282,134.738C239.197,140.858 241.655,148.247 241.655,156.906C241.655,169.471 237.065,180.181 227.885,189.035C218.777,197.82 207.458,202.247 193.928,202.316L193.608,202.316C180.652,202.316 169.91,198.589 161.382,191.135C152.853,183.68 147.905,173.931 146.538,161.887L173.1,158.664L173.141,158.98C174.018,165.596 176.283,170.667 179.936,174.191C183.647,177.772 188.139,179.563 193.413,179.563L193.678,179.561C199.225,179.495 203.906,177.347 207.719,173.117C211.593,168.82 213.53,163.026 213.53,155.734C213.53,148.833 211.675,143.365 207.964,139.328C204.311,135.355 199.869,133.337 194.639,133.275L194.389,133.273C190.984,133.273 186.937,133.915 182.247,135.198L181.792,135.324L184.819,112.961L185.166,112.969C185.396,112.973 185.624,112.976 185.851,112.976L186.19,112.976C192.942,112.948 198.149,111.331 201.811,108.127C205.717,104.709 207.671,100.168 207.671,94.504C207.671,89.686 206.238,85.845 203.374,82.98C200.554,80.161 196.819,78.729 192.17,78.685L191.948,78.684C187.26,78.684 183.257,80.311 179.936,83.566C176.668,86.771 174.661,91.426 173.916,97.532L173.882,97.824L148.589,93.527C150.346,84.868 152.999,77.951 156.548,72.775C160.096,67.6 165.044,63.531 171.391,60.568C177.739,57.606 184.852,56.125 192.729,56.125L193.045,56.126Z\" style=\"fill:rgb(68,68,68);fill-rule:nonzero;\"/></g></svg>",
};"use strict";
window.TK.AjaxList = {
    _: "div",
    Url: "",
    Post: null,
    IdField: "Id",
    Template: {},
    AjaxSettings: {},
    UseVariable: null,
    Init: function () {
        var obj = this;
        if (this.Url) {
            Ajax.do(this.Url, this.Post, function (response) {
                obj.AddMultiple(obj.Template, JSON.parse(response), obj.IdField, obj.UseVariable);
            }, undefined, this.AjaxSettings);
        }
    },
    Refresh: function () {
        this.Init();
    }
};/* Minify Order(100) */

// Component to store client side data with several fallbacks: IndexedDB, LocalStorage
// This component has the same methods as TK.ServerStorage
TK.ClientStorage = {
    _: "component",
    Prefix: "TKStorage_",

    Store: function (path, blobOrByteArrayOrStringContents, isStoredCallBack) {
        var obj = this;

        // We will convert all byte arrays to blobs, which will later be converted to data urls
        if ((window.Uint8Array && blobOrByteArrayOrStringContents instanceof Uint8Array) || (window.Uint16Array && blobOrByteArrayOrStringContents instanceof Uint16Array)) {
            blobOrByteArrayOrStringContents = new Blob([blobOrByteArrayOrStringContents], { 'type': 'application/octet-stream' });
        }

        // We will convert all blobs to data urls
        if ((window.Blob && blobOrByteArrayOrStringContents instanceof Blob) || (window.File && blobOrByteArrayOrStringContents instanceof File)) {
            var reader = new FileReader();
            reader.onload = function () {
                if (reader.result) {
                    obj.Store(path, reader.result, isStoredCallBack);
                }
            };
            reader.readAsDataURL(blobOrByteArrayOrStringContents);
            return;
        }
        
        this.GetIndexedDBInstance(function (db) {
            if (!db) {
                // use local storage as fallback
                var saved = false;
                try {
                    window.localStorage[obj.Prefix + path] = blobOrByteArrayOrStringContents;
                    saved = true;
                } catch (ex) { } // not allowed, supported or quota reached

                if (isStoredCallBack)
                    isStoredCallBack(saved);
                return;
            }

            var transaction = db.transaction(["data"], "readwrite");
            transaction.oncomplete = function (event) {
                if (isStoredCallBack)
                    isStoredCallBack(true);
            };
            transaction.onerror = function (event) {
                console.log("IndexedDB transaction onerror: " + event);
            };
            var store = transaction.objectStore("data");
            var request = store.get(path);
            request.onerror = function (event) {
                console.log('IndexedDB objectStore get onerror: ' + event);
            };
            request.onsuccess = function (event) {
                if (request.result === undefined) { // Add
                    store.add({ key: path, data: blobOrByteArrayOrStringContents });
                } else { // Update
                    request.result.data = blobOrByteArrayOrStringContents;
                    store.put(request.result);
                }
            };
        });
    },
    Retrieve: function (path, asBlob, callBack) {
        if (!callBack)
            return;

        var dataUrlToBlob = function (dataUrl) {
            var parts = dataUrl.split(','), mime = parts[0].match(/:(.*?);/)[1]
            if (parts[0].indexOf('base64') != -1) {
                var data = atob(parts[1]);
                var i = data.length;
                var byteArray = new Uint8Array(data.length);
                while (i--)
                    byteArray[i] = data.charCodeAt(i);
                return new Blob([byteArray], { type: mime });
            } else {
                return new Blob([decodeURIComponent(parts[1])], { type: mime });
            }
        };

        var obj = this;
        this.GetIndexedDBInstance(function (db) {
            if (!db) {
                // use local storage as fallback
                if (!window.localStorage[obj.Prefix + path]) {
                    callBack();
                } else if (!asBlob) {
                    callBack(window.localStorage[obj.Prefix + path]);
                } else if (request.result.data.length < 5 && request.result.data.substr(0, 5) != "data:") {
                    callBack(new Blob([window.localStorage[obj.Prefix + path]], { type: 'text/plain' }));
                } else {
                    callBack(dataUrlToBlob(window.localStorage[obj.Prefix + path]));
                }
                return;
            }

            var transaction = db.transaction(["data"]);
            var store = transaction.objectStore("data");
            var request = store.get(path);
            request.onerror = function (event) {
                console('IndexedDB getAllKeys onerror: ' + event);
            };
            request.onsuccess = function () {
                if (!request.result) {
                    callBack();
                } else if (!asBlob) {
                    callBack(request.result.data);
                } else if (request.result.data.length < 5 && request.result.data.substr(0, 5) != "data:") {
                    callBack(new Blob([request.result.data], { type: 'text/plain' })); 
                } else { 
                    callBack(dataUrlToBlob(request.result.data)); // Data url, turn into blob
                }
            };
        });
    },
    GetUrl: function (path, callBack) {
        if (window.URL && window.URL.createObjectURL) {
            // Return a blob url if supported
            this.Retrieve(path, true, function (resp) {
                if (!resp) {
                    callBack();
                } else {
                    callBack(window.URL.createObjectURL(resp));
                }
            });
        } else {
            // Return a data url as fallback
            this.Retrieve(path, false, function (resp) {
                if (!resp) {
                    callBack();
                } else if (resp.length < 5 || resp.substr(0, 5) != "data:") {
                    callBack("data:text/plain;base64," + btoa(resp));
                } else {
                    callBack(resp);
                }
            });
        }
    },
    Delete: function (path, isDeletedCallBack) {
        var obj = this;
        this.GetIndexedDBInstance(function (db) {
            if (!db) {
                if (window.localStorage[obj.Prefix + path])
                    delete window.localStorage[obj.Prefix + path];
                if (isDeletedCallBack)
                    isDeletedCallBack(true);
                return;
            }

            var transaction = db.transaction(["data"], "readwrite");
            transaction.oncomplete = function (event) {
                if (isDeletedCallBack)
                    isDeletedCallBack(true);
            };
            transaction.onerror = function (event) {
                console.log("IndexedDB transaction onerror: " + event);
                if (isDeletedCallBack)
                    isDeletedCallBack(false);
            };
            var store = transaction.objectStore("data");
            var request = store.get(path);
            request.onerror = function (event) {
                console.log('IndexedDB objectStore get onerror: ' + event);
                if (isDeletedCallBack)
                    isDeletedCallBack(false);
            };
            request.onsuccess = function (event) {
                if (request.result !== undefined) {
                    // Found: Delete
                    store.delete(path);
                }
            };
        });
    },
    List: function (pathsCallBack) {
        if (!pathsCallBack)
            return;

        var obj = this;
        this.GetIndexedDBInstance(function (db) {
            if (!db) {
                // use local storage as fallback
                var keys = [];
                for (var name in window.localStorage) {
                    if (name.length > obj.Prefix && name.substr(0, obj.Prefix.length) == obj.Prefix) {
                        keys.push(name.substr(obj.Prefix.length));
                    }
                }
                pathsCallBack(keys);
                return;
            }

            var transaction = db.transaction(["data"]);
            var store = transaction.objectStore("data");
            var request = store.getAllKeys();
            request.onerror = function (event) {
                console('IndexedDB getAllKeys onerror: ' + event);
            };
            request.onsuccess = function () {
                pathsCallBack(request.result);
            };
        });
    },

    // Internal   
    GetIndexedDBInstance: function (callBack) {
        if (this.IndexedDB) {
            callBack(this.IndexedDB);
            return;
        }

        var obj = this;
        var db = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        if (!db) {
            callBack();
            return;
        }

        var request = window.indexedDB.open(this.Prefix, 1);
        request.onerror = function (event) {
            console.log("IndexedDB onerror: " + request.errorCode);
            callBack();
        };
        request.onupgradeneeded = function (event) {
            obj.IndexedDB = event.target.result;
            event.target.transaction.oncomplete = function () {
                callBack(obj.IndexedDB);
            };
            obj.IndexedDB.createObjectStore("data", { keyPath: "key" });            
        };
        request.onsuccess = function (event) {
            obj.IndexedDB = event.target.result;
            callBack(obj.IndexedDB);
        };
    }
};"use strict";

window.TK.DragDrop = {
    _: "div",    
    className: "toolkitDragDrop",
    Init: function () {
        this.style.position = "relative";
    },
    Type: "",
    Threshold: 10,
    ElementTemplate: null, // When set, the current element will not be moved, but a new element will be created by this. This will also be used as hover template if the HoverTemplate property is not set.
    HoverTemplate: null, // When set, this element will be used for a hover-preview. If both are set, the ElementTemplate will be passed as Template to the .Drop method
    Dropped: function (droppedInContainer, addedElement) { }, // Extra callback

    ontouchstart: function (e) {
        this.onmousedown(e.touches[0]);
        e.stopPropagation();
    },
    onmousedown: function (e) {
        var startX, startY;
        try { startX = e.clientX; startY = e.clientY; } catch (errie) { var e2 = window.event; startX = e2.clientX; startY = e2.clientY; }

        var obj = this;
        var origObj = this;
        var origParent = this.parentNode;
        var myPosition = this.getBoundingClientRect();
        
        var cursorOffsetX = startX - myPosition.left;
        var cursorOffsetY = startY - myPosition.top;
        
       
        var positions = [];
        var newTop, newLeft;
        var first = true;
        var elementOrTemplateToAdd = null;
        var passedThreshold = false;
        var aboveContainer = null;
        var aboveContainerPosition = null;        
        window.onmousemove = function (e) {
            var x, y;
            try { x = e.clientX; y = e.clientY; } catch (errie) { var e2 = window.event; x = e2.clientX; y = e2.clientY; }

            if (!passedThreshold && (Math.abs(startX - x) < obj.Threshold && Math.abs(startY - y) < obj.Threshold))
                return;
            passedThreshold = true;

            if (first) {
                if (obj.HoverTemplate) {
                    obj = obj.Add(obj.HoverTemplate);
                    origParent = null;
                } else if (obj.ElementTemplate) {
                    obj = obj.Add(obj.ElementTemplate);
                    origParent = null;
                }
                obj.style.position = "fixed";
                document.body.appendChild(obj);

                elementOrTemplateToAdd = (origObj.ElementTemplate && origObj.HoverTemplate ? origObj.ElementTemplate : obj);

                var containers = document.querySelectorAll(".toolkitDragDropContainer");
                for (var i = 0; i < containers.length; i++) {
                    if (containers[i].DropFilter && (!obj.Type || containers[i].DropFilter.indexOf(obj.Type) < 0))
                        continue;
                    if (containers[i].CanDrop && !containers[i].CanDrop(elementOrTemplateToAdd))
                        continue;
                    containers[i].className += " toolkitDragDropContainerArea";
                    positions.push({ Element: containers[i], Position: containers[i].getBoundingClientRect() });
                }

                first = false;
            } else {
                for (var i = 0; i < positions.length; i++) {
                    positions[i].Position = positions[i].Element.getBoundingClientRect();
                }
            }

            newTop = (y - startY) + myPosition.top;
            newLeft = (x - startX) + myPosition.left;

            var cursorX = newLeft + cursorOffsetX;
            var cursorY = newTop + cursorOffsetY;

            var found = [];
            for (var i = 0; i < positions.length; i++) {
                if (positions[i].Position.left <= cursorX && positions[i].Position.right >= cursorX && 
                    positions[i].Position.top <= cursorY && positions[i].Position.bottom >= cursorY) {
                    
                    if (aboveContainer != positions[i].Element) {
                        if (aboveContainer != null) {
                            aboveContainer.className = aboveContainer.className.replace(/toolkitDragDropContainerHover/g, "");
                        }
                        aboveContainer = positions[i].Element;
                        aboveContainerPosition = positions[i].Position;
                        aboveContainer.className += " toolkitDragDropContainerHover";
                    }
                    positions[i].TotalSize = positions[i].Position.width + positions[i].Position.height;
                    found.push(positions[i]);
                }
            }
            if (found.length == 0 && aboveContainer != null) {
                aboveContainer.className = aboveContainer.className.replace(/toolkitDragDropContainerHover/g, "");
                aboveContainer = null;
            } else if (found.length > 0) {
                // We will pick the smallest element hovered over, as that will often work fine for nested elements
                var newAboveContainer = found.OrderBy(function (a) { return a.TotalSize }).First().Element;
                if (aboveContainer != newAboveContainer) {
                    if (aboveContainer != null) {
                        aboveContainer.className = aboveContainer.className.replace(/toolkitDragDropContainerHover/g, "");
                    }
                    aboveContainer = newAboveContainer;
                    aboveContainerPosition = positions[i].Position;
                    aboveContainer.className += " toolkitDragDropContainerHover";
                }
            }

            obj.style.top = newTop + "px";
            obj.style.left = newLeft + "px";
        };

        window.onmouseup = function () {
            // If above container element, append to container element, or else move back                        
            obj.style.left = "";
            obj.style.top = "";
            obj.style.position = "relative";

            for (var i = 0; i < positions.length; i++) {
                if (positions[i].Element.className)
                    positions[i].Element.className = positions[i].Element.className.replace(/toolkitDragDropContainerArea/g, "");
            }

            if (aboveContainer) {
                aboveContainer.className = aboveContainer.className.replace(/toolkitDragDropContainerHover/g, "");

                var createdElement = null;
                if (aboveContainer.Drop) {
                    createdElement = aboveContainer.Drop(elementOrTemplateToAdd, newLeft - aboveContainerPosition.left, newTop - aboveContainerPosition.top);
                }

                if (!createdElement && elementOrTemplateToAdd == obj) {
                    if (origObj.ElementTemplate && origObj.HoverTemplate) { // Both are set, but not handled. Create a new element to add
                        // Remove hover element
                        if (obj.Remove)
                            obj.Remove();
                        else
                            obj.parentNode.removeChild(obj);

                        if (aboveContainer.Add) { // Container is a toolkit element, use the Add method
                            aboveContainer.Add(origObj.ElementTemplate);
                            obj = null; // Mark as finished
                        } else {
                            obj = TK.Initialize(origObj.ElementTemplate); // Initialize and append to this container
                        }
                    } else if (!origObj.ElementTemplate && origObj.HoverTemplate) { // Just the hover is set, add the original object to the new parent
                        // Remove hover element
                        if (obj.Remove)
                            obj.Remove();
                        else
                            obj.parentNode.removeChild(obj);

                        obj = origObj;
                    }

                    if (obj != null) {
                        aboveContainer.appendChild(obj);
                        obj.Parent = aboveContainer;
                        var newElementId = Math.random();
                        if (origParent && origParent != aboveContainer && origParent.Elements) {

                            for (var id in origParent.Elements) {
                                if (origParent.Elements[id] == obj) {
                                    delete origParent.Elements[id];
                                    newElementId = id;
                                    break;
                                }
                            }
                        }
                        if (aboveContainer.Elements) {
                            aboveContainer.Elements[newElementId] = obj;
                        }
                    }
                }

                if (origObj.Dropped) {
                    origObj.Dropped(aboveContainer, createdElement);
                }
            } else if (passedThreshold && origParent) {
                origParent.appendChild(obj);
            } else if (passedThreshold) {
                // Remove hover element
                if (obj.Remove)
                    obj.Remove();
                else
                    obj.parentNode.removeChild(obj);
            }
            

            window.onmousemove = null;
            window.onmouseup = null;
            window.onselectstart = null;
            window.ontouchmove = null;
            window.ontouchend = null;
        };
        window.ontouchmove = function (e) {
            if (window.onmousemove)
                window.onmousemove(e.touches[0]);
            e.stopPropagation();
        };
        window.ontouchend = function (e) {
            if (window.onmouseup)
                window.onmouseup();
            e.stopPropagation();
        };
        window.onselectstart = function () { return false; };

        if (e && e.preventDefault)
            e.preventDefault();
        else
            window.event.returnValue = false;
    }

};"use strict";
window.TK.Event = {
    _: "component",
    Subscribe: [],
    Init: function () {
        if (!window.TK.EventHandlers) {
            window.TK.EventHandlers = [];
        }
        window.TK.EventHandlers.push(this);
    },
    Destroy: function () {
        var i = window.TK.EventHandlers.indexOf(this);
        if (i >= 0) {
            window.TK.EventHandlers.splice(i, 1);
        }
    },
    Send: function (eventType, eventData) {
        if (!window.TK.EventHandlers)
            return;
        for (var i = 0; i < window.TK.EventHandlers.length; i++) {
            if (window.TK.EventHandlers[i].Subscribe.indexOf(eventType) >= 0) {
                window.TK.EventHandlers[i].Receive(eventType, eventData);
            }
        }
    },
    Receive: function (eventType, eventData) { /* Callback */ }
};"use strict";
window.TK.Form = {
    _: "form",
    className: "toolkitForm",
    Model: null,
    DefaultModel: null,
    ModelProperty: "Model",
    Fields: null, // fieldName: { Required: false, DisplayName: "Field1", Type: "number", Template: {..} }
    SortByFields: false,
    IgnoreRest: false,
    CurrentFields: null,
    LabelWidth: 0, // when non-zero number: width of labels in px, when string: width of label with unit (ex. 50%), when 0/null: the labels will be displayed as 'block' and fill the complete line.
    SaveButtonText: "Save",
    AutoSave: false,
    RequiredText: "The following fields are required: ",
    ApplyToModelDirectly: false,
    RemoveValueOfNotVisibleFields: true, // If false, a field hidden by IsVisible will still keep its value when saving
    CustomValidation: function (model, callBackResult) { callBackResult([]); }, // Callback with an array of errors. If the array is empty or undefined, the validation is seen as passed.
    DefaultTemplates: {
        text: {
            _: "input",
            type: "text",
            Init: function () { this.value = this.Data; },
            GetValue: function () { return this.value; }
        },
        textarea: {
            _: "textarea",
            Init: function () { this.value = this.Data; },
            GetValue: function () { return this.value; }
        },
        textarray: {
            _: "div",
            className: "textArray",
            TemplateEditableDiv: {
                className: "textArrayItem",
                Data: null,
                PlaceHolder: null,
                Init: function () {
                    this.Elements.Content.disabled = this.Parent ? this.Parent.disabled : false;
                    if (this.PlaceHolder) {
                        this.Elements.Content.value = this.PlaceHolder;
                        this.className += " newItem";
                        this.Elements.RemoveButton.style.display = "none";
                    } else {
                        this.Elements.Content.value = this.Data;
                    }
                },
                Elements: {
                    ContentSize: {
                        _: "div",
                        style: {
                            position: "absolute",
                            height: "0px",
                            overflow: "hidden",
                            maxWidth: "70%"
                        }
                    },
                    Content: {
                        _: "input",
                        onfocus: function () {
                            if (this.Parent.PlaceHolder) {
                                this.value = "";
                                delete this.Parent.PlaceHolder;
                                this.Parent.className = "textArrayItem";
                                this.Parent.Elements.RemoveButton.style.display = "";
                                this.Parent.OnUse();
                            }
                        },
                        oninput: function () {
                            this.Parent.Elements.ContentSize.textContent = this.value;
                            this.style.width = (this.Parent.Elements.ContentSize.offsetWidth + 5) + "px";
                        },
                        onblur: function () {
                            if (this.value == "")
                                this.Parent.Remove();
                        }
                    },
                    RemoveButton: {
                        innerHTML: "X",
                        tabIndex: -1,
                        onclick: function () {
                            this.Parent.Remove();
                        }
                    }
                },
                OnUse: function () {

                }
            },
            Init: function () {
                for (var i = 0; i < this.Data.length; i++) {
                    this.Add({
                        _: this.TemplateEditableDiv,
                        Data: this.Data[i]
                    });
                }
                this.AddNewItem();
            },
            AddNewItem: function () {
                var obj = this;
                this.Add({
                    _: this.TemplateEditableDiv,
                    Data: null,
                    PlaceHolder: "New item",
                    OnUse: function () {
                        obj.AddNewItem();
                    }
                });
                this.ResizeAllElements();
            },
            ResizeAllElements: function () {
                var obj = this;
                setTimeout(function () {
                    for (var name in obj.Elements) {
                        if (!obj.Elements[name].Elements)
                            continue;
                        obj.Elements[name].Elements.Content.oninput();
                    }
                }, 1);
            },
            GetValue: function () {
                var items = this.Elements.ToArray();
                var value = [];
                for (var i = 0; i < items.length; i++) {
                    if (items[i].Elements.Content.value != "" && !items[i].PlaceHolder)
                        value.push(items[i].Elements.Content.value);
                }
                return value;
            }
        },
        number: {
            _: "input",
            type: "number",
            step: "any",
            className: "digits",
            Init: function () { this.value = this.Data; },
            GetValue: function () {
                if (this.value == "")
                    return null;
                return parseFloat(this.value);
            }
        },
        password: {
            _: "input",
            type: "password",
            Init: function () { this.value = this.Data; },
            GetValue: function () {
                return this.value;
            }
        },
        boolean: {
            _: "input",
            type: "checkbox",
            Init: function () {
                this.checked = this.Data;

                this.Parent.Elements.DataLabel.insertBefore(this, this.Parent.Elements.DataLabel.childNodes[0]); // Put the text behind the checkbox and make the text clickable

                if (this.Parent.Elements.DataLabel.style.width) {
                    // Insert dummy container in the place where the label used to be
                    var dummy = this.Add({ style: { display: "inline-block", width: this.Parent.Elements.DataLabel.style.width } });
                    this.Parent.insertBefore(dummy, this.Parent.Elements.DataLabel);
                    this.Parent.Elements.DataLabel.style.width = "auto";
                }
                
            },
            GetValue: function () { return this.checked; }
        },
        select: {
            _: "select",
            Init: function () {
                if (!this.DataSettings.Options)
                    return;
                for (var i = 0; i < this.DataSettings.Options.length; i++) {
                    this.appendChild(new Option(this.DataSettings.Options[i].Text, this.DataSettings.Options[i].Value.toString()));
                }
                if (this.Data)
                    this.value = this.Data.toString();
                else
                    this.value = this.DataSettings.ValueIsText ? "" : 0;
            },
            GetValue: function () { 
                return this.DataSettings.ValueIsText ? this.value : 
                    this.value !== null && this.value !== undefined ? parseInt(this.value) :
                    0;
            }
        },
        ajaxselect: {
            _: "select",
            Init: function () {
                this.Refresh();
            },
            Refresh: function () {
                var obj = this;
                Ajax.do(this.DataSettings.Url, null, function (response) {
                    obj.Values = JSON.parse(response);
                    if (obj.DataSettings.Options && obj.DataSettings.Options.length > 0) {
                        obj.Values = obj.DataSettings.Options.concat(obj.Values);
                    }
                    obj.GenerateOptions();
                }, null, { cacheResults: true });
            },
            GenerateOptions: function () {
                for (var i = 0; i < this.Values.length; i++) {
                    var name = this.DataSettings.GetName ? this.DataSettings.GetName(this.Values[i]) : this.Values[i].Name;
                    var value = this.DataSettings.GetValue ? this.DataSettings.GetValue(this.Values[i]) : this.Values[i].Id;
                    var optionEle = new Option(name.toString(), value.toString());
                    optionEle.ValueObj = this.Values[i];
                    this.appendChild(optionEle);
                }
                if (this.Data !== undefined && this.Data !== null) {
                    this.value = this.Data.toString(); // Always set a string for compatibility reasons
                    // Set Data to null so GetValue will return value from here on
                    this.Data = null;
                }
                else
                    this.value = this.DataSettings.ValueIsText ? "" : "0";
            },
            GetValue: function () {
                // When Data is set and options are being retrieved we can return the Data.
                // The user was not able to change the value up to this point so the Data is accurate.
                if (this.Data !== null && this.Data !== undefined) {
                    return this.Data;
                } else if (this.value !== null && this.value !== undefined) {
                    return this.DataSettings.ValueIsText ? this.value.toString() : parseInt(this.value);
                }
                return this.DataSettings.ValueIsText ? "" : 0;
            }
        },
        date: {
            _: "input",
            type: "date",
            Init: function () { this.value = this.Data; },
            GetValue: function () { return this.value; }
        },
        color: {
            _: "input",
            type: "color",
            Init: function () { this.value = this.Data; },
            GetValue: function () { return this.value; }
        },
        datetime: {
            _: "input",
            type: "text",
            Init: function () { this.value = this.Data; },
            GetValue: function () { return this.value; }
        },
        form: {
            _: "div", 
            className: "subForm",
            Init: function () {
                var dataSettings = this.DataSettings;
                if (this.LinkedData !== undefined && dataSettings.LinkSettings && dataSettings.LinkSettings[this.LinkedData]) {
                    dataSettings = dataSettings.LinkSettings[this.LinkedData];
                }

                this.Add({
                    _: TK.Form,
                    SaveButtonText: null,
                    Model: this.Data,
                    DefaultModel: dataSettings.DefaultModel,
                    Fields: dataSettings.Fields,
                    IgnoreRest: dataSettings.IgnoreRest,
                    SortByFields: dataSettings.SortByFields,
                  //  Init: dataSettings.Init
                }, "Form");
            },
            GetValue: function (errors) {
                return this.Elements.Form.GetModel(errors);
            }
        },
        forms: {
            _: "div",
            className: "subForms",
            Forms: null,
            Init: function () {
                this.Forms = [];
                var obj = this;
                if (this.DataSettings.NewItem) {
                    this.Add({
                        _: "button",
                        innerHTML: this.DataSettings.AddButtonText ? this.DataSettings.AddButtonText : "Add",
                        className: "addButton",
                        type: "button",
                        onclick: function () {
                            obj.Forms.push(obj.Add({
                                _: TK.Form,
                                Model: JSON.parse(JSON.stringify(obj.DataSettings.NewItem)), // deepcopy
                                SaveButtonText: null,
                                Fields: obj.DataSettings.Fields,
                                IgnoreRest: obj.DataSettings.IgnoreRest,
                                SortByFields: obj.DataSettings.SortByFields,
                               // Init: obj.DataSettings.Init,
                                Elements: {
                                    RemoveButton: {
                                        innerHTML: obj.DataSettings.RemoveButtonText ? obj.DataSettings.RemoveButtonText : "Remove",
                                        className: "removeButton",
                                        onclick: function () {
                                            this.Parent.Remove();
                                        }
                                    }
                                }
                            }));
                            if (obj.onchange)
                                obj.onchange();
                        }
                    });
                }
                if (!this.Data)
                    return;
                for (var i = 0; i < this.Data.length; i++) {
                    this.Forms.push(this.Add({
                        _: TK.Form,
                        Model: this.Data[i],
                        SaveButtonText: null,
                        Fields: this.DataSettings.Fields,
                        IgnoreRest: this.DataSettings.IgnoreRest,
                        SortByFields: this.DataSettings.SortByFields,
                        //Init: this.DataSettings.Init,
                        Elements: {
                            RemoveButton: {
                                innerHTML: this.DataSettings.RemoveButtonText ? this.DataSettings.RemoveButtonText : "Remove",
                                className: "removeButton",
                                onclick: function () {
                                    this.Parent.Remove();
                                }
                            }
                        }
                    }));
                }
            },
            GetValue: function (errors) {
                var newObjs = [];
                for (var i = 0; i < this.Forms.length; i++) {
                    if (!this.Forms[i].Parent)
                        continue; // This form is removed
                    newObjs.push(this.Forms[i].GetModel(errors));
                }
                return newObjs;
            }
        }
    },
    Init: function () {        
        var obj = this;
        this.CurrentFields = {};
        var tmpFields = {};
        var model = this[this.ModelProperty];
        if (!model && this.DefaultModel)
            model = this.DefaultModel;
        else if (!model)
            return;
        

        if (this.Templates) {
            for (var name in this.Templates) {
                this.DefaultTemplates[name] = this.Templates[name];
            }
        }

        var callIsVisible = false;
        for (var name in model) {            
            var type = this.Fields && this.Fields[name] && this.Fields[name].Type ? this.Fields[name].Type : typeof model[name];

            if (this.IgnoreRest && (!this.Fields || !this.Fields[name]))
                type = "ignore";
            var getField = function (fieldName, fallBack) {
                if (fallBack == undefined)
                    fallBack = null;
                return obj.Fields && obj.Fields[name] && obj.Fields[name][fieldName] ? obj.Fields[name][fieldName] : fallBack;
            };
            if (type != "ignore") {
                var defaultTemplate = this.DefaultTemplates[type] ? this.DefaultTemplates[type] : this.DefaultTemplates.text;
                var isRequired = getField("Required", false);                
                var row = {
                    style: { },
                    className: "fieldRow field-" + name + (isRequired ? " fieldRequired" : "") + " " + (getField("Inline") ? "inlineBlock" : ""),                    
                    Elements: {
                        DataLabel: { innerHTML: getField("DisplayName",name), style: {} },
                        DataField: {
                            _: getField("Template", defaultTemplate),
                            _Self: true,
                            /* required: isRequired, */
                            placeholder: getField("PlaceHolder",""),
                            Data: model[name],                            
                            DataName: name,
                            LinkedData: getField("LinkField") ? model[getField("LinkField")] : null,
                            DataSettings: (this.Fields && this.Fields[name] ? this.Fields[name] : null),
                            onfocus: getField("onfocus"),
                            onblur: getField("onblur"),
                            onchange: getField("onchange"),
                            disabled: getField("disabled", false),
                            readOnly: getField("readOnly"),
                            IsVisible: getField("IsVisible"),
                            //Init: (this.Fields && this.Fields[name] && this.Fields[name].Init ? this.Fields[name].Init : undefined),
                            Form: this 
                        }
                    }
                };

                if (this.LabelWidth) {
                    row.Elements.DataLabel.style.display = "inline-block";
                    row.Elements.DataLabel.style.width = this.LabelWidth + (this.LabelWidth.substr ? "" : "px");
                }

                if (this.Fields && this.Fields[name]) {
                    if (this.Fields[name].Width) {
                        row.className += " withWidth";
                        row.style.width = this.Fields[name].Width;
                    }
                    if (this.Fields[name].IsVisible) {
                        row.style.display = this.Fields[name].IsVisible(model) ? "" : "none";
                        callIsVisible = true;
                    }
                    if (this.Fields[name].LabelWidth) {
                        row.Elements.DataLabel.style.display = "inline-block";
                        row.Elements.DataLabel.style.width = this.LabelWidth + (this.LabelWidth.substr ? "" : "px");
                    }
                }

                row.Elements.DataField.origOnBlur = row.Elements.DataField.onblur;
                row.Elements.DataField.onblur = function () {
                    if (this.origOnBlur)
                        this.origOnBlur();
                    if (obj.AutoSave) {
                        obj.onsubmit();
                    }
                };
                row.Elements.DataField.origOnchange = row.Elements.DataField.onchange;
                row.Elements.DataField.onchange = function () {
                    if (this.origOnchange)
                        this.origOnchange();
                    var curModel = null;
                    for (var name in obj.CurrentFields) {
                        if (obj.CurrentFields[name] && obj.CurrentFields[name].DataSettings && obj.CurrentFields[name].DataSettings.LinkField && obj.CurrentFields[name].DataSettings.LinkField == this.DataName) {
                            obj.CurrentFields[name].LinkedData = this.GetValue();
                            obj.CurrentFields[name].Clear();
                            obj.CurrentFields[name].Init();
                        }

                        if (obj.CurrentFields[name] && obj.CurrentFields[name].IsVisible && obj.CurrentFields[name].Parent && obj.CurrentFields[name].Parent.style) {
                            // Get model and call obj.CurrentFields[name].DataSettings.IsVisible(model);
                            if (!curModel)
                                curModel = obj.GetModel([]);
                            obj.CurrentFields[name].Parent.style.display = obj.CurrentFields[name].IsVisible(curModel) ? "" : "none";
                        }
                    }
                    
                    if (obj.AutoSave) {
                        obj.onsubmit();
                    }
                };                

                if (this.SortByFields) {
                    tmpFields[name] = row;
                } else {
                    var rowObj = this.Add(row);
                    this.CurrentFields[name] = rowObj.Elements.DataField;
                }                

            } else {
                this.CurrentFields[name] = "ignore";
            }
        }
        
        var parent = this;
        if (this.SortByFields && this.Fields) {
            for (var fieldName in this.Fields) {                

                if (this.Fields[fieldName].Type == "section") {
                    parent = this.Add({
                        _: "fieldset",
                        Elements: {
                            Legend: {
                                _: "legend",
                                innerHTML: this.Fields[fieldName].DisplayName
                            }
                        }
                    });
                    
                }
                
                if (!tmpFields[fieldName]) {
                    if (this.Fields[fieldName]._) // This is just a template
                        parent.Add(this.Fields[fieldName], fieldName);
                    continue;
                }

                var rObj = parent.Add(tmpFields[fieldName]);
                this.CurrentFields[fieldName] =  rObj.Elements.DataField;
                
            }
        }

        if (callIsVisible) {
            // There is at least 1 IsVisible function, so we'll get the model and call all methods now the elements are actually created            
            var curModel = this.GetModel([]);
            for (var name in this.CurrentFields) {
                if (this.CurrentFields[name] && this.CurrentFields[name].IsVisible && this.CurrentFields[name].Parent && this.CurrentFields[name].Parent.style) {
                    this.CurrentFields[name].Parent.style.display = this.CurrentFields[name].IsVisible(curModel) ? "" : "none";
                }
            }
        }

        if (this.SaveButtonText) {
            this.Add({
                _: "button",
                type: "submit",
                innerHTML: this.SaveButtonText
            }, "SaveButton");
        }
    },
    Save: function (obj) {
    },
    GetModel: function (errors, applyToModelDirectly) {
        if (applyToModelDirectly === undefined)
            applyToModelDirectly = this.ApplyToModelDirectly;
        var model = this[this.ModelProperty];
        var newObj = applyToModelDirectly ? model : {};

        if (applyToModelDirectly) { // Check for errors first
            var tmpErrorList = [];
            var tmpModel = this.GetModel(tmpErrorList, false);            
            if (tmpErrorList.length > 0) {
                for (var i = 0; i < tmpErrorList.length; i++) {
                    errors.push(tmpErrorList[i]);
                }
                return tmpModel;
            }
        }

        for (var name in this.CurrentFields) {
            if (this.CurrentFields[name] == "ignore") {
                if (!applyToModelDirectly && model != null)
                    newObj[name] = model[name];
            } else {
                if (this.CurrentFields[name].IsVisible && this.RemoveValueOfNotVisibleFields && this.CurrentFields[name].Parent && this.CurrentFields[name].Parent.style && this.CurrentFields[name].Parent.style.display == "none") {
                    if (applyToModelDirectly && newObj != null) // Set to null, otherwise don't include it in the new model
                        newObj[name] = null;
                    continue;
                }
                newObj[name] = this.CurrentFields[name].GetValue(errors);
                var hasError = false;
                if (errors) {
                    if (this.Fields && this.Fields[name] && this.Fields[name].Required && (newObj[name] === null || newObj[name] === "")) {
                        errors.push(this.Fields && this.Fields[name] && this.Fields[name].DisplayName ? this.Fields[name].DisplayName : name);
                        hasError = true;
                        this.CurrentFields[name].Parent.className += " fieldError";
                    }
                }

                if (!hasError) {
                    this.CurrentFields[name].Parent.className = this.CurrentFields[name].Parent.className.replace("fieldError", "");
                }
            }
        }
        return newObj;
    },
    RenderErrors: function (errors, textBefore) {
        if (this.Elements.ErrorText) {
            this.Elements.ErrorText.innerHTML = textBefore + errors.join(", ");
        } else {
            this.Add({ innerHTML: textBefore + errors.join(", "), className: "validationError" }, "ErrorText");
        }
    },
    onsubmit: function () {
        if (this.IsCurrentlySubmitting)
            return false;
        this.IsCurrentlySubmitting = true;
        var obj = this;
        var errors = [];
        var newObj = this.GetModel(errors);
        if (errors.length == 0) {
            if (this.CustomValidation) {
                this.CustomValidation(newObj, function (customErrors) {
                    obj.IsCurrentlySubmitting = false;
                    if (!customErrors || customErrors.length == 0) {                        
                        obj.Save(newObj);                        
                    } else {
                        obj.RenderErrors(customErrors, "");
                    }
                });
            } else {
                this.IsCurrentlySubmitting = false;
                this.Save(newObj);
            }            
        } else {
            this.RenderErrors(errors, this.RequiredText);
            this.IsCurrentlySubmitting = false;
        }        
        return false;
    }
};
"use strict";
window.TK.Navigator = {
    _: "div",
    DefaultHash: "index",
    Seperator: "/",
    Current: null,
    CurrentElement: null,
    UseTemplates: false,
    Init: function () {
        var obj = this;
        if (this.Templates) {
            this.UseTemplates = true;
        }
        this.onHashChangeHandler = function () {
            obj.Handle();
        };
        window.addEventListener("hashchange", this.onHashChangeHandler);
        if (this.NavigatorLevel === undefined) {
            this.NavigatorLevel = 0;
            var parent = this.Parent;
            while (parent) {
                if (parent.DefaultHash) {
                    // This is a navigator
                    this.NavigatorLevel++;
                }
                parent = parent.Parent;
            }
        }
        this.Handle();
    },
    Destroy: function () {
        window.removeEventListener("hashchange", this.onHashChangeHandler);
    },
    Handle: function () {
        var navigateTo = window.location.hash;
        if (navigateTo == "")
            navigateTo = this.DefaultHash;
        else
            navigateTo = navigateTo.substr(1);


        var pagePart = decodeURIComponent(navigateTo).split(this.Seperator);
        if (pagePart.length <= this.NavigatorLevel) {
            pagePart.push(this.DefaultHash);
        }

        if (this.UseTemplates) { // Add new element, and destroy old elements (Slower, less memory usage)
            if (pagePart[this.NavigatorLevel] != this.Current) {
                if (this.CurrentElement) {
                    this.CurrentElement.Remove();
                }
                this.Current = pagePart[this.NavigatorLevel];
                if (this.Templates[this.Current]) {                    
                    this.CurrentElement = this.Add(this.Templates[this.Current], "current");
                }
            }
        } else { // Just hide/show elements (Faster, but more memory usage)
            this.CurrentElement = null;
            for (var elementName in this.Elements) {
                if (elementName != pagePart[this.NavigatorLevel] && this.Elements[elementName].style && this.Elements[elementName].style.display != "none")
                    this.Elements[elementName].style.display = "none";
                else if (elementName == pagePart[this.NavigatorLevel]) {
                    this.CurrentElement = this.Elements[elementName];
                    if (this.Elements[elementName].style && this.Elements[elementName].style.display != "")
                        this.Elements[elementName].style.display = "";
                }
            }
        }
        this.Current = pagePart[this.NavigatorLevel];
        pagePart.splice(0, this.NavigatorLevel + 1);
        if (this.CurrentElement && this.CurrentElement.Navigate) {
            this.CurrentElement.Navigate(pagePart);
        }
        if (this.Navigate)
            this.Navigate(this.Current);

    },
    Navigate: function (newPage) { }
};"use strict";
window.TK.Page = {
    _: "div",
    Url: "",
    Post: null,
    IsTemplate: false,
    Template: null,
    ExecuteScripts: true,
    ChangeForms: true,
    AjaxSettings: {},
    State: null,
    Init: function () {
        var obj = this;
        this.ajaxCallBack = function (response) {
            if (response && response.substr(0, 1) == "{") {
                // Response is a template
                var template = eval('(' + response + ')');
                if (obj.Template) {
                    obj.Template._ = template;
                    obj.Add(obj.Template, "page");
                } else {
                    obj.Add(template, "page");
                }
            } else {
                obj.innerHTML = response;
                if (obj.ExecuteScripts) {
                    Ajax.executeScripts(response);
                }
                if (obj.ChangeForms) {
                    var allForms = obj.querySelectorAll("form");
                    for (var i = 0; i < allForms.length; i++) {
                        allForms[i].onsubmit = function () {
                            Ajax.doAjaxFormSubmit(this, obj.ajaxCallBack);
                            return false;
                        };
                    }
                }
            }
            if (obj.Update) {
                obj.Update();
            }
        };

        if (this.Url) {
            Ajax.do(this.Url, this.Post, this.ajaxCallBack, undefined, this.AjaxSettings);
        }
    },
    Refresh: function () {
        if (this.Elements.page) {
            this.Elements.page.Remove();
        }
        this.innerHTML = "";
        this.Init();
    },
    Update: function () { }
};"use strict";
window.TK.Popup = {
    _: "div",
    _Tag: "ToolkitPopup",
    Width: 400,
    Height: 500,
    MinWidth: 150,
    MinHeight: 150,
    Title: "Popup",
    EnableCloseButton: true,
    EnableBackDrop: false,
    CloseWithEscapeButton: false,
    CloseByClickingOutsideOfPopup: false,
    EnableResize: true,
    EnableSnapping: true,
    Maximized: false,
    className: "toolkitPopup",
    Template: {},
    OnResize: function () { },
    Buttons: null,   // { Ok: function() { alert('ok pressed!'); } }
    Init: function () {        
        var obj = this;
        this.style.position = "fixed";
        this.CenterWindow();        
        this.RestoreBodyOverflow = function () {
            if (obj.OrigBodyOverflow) {
                document.body.style.overflow = obj.OrigBodyOverflow;
                obj.OrigBodyOverflow = null;
            }
        };

        this.Add({
            _: "h2",
            Elements: {
                TitleSpan: {
                    innerText: this.Title
                }
            },
            onselectstart: function () { return false; },
            ondblclick: function () {
                if (!obj.EnableResize)
                    return;

                if (obj.Maximized) {
                    obj.Maximized = false;
                    obj.RestoreBodyOverflow();

                    obj.style.left = obj.OldCords[0] + "px";
                    obj.style.top = obj.OldCords[1] + "px";
                    obj.style.width = obj.OldCords[2] + "px";
                    obj.style.height = obj.OldCords[3] + "px";
                } else {
                    obj.Maximized = true;
                    obj.OrigBodyOverflow = document.body.style.overflow;
                    if (!obj.OrigBodyOverflow)
                        obj.OrigBodyOverflow = "initial";
                    document.body.style.overflow = "hidden";

                    obj.OldCords = [obj.offsetLeft, obj.offsetTop, obj.offsetWidth, obj.offsetHeight];
                    obj.style.left = "0px";
                    obj.style.top = "0px";
                    obj.style.width = window.innerWidth + "px";
                    obj.style.height = window.innerHeight + "px";
                }

                if (obj.OnResize) {
                    obj.OnResize();
                }
            },
            ontouchstart: function (e) {
                this.onmousedown(e.touches[0]);
                e.stopPropagation();
            },
            onmousedown: function (e) {
                var x, y;
                try { x = e.pageX; y = e.pageY; } catch (errie) { var e2 = window.event; x = e2.clientX; y = e2.clientY; }
                var startX = x - obj.offsetLeft;
                var startY = y - obj.offsetTop;
                var startWidth = obj.offsetWidth;
                var startHeight = obj.offsetHeight;

                var snapXSides = [0, window.innerWidth];
                var snapYSides = [0, window.innerHeight];
                if (obj.EnableSnapping) {
                    var allPopups = document.querySelectorAll(".toolkitPopup");
                    for (var i = 0; i < allPopups.length; i++) {
                        if (allPopups[i] == obj || !allPopups[i].parentNode)
                            continue;
                        snapXSides.push(allPopups[i].offsetLeft - 2);
                        snapXSides.push(allPopups[i].offsetLeft + allPopups[i].offsetWidth);
                        snapYSides.push(allPopups[i].offsetTop);
                        snapYSides.push(allPopups[i].offsetTop + allPopups[i].offsetHeight);
                    }
                }
                
                window.onmousemove = function (e) {
                    if (obj.Maximized) {
                        obj.Maximized = false;
                        obj.style.left = obj.OldCords[0] + "px";
                        obj.style.top = obj.OldCords[1] + "px";
                        obj.style.width = obj.OldCords[2] + "px";
                        obj.style.height = obj.OldCords[3] + "px";
                        obj.RestoreBodyOverflow();
                    }
                    var x, y;
                    try { x = e.pageX; y = e.pageY; } catch (errie) { var e2 = window.event; x = e2.clientX; y = e2.clientY; }
                    var newLeft = (x - startX);
                    var newTop = (y - startY);
                    if (obj.EnableSnapping) {
                        for (var i = 0; i < snapXSides.length; i++) {
                            if (Math.abs(snapXSides[i] - newLeft) < 10) {
                                newLeft = snapXSides[i];
                            } else if (Math.abs(snapXSides[i] - (newLeft + startWidth)) < 10) {
                                newLeft = snapXSides[i] - startWidth;
                            }
                        }

                        for (var i = 0; i < snapYSides.length; i++) {
                            if (Math.abs(snapYSides[i] - newTop) < 10) {
                                newTop = snapYSides[i];
                            } else if (Math.abs(snapYSides[i] - (newTop + startHeight)) < 10) {
                                newTop = snapYSides[i] - startHeight;
                            }
                        }
                    }

                    obj.style.left = newLeft + "px";
                    obj.style.top = newTop + "px";
                };
                window.onmouseup = function () {
                    window.onmousemove = null;
                    window.onmouseup = null;
                    window.onselectstart = null;
                    window.ontouchmove = null;
                    window.ontouchend = null;
                };
                window.ontouchmove = function (e) {
                    if (window.onmousemove)
                        window.onmousemove(e.touches[0]);
                    e.stopPropagation();
                };
                window.ontouchend = function (e) {
                    if (window.onmouseup)
                        window.onmouseup();
                    e.stopPropagation();
                };
                window.onselectstart = function () { return false; };

                if (e && e.preventDefault)
                    e.preventDefault();
                else
                    window.event.returnValue = false;
            }
        }, "PopupTitle");
        
        if (this.EnableResize) {
            this.Add({
                _: "button",
                innerHTML: "",
                onselectstart: function () { return false; },
                ontouchstart: function (e) {
                    this.onmousedown(e.touches[0]);
                    e.stopPropagation();
                },
                onmousedown: function (e) {
                    var x, y;
                    try { x = e.pageX; y = e.pageY; } catch (errie) { var e2 = window.event; x = e2.clientX; y = e2.clientY; }
                    var startX = x;
                    var startY = y;
                    var startWidth = obj.offsetWidth;
                    var startHeight = obj.offsetHeight;                    

                    window.onselectstart = function () { return false; };
                    window.onmousemove = function (e) {
                        obj.Maximized = false;
                        obj.RestoreBodyOverflow();
                        var x, y;
                        try { x = e.pageX; y = e.pageY; } catch (errie) { var e2 = window.event; x = e2.clientX; y = e2.clientY; }

                        var newWidth = startWidth + (x - startX);
                        if (newWidth < obj.MinWidth)
                            newWidth = obj.MinWidth;

                        var newHeight = startHeight + (y - startY);
                        if (newHeight < obj.MinWidth)
                            newHeight = obj.MinWidth;

                        obj.style.width = newWidth + "px";
                        obj.style.height = newHeight + "px";

                        window.onmouseup = function () {
                            window.onmousemove = null;
                            window.onselectstart = null;
                            window.ontouchmove = null;
                            window.ontouchend = null;
                            if (obj.OnResize) {
                                obj.OnResize();
                            }
                        };
                        if (e && e.preventDefault)
                            e.preventDefault();
                        else
                            window.event.returnValue = false;
                    };
                    window.ontouchmove = function (e) {
                        if (window.onmousemove)
                            window.onmousemove(e.touches[0]);
                        e.stopPropagation();
                    };
                    window.ontouchend = function (e) {
                        if (window.onmouseup)
                            window.onmouseup();
                        e.stopPropagation();
                    };
                }
            }, "ResizeButton");
        }		


        if (this.EnableCloseButton) {
            this.Add({
                _: "button",
                innerHTML: "x",
                onclick: function () {
                    this.Parent.Remove();
                }
            }, "CloseButton");
        }

        if (this.Buttons) {
            var buttonBar = {
                className: "toolkitButtonBar",
                Elements: {}
            };
            this.className += " toolkitPopupWithButtonBar";
            for (var name in this.Buttons) {
                if (typeof this.Buttons[name] === 'function') {
                    this.Buttons[name] = {
                        Click: this.Buttons[name]
                    };
                }
                buttonBar.Elements[name + "Button"] = {
                    _: this.Buttons[name],
                    ButtonName: name,
                    Init: function () {
                        this.appendChild(document.createTextNode(this.Text ? this.Text : this.ButtonName));
                    },
                    onclick: function () {
                        var cancelClosePopup = false;
                        if (this.Click)
                            cancelClosePopup = this.Click();
                        if (!cancelClosePopup)
                            this.Parent.Parent.Remove();
                    }
                };
            }
            this.Add(buttonBar, "ButtonBar");
        }

        this.Add(this.Template, "Content");

        if (this.EnableBackDrop) {
            this.BackDrop = document.createElement("DIV");
            this.BackDrop.className = "toolkitPopupBackDrop";
            this.BackDrop.style.position = "fixed";
            this.BackDrop.style.top = "0px";
            this.BackDrop.style.right = "0px";
            this.BackDrop.style.bottom = "0px";
            this.BackDrop.style.left = "0px";
            this.BackDrop.style.zIndex = (window.TK.Popup.StartZIndex++);
            if (this.CloseByClickingOutsideOfPopup) {
                this.BackDrop.onclick = function () {
                    obj.Remove();
                }
            };

            if (this.CloseWithEscapeButton) {
                obj.Keydown = function (evt) {
                    if (evt && evt.key === 'Escape' && obj != null) {
                        obj.Remove();
                    }
                };
                document.addEventListener('keydown', obj.Keydown)
            };
            document.body.appendChild(this.BackDrop);
        }

        this.style.zIndex = (window.TK.Popup.StartZIndex++);
        document.body.appendChild(this); // Move myself to the body element
        if (this.Maximized || window.innerWidth < this.Width || window.innerHeight < this.Height) {
            this.Maximized = false;
            this.Elements.PopupTitle.ondblclick();
        }
    },
    Destroy: function () {
        if (this.BackDrop) {
            this.BackDrop.parentNode.removeChild(this.BackDrop);
        }
        if (this.Keydown) {
            document.removeEventListener('keydown', this.Keydown);
        }
        this.RestoreBodyOverflow();
    },
    onmousedown: function () {
        this.style.zIndex = (window.TK.Popup.StartZIndex++);
    },
    CenterWindow: function () {
        
        this.style.width = this.Width + "px";
        this.style.height = this.Height + "px";
        this.style.top = Math.round((window.innerHeight / 2) - (this.Height / 2)) + "px";
        this.style.left = Math.round((window.innerWidth / 2) - (this.Width / 2)) + "px";
    }
};
window.TK.Popup.StartZIndex = 10000;
window.TK.PopupOpen = function (template, title, width, height) {
    TK.Initialize({
        _: TK.Popup,
        Width: width ? width : 600,
        Height: height ? height : 500,
        Title: title,
        Template: template
    });
};








"use strict";
/* Minify Skip */
/* Minify Order(100) */

// Component to send and receive messages in a public channel, this will try to use WebSockets or fall back to https requests to the toolkit api
TK.ServerChannel = {
    _: "component",
    Channels: [],
    ClientId: "Client" + (Math.random() * 100000) + "-" + (Math.random() * 100000) + "-" + (Math.random() * 100000) + "-" + (Math.random() * 100000), // Not visible for other connected client
    Receive: function (channel, identity, data) { },    

    Connection: null,

    Init: function () {
        if (!TK.ServerChannel.Connections)
            TK.ServerChannel.Connections = {};
        if (!TK.ServerChannel.Connections[this.ClientId]) {
            // Create connection            
            TK.ServerChannel.Connections[this.ClientId] = TK.Initialize({
                _: TK.ServerChannelConnection,
                ClientId: this.ClientId,
                Channels: this.Channels.slice(0),
                UsedBy: [this],
                Receive: function (channel, identity, data) {
                    for (var i = 0; i < this.UsedBy.length; i++) {
                        if (this.UsedBy[i].Channels.indexOf(channel) >= 0)
                            this.UsedBy[i].Receive(channel, identity, data);
                    }
                }
            });
        } else {
            // Use existing connection
            TK.ServerChannel.Connections[this.ClientId].UsedBy.push(this);
            for (var i = 0; i < this.Channels.length; i++) {
                TK.ServerChannel.Connections[this.ClientId].AddChannel(this.Channels[i]);
            }
        }
        this.Connection = TK.ServerChannel.Connections[this.ClientId];
    },
    Destroy: function () {
        while (this.Channels.length > 0)
            this.RemoveChannel(this.Channels[0]);
        this.Connection.UsedBy.splice(this.Connection.UsedBy.indexOf(this), 1);
        if (this.Connection.UsedBy.length == 0)
            this.Connection.Remove();
    },
    Send: function (channel, data) {
        this.Connection.Send(channel, data);
    },
    AddChannel: function (channel) {        
        if (this.Channels.indexOf(channel) >= 0)
            return;
        this.Channels.push(channel);
        this.Connection.AddChannel(channel);
    },
    RemoveChannel: function (channel) {
        if (this.Channels.indexOf(channel) < 0)
            return;
        this.Channels.splice(this.Channels.indexOf(channel), 1);

        // Check if used by other ServerChannel objects
        for (var i = 0; i < this.Connection.UsedBy.length; i++) {
            if (this.Connection.UsedBy[i].Channels.indexOf(channel) >= 0)
                return;
        }

        // Not used anymore, leave channel
        this.Connection.RemoveChannel(channel);
    }
};


// Shared component, this will be used by (multiple) TK.ServerChannel objects
TK.ServerChannelConnection = {
    _: "component",
    Channels: [],
    ClientId: null, // Not visible for other connected client    
    UrlFallback: "https://toolkitapi.comgenie.com/Channel/Communicate",
    UrlWebsocket: "wss://toolkitapi.comgenie.com/ws",
    FallbackInterval: 5000,
    Receive: function (channel, identity, data) { },
    ChannelIndexes: [], // used internally for fallback method    

    Init: function () {
        if (this.ClientId == null)
            return;
        
        if (this.UrlWebsocket)
            this.CreateWebsocket();
        else
            this.CreateFallback();
    },
    Destroy: function () {
        // Disconnect communication
        if (this.WebSocket)
            this.WebSocket.close();
        
        if (this.FallBackTimeout) {
            
            clearTimeout(this.FallBackTimeout);
            this.FallBackTimeout = null;
        }
    },
    CreateWebsocket: function () {
        var obj = this;
        var webSocket = new WebSocket(this.UrlWebsocket);
        webSocket.SendData = function (command, data) {
            //console.log("Send data: " + command, data);
            this.send(command + "|" + data.length + "|" + data);
        };
        webSocket.onopen = function (eventData) {
            //console.log("WS Open", eventData);
            obj.WebSocket = this;
            this.SendData("ID", obj.ClientId);
            for (var i = 0; i < obj.Channels.length; i++)
                this.SendData("JOIN", obj.Channels[i]);
        };
        webSocket.onmessage = function (eventData) {
            if (!eventData.data.substr)
                return;

            //console.log("WS Receive", eventData.data);
            var firstSeperator = eventData.data.indexOf("|");
            if (firstSeperator < 0)
                return;
            var secondSeperator = eventData.data.indexOf("|", firstSeperator + 1);
            if (secondSeperator < 0)
                return;
            var command = eventData.data.substr(0, firstSeperator);
            var dataLength = eventData.data.substring(secondSeperator + 1, secondSeperator);
            var payload = eventData.data.substr(secondSeperator + 1);
            if (command == "MSG") {
                var msg = JSON.parse(payload);
                console.log(msg);
                obj.Receive(msg.Channel, msg.Identity, msg.Data);
            }
        };
        webSocket.onerror = function (eventData) {
            // Couldn't connect            
            //console.log("WS Error", eventData);
            obj.CreateFallback();
        };
        webSocket.onclose = function (eventData) {
            // Disconnected
            //console.log("WS Close", eventData)
            obj.CreateFallback();
        };
    },
    CreateFallback: function () {
        console.log("Using fallback");
        this.WebSocket = null; // TODO: See if we can reconnect 
        this.SendFallBack(null, null); // Send first check message, this activates the interval as well
    },
    AddChannel: function (channel) {
        if (this.Channels.indexOf(channel) >= 0)
            return;

        this.Channels.push(channel);
        this.ChannelIndexes.push(-1);

        if (this.WebSocket)
            this.WebSocket.SendData("JOIN", channel);
    },
    RemoveChannel: function (channel) {
        var channelIndex = this.Channels.indexOf(channel);
        if (channelIndex < 0)
            return;
        this.Channels.splice(channelIndex, 1);
        this.ChannelIndexes.splice(channelIndex, 1);

        if (this.WebSocket)
            this.WebSocket.SendData("LEAVE", channel);
    },
    SendFallBack: function (channel, data) {
        
        if (this.FallBackTimeout) {
            clearTimeout(this.FallBackTimeout);
            this.FallBackTimeout = null;
        }

        var obj = this;
        var channelsArr = [];
        var indexesArr = [];
        for (var i = 0; i < this.Channels.length; i++) {
            channelsArr.push(this.Channels[i]);
            indexesArr.push(this.ChannelIndexes[i] !== undefined ? this.ChannelIndexes[i] : -1);
        }

        Ajax.do(this.UrlFallback, { clientId: this.ClientId, channels: channelsArr, indexes: indexesArr, sendChannel: channel, sendData: data }, function (responseObj) {
            //console.log("Fallback response", responseObj);
            for (var i = 0; i < responseObj.length; i++) {
                if (!responseObj[i].channel)
                    continue;
                var arrChannelIndex = obj.Channels.indexOf(responseObj[i].channel);
                if (arrChannelIndex < 0) // Unsubscribed before callback was received
                    continue;

                for (var j = 0; j < responseObj[i].messages.length; j++) {
                    obj.Receive(responseObj[i].channel, responseObj[i].messages[j].identity, responseObj[i].messages[j].data);
                }

                // Update our index so we can prevent double-messages
                if (responseObj[i].index != 0)
                    obj.ChannelIndexes[arrChannelIndex] = responseObj[i].index;
            }
        });

        this.FallBackTimeout = setTimeout(function () {
            obj.SendFallBack(null, null);
        }, this.FallbackInterval);
    },
    Send: function (channel, data) {        
        if (this.WebSocket)
            this.WebSocket.SendData("MSG", JSON.stringify({ Channel: channel, Data: data }));
        else if (this.UrlFallback)
            this.SendFallBack(channel, data);       
    }
};"use strict";
/* Minify Skip */
/* Minify Order(100) */

// Component to save and retrieve files, using the Toolkit API
// This component has the same methods as TK.ClientStorage
TK.ServerStorage = {
    _: "component",
    Container: null, // null is only for public file storage/retrieval, use a https:// link for a private storage container with rights check based on the clientId
    ClientId: "Client" + (Math.random() * 100000) + "-" + (Math.random() * 100000) + "-" + (Math.random() * 100000) + "-" + (Math.random() * 100000), // Used for private containers
    Url: "https://toolkitapi.comgenie.com/Storage",

    Store: function (path, blobOrByteArrayOrStringContents, callBack) {
        
        var formData = new FormData();
        var url = "?clientId=" + encodeURIComponent(this.ClientId) + (this.Container ? "&container=" + encodeURIComponent(this.Container) : "");
        
        if (path)
            url += "&fileName=" + encodeURIComponent(path);
        
        if ((window.Blob && blobOrByteArrayOrStringContents instanceof Blob) || (window.File && blobOrByteArrayOrStringContents instanceof File)) {            
            formData.append("files", blobOrByteArrayOrStringContents);
        } else if ((window.Uint8Array && blobOrByteArrayOrStringContents instanceof Uint8Array) || (window.Uint16Array && blobOrByteArrayOrStringContents instanceof Uint16Array)) {
            formData.append("files", new Blob(blobOrByteArrayOrStringContents));
        } else if (blobOrByteArrayOrStringContents.substr && blobOrByteArrayOrStringContents.length && blobOrByteArrayOrStringContents.length > 10 && blobOrByteArrayOrStringContents.substr(0, 5) == "data:") {            
            var blob = new Blob(atob(blobOrByteArrayOrStringContents.split(',')[1])); // Convert base64 data url to blob
            formData.append("files", blob);            
        } else { // string
            if (!blobOrByteArrayOrStringContents.substr)
                blobOrByteArrayOrStringContents = blobOrByteArrayOrStringContents.toString();

            var buf = new ArrayBuffer(blobOrByteArrayOrStringContents.length * 2); // 2 bytes for each char
            var bufView = new Uint16Array(buf);
            for (var i = 0; i < blobOrByteArrayOrStringContents.length; i++)
                bufView[i] = blobOrByteArrayOrStringContents.charCodeAt(i);
            formData.append("files", new Blob(bufView));
        }
        
        Ajax.do(this.Url + "/Store" + url, formData, function (response) {
            if (!callBack)
                return;
            if (response.length && response.length > 0 && response[0].url)
                callBack(response[0]);
            else
                callBack();
        }, null, { parseJSONResponse: true });
    },
    Retrieve: function (path, asBlob, callBack) {
        Ajax.do(this.Url + "/Retrieve", { clientId: this.ClientId, container: this.Container, fileName: path, directly: true }, function (contents) {
            if (callBack)
                callBack(contents);
        }, null, { parseJSONResponse: false, responseType: (asBlob ? "blob" : undefined) });
    },
    GetUrl: function (path, callBack) {
        Ajax.do(this.Url + "/Retrieve", { clientId: this.ClientId, container: this.Container, fileName: path }, function (fileData) {
            if (!callBack)
                return;
            if (fileData.Url)
                callBack(fileData.Url);
            else {
                console.log(fileData); 
                callBack();
            }
        });
    },
    Delete: function (path, callBack) {
        Ajax.do(this.Url + "/Delete", { clientId: this.ClientId, container: this.Container, fileName: path }, function (result) {
            if (callBack)
                callBack(result == "OK");
        });
    },
    List: function (callBack) {
        Ajax.do(this.Url + "/List", { clientId: this.ClientId, container: this.Container }, function (files) {
            if (!callBack)
                return;
            if (files && files.length > 0 && files[0].url)
                callBack(files);
            else {
                console.log(files); 
                callBack();
            }
        });
    },
};
"use strict";
// Sortable table
window.TK.Table = {
    _: "table",
    className: "toolkitTable",
    EnableSort: true,
    EnableFilter: false,
    EnableTotals: false,
    DisableFilterForColumns: [],
    ThresholdFilterMultiselect: 15,
    EnableCheckBoxes: false,
    EnableFullRowCheckBoxToggle: false,
    EnableFullRowClickDeselectOthers: false,
    EnableSelectAllCheckBox: true,
    EnableRemoveButton: false,
    EnablePartialInit: false, // TODO: Only add rows as TR elements which are currently visible
    PageSize: null,
    PageOffset: 0,
    SpecificColumns: null,    
    ColumnTitles: {},
    Templates: {},
    HeaderTemplates: {},
    SortedBy: null,
    SortedDesc: false,
    SortCallBack: null,
    FilterCallBack: null,
    MaxRows: null,
    CurrentFilter: null,    
    DefaultTemplate: {
        _: "td",
        Data: null,
        Init: function () { this.appendChild(document.createTextNode(this.Data)); }
    },
    CheckBoxTemplate: {
        _: "td",
        Data: null,
        onclick: function (event) {
            if (event)
                event.stopPropagation();
            if (window.event)
                window.event.cancelBubble = true;
            return true;
        },
        Elements: {
            CheckBox: {
                _: "input",
                type: "checkbox",
                className: "tableRowCheckBox",
                onclick: function (event) {
                    this.Parent.Table.LastCheckBoxRange = null;
                    if (event.shiftKey && this.Parent.Table.PreviousCheckBox) {
                        // Select everything in between
                        this.Parent.Table.LastCheckBoxRange = [];
                        var curIndex = this.Parent.Parent.RowIndex;
                        var otherIndex = this.Parent.Table.PreviousCheckBox.Parent.Parent.RowIndex;
                        for (var i = curIndex; i != otherIndex; i = (curIndex < otherIndex ? i + 1 : i - 1)) {
                            var checkBoxElement = this.Parent.Table.querySelectorAll(".Element-row" + i + " input[type=checkbox].tableRowCheckBox")[0];
                            if (checkBoxElement.Parent.Parent.style.display == "none")
                                continue; // Skip filtered rows
                            if (checkBoxElement.checked != this.Parent.Table.PreviousCheckBox.checked) {
                                this.Parent.Table.LastCheckBoxRange.push(checkBoxElement.Parent.Row);
                                checkBoxElement.checked = this.Parent.Table.PreviousCheckBox.checked;
                            }                            
                            checkBoxElement.UpdateData();
                        }
                    }
                },
                onblur: function () {
                    this.Parent.Table.PreviousCheckBox = this;
                },
                onchange: function (event) {
                    this.UpdateData();
                    if (this.Parent.Table.EnableSelectAllCheckBox) {
                        var selectAll = this.Parent.Table.querySelectorAll(".tableSelectAllCheckBox")[0];
                        if (selectAll) {
                            var checkBoxElements = this.Parent.Table.Elements.tbody.Elements.ToArray()
                                .Where(function (a) { return a.Elements.CheckBoxes && a.Elements.CheckBoxes.Elements.CheckBox && a.style.display != "none"; })
                                .Select(function (a) { return a.Elements.CheckBoxes.Elements.CheckBox });
                            selectAll.checked = checkBoxElements.length == this.Parent.Table.SelectedRows().length;
                        }
                    }

                    if (this.Parent.Table.CheckboxCheck) {
                        if (!this.Parent.Table.LastCheckBoxRange) {
                            this.Parent.Table.CheckboxCheck([this.Parent.Row], this.checked);
                        } else {
                            if (this.Parent.Table.LastCheckBoxRange.indexOf(this.Parent.Row) < 0)
                                this.Parent.Table.LastCheckBoxRange.push(this.Parent.Row);
                            this.Parent.Table.CheckboxCheck(this.Parent.Table.LastCheckBoxRange, this.checked);
                        }
                    }
                    this.Parent.Table.LastCheckBoxRange = null;
                },
                UpdateData: function () {
                    this.Parent.Row["CheckBoxes"] = this.checked;
                },
                Init: function () {
                    this.checked = this.Parent.Data === true;
                }
            }
        }
    },
    RemoveButtonTemplate: {
        _: "td",
        Data: null,
        onclick: function (event) {
            if (event)
                event.stopPropagation();
            if (window.event)
                window.event.cancelBubble = true;
            return true;
        },
        Elements: {
            RemoveButton: {
                _: "button",
                innerHTML: "Remove",
                onclick: function (event) {
                    // Find with button clicked and delete it from Rows variable in the table
                    var table = this.Parent.Table;
                    var thisRow = this.Parent.Parent.Row;
                    // When the row was succesfully deleted in the save function remove current row
                    if (table.Save(thisRow, true) !== false) {
                        for (var i = 0; i < table.Rows.length; i++) {
                            if (table.Rows[i] == thisRow) {
                                table.Rows.splice(i, 1);
                                break;
                            }
                        }

                        var thisRowNode = this.Parent.Parent;
                        // When the user was editing the row a form is showing on the next row. When this is the case remove that form as well.
                        if (thisRowNode.subTr)
                            thisRowNode.subTr.Remove();
                        thisRowNode.Remove();
                    }
                }
            }
        }
    },
    PreviousCheckBox: null,
    Rows: [],
    Form: null,
    FormAlwaysLoaded: false, // If true, the subViews are initialized directly, but shown/hidden using style.display
    Init: function () {
        if (this.SortedBy && this.Rows && this.Rows.OrderBy) {
            var sortedBy = this.SortedBy;
            this.Rows = this.SortedDesc ? this.Rows.OrderByDesc(function (a) { return a[sortedBy]; }) : this.Rows.OrderBy(function (a) { return a[sortedBy]; });
        }
        this.Refresh();
    },
    RowClick: function (rowObj, trElement) {
        var obj = this;
        if (this.Form) {
            if (!trElement) { // Optional parameter, Find the TR element based on the given row Obj                
                if (!this.Elements.tbody)
                    return;
                for (var rowId in this.Elements.tbody.Elements) {
                    var row = this.Elements.tbody.Elements[rowId];
                    if (row.Row == rowObj) {
                        trElement = row;
                        break;
                    }
                }
                if (!trElement)
                    return;
            }
            if (obj.FormAlwaysLoaded) {
                if (trElement.subTr) {
                    trElement.subTr.style.display = trElement.subTr.style.display == "" ? "none" : "";
                    return;
                }
            } else {
                if (trElement.subTr) {
                    trElement.subTr.parentNode.removeChild(trElement.subTr);
                    trElement.subTr = null;
                    return;
                }
            }
            var template = {
                _: obj.Form,
                Model: rowObj,
                ApplyToModelDirectly: true,
                
            };
            if (obj.Form.Save == undefined) {
                template.Save = function (model) {
                    obj.Save(model, false);
                    obj.UpdateRow(trElement);                    
                };
            }
            if (obj.Form.ApplyToModelDirectly == undefined) {
                template.ApplyToModelDirectly = true;
            }
            this.OpenViewForRow(trElement, template);
        }
    },
    RowDoubleClick: function (rowObj, trElement) { },
    Save: function (rowObj, isRemoved) {
        // Only used when the Form property is given
    },
    OpenViewForRow: function (trElement, template) {
        if (!template || trElement.subTr)
            return;
        var childElements = trElement.Elements.ToArray();
        var tds = 0;
        for (var i = 0; i < childElements.length; i++) {
            tds += childElements[i].colSpan ? parseInt(childElements[i].colSpan) : 1;
        }
        
        trElement.subTr = trElement.Parent.Add(
        {
            _: "tr",      
            ThisIsASubTR: true,
            Destroy: function () {
                trElement.subTr = null;
            },
            Elements: {
                Editor: {
                    _: "td",
                    className: "subView",
                    colSpan: tds,
                    Elements: {
                        View: template
                    }
                }
            }
        });
        trElement.parentNode.insertBefore(trElement.subTr, trElement.nextSibling);
    },
    CheckboxCheck: function (rowsChanged, isChecked) { },
    SelectedRows: function () {
        if (!this.EnableCheckBoxes)
            return [];
        return this.Elements.tbody.Elements.ToArray()
            .Where(function (a) { return a.Elements.CheckBoxes && a.Elements.CheckBoxes.Elements.CheckBox && a.Elements.CheckBoxes.Elements.CheckBox.checked; })
            .Select(function (a) { return a.Row });
    },
    ApplyFilter: function (filter, skipCallback) {
        this.CurrentFilter = filter == null ? "" : filter.toLowerCase ? filter.toLowerCase() : filter;
        if (this.FilterCallBack && !skipCallback) {
            this.FilterCallBack();
            return;
        }

        if (!this.Elements.tbody) {
            return;
        }
        if (this.Elements.thead && this.ColumnFilter) {
            for (var name in this.ColumnFilter) {
                if (this.Elements.thead.Elements.tr.Elements[name]) {
                    this.Elements.thead.Elements.tr.Elements[name].className = this.ColumnFilter[name] ? "toolkitHasFilter" : "";
                }
            }
        }
        this.Elements.tbody.style.display = "none"; // This prevents row style changes to cause render updates, making it a lot faster
        var rows = 0;

        for (var rowId in this.Elements.tbody.Elements) {
            var row = this.Elements.tbody.Elements[rowId];
            if (!row.innerText || row.ThisIsASubTR)
                continue;

            if (this.MaxRows != null && rows >= this.MaxRows) {
                row.style.display = "none";
                if (row.subTr)
                    row.subTr.style.display = "none";
                continue;
            }

            if (row.subTr && row.subTr.Elements && row.subTr.Elements.Editor && row.subTr.Elements.Editor.Elements && row.subTr.Elements.Editor.Elements.View && row.subTr.Elements.Editor.Elements.View.IsVisible && row.subTr.Elements.Editor.Elements.View.IsVisible(this.CurrentFilter)) {
                // The subTr wants to be visible, so we'll also make the parent row visible
                row.style.display = "";
                row.subTr.style.display = "";
                rows++;
                continue;
            }
            
            if (this.CurrentFilter == "" || this.CurrentFilter == null || !row.innerText || (this.CurrentFilter && this.CurrentFilter.toLowerCase && row.innerText.toLowerCase().indexOf(this.CurrentFilter) >= 0) || (this.CurrentFilter && !this.CurrentFilter.toLowerCase && this.CurrentFilter(row.Row, row))) {
                row.style.display = "";
                if (row.subTr)
                    row.subTr.style.display = "";
                rows++;
            } else {
                row.style.display = "none";
                if (row.subTr)
                    row.subTr.style.display = "none";
            }

            if (this.PageSize != null && ((rows - 1) < this.PageOffset || (rows-1) >= this.PageOffset + this.PageSize)) {
                row.style.display = "none";
                if (row.subTr)
                    row.subTr.style.display = "none";
                continue;
            }
        }
        this.Elements.tbody.style.display = "";
        this.VisibleRowCount = rows;

        var ttnc = this.Near(".toolkitTableNavigationContainer");
        if (ttnc)
            ttnc.Init();

        return rows;
    },
    Refresh: function () {
        var obj = this;
        this.Clear();
        this.PreviousCheckBox = null;
        if (this.Rows.length == 0) {
            return;
        }

        // Build header
        var thead = {
            _: "thead",
            Elements: {
                tr: {
                    _: "tr",
                    Elements: {}
                }
            }
        };
        var columns = [];
        if (this.EnableCheckBoxes) {
            columns.push("CheckBoxes");
            if (!this.DisableFilterForColumns)
                this.DisableFilterForColumns = [];
            if (this.DisableFilterForColumns.indexOf("CheckBoxes") < 0)
                this.DisableFilterForColumns.push("CheckBoxes");
            this.ColumnTitles["CheckBoxes"] = " ";
            this.Templates["CheckBoxes"] = this.CheckBoxTemplate;
            if (this.EnableSelectAllCheckBox) {
                this.HeaderTemplates["CheckBoxes"] = {
                    _: "th",
                    Init: function () {
                        var selectAllCheckBox = this.Add({
                            _: "input",
                            type: "checkbox",
                            className: "tableSelectAllCheckBox",
                            onclick: function (event) {
                                if (event)
                                    event.stopPropagation();
                                if (window.event)
                                    window.event.cancelBubble = true;
                            },
                            onchange: function (event) {
                                var checkBoxElements = obj.Elements.tbody.Elements.ToArray()
                                    .Where(function (a) { return a.Elements.CheckBoxes && a.Elements.CheckBoxes.Elements.CheckBox && a.style.display != "none"; })
                                    .Select(function (a) { return a.Elements.CheckBoxes.Elements.CheckBox });
                                var changedRange = [];
                                for (var i = 0; i < checkBoxElements.length; i++) {
                                    if (checkBoxElements[i].checked != this.checked) {
                                        changedRange.push(checkBoxElements[i].Parent.Row);
                                        checkBoxElements[i].checked = this.checked;
                                    }                                    
                                    checkBoxElements[i].UpdateData();
                                }
                                if (obj.CheckboxCheck)
                                    obj.CheckboxCheck(changedRange, this.checked);
                            }
                        });

                        // See if all rows are already selected
                        var totalRowsChecked = 0;
                        for (; totalRowsChecked < obj.Rows.length; totalRowsChecked++) {
                            if (!obj.Rows[totalRowsChecked]["CheckBoxes"])
                                break;
                        }
                        if (totalRowsChecked > 0 && totalRowsChecked == obj.Rows.length)
                            selectAllCheckBox.checked = true;
                    }

                };
            } else {
                this.HeaderTemplates["CheckBoxes"] = null;
            }
        }

        if (this.SpecificColumns && this.SpecificColumns.length > 0) {
            columns = columns.concat(this.SpecificColumns);
        } else {
            for (var name in this.Rows[0]) {
                columns.push(name);
            }
        }

        if (this.EnableRemoveButton) {
            columns.push("RemoveButtons");
            this.ColumnTitles["RemoveButtons"] = " ";
            this.Templates["RemoveButtons"] = this.RemoveButtonTemplate;
        }

        for (var i = 0; i < columns.length; i++) {
            var name = columns[i];

            thead.Elements.tr.Elements[name] = {
                _: this.HeaderTemplates && this.HeaderTemplates[name] ? this.HeaderTemplates[name] : "th",
                innerHTML: (this.ColumnTitles && this.ColumnTitles[name] ? this.ColumnTitles[name] : name),
                className: (name == obj.SortedBy ? "sorted" + (this.SortedDesc ? " desc" : "") : ""),
                DataColumnName: name,
                onclick: function () {
                    if (!obj.EnableSort)
                        return;

                    var thisTh = this;
                    if (obj.SortedBy == this.DataColumnName) {
                        obj.Rows = obj.Rows.reverse();
                        obj.SortedDesc = !obj.SortedDesc;
                    } else {

                        obj.Rows = obj.Rows.OrderBy(function (a) {
                            if (a[thisTh.DataColumnName + "-SortValue"] !== undefined)
                                return a[thisTh.DataColumnName + "-SortValue"];
                            return a[thisTh.DataColumnName];
                        });
                        obj.SortedDesc = false;
                    }
                    obj.SortedBy = this.DataColumnName;

                    if (obj.SortCallBack) {
                        obj.SortCallBack();
                    } else {
                        obj.Refresh();
                    }
                },
                Elements: {}
            };

            // Enable filter button on column
            if (this.EnableFilter && (!this.DisableFilterForColumns || this.DisableFilterForColumns.indexOf(name) < 0 )) {
                thead.Elements.tr.Elements[name].Elements.FilterButton = {
                    className: "toolkitFilterButton",
                    innerHTML: "v",
                    onclick: function (event) {
                        // Open filter window for this column and data type (Slider for numbers, Multiselect for few options, search for many options)
                        var currentHeader = this.Parent;
                        var position = this.Parent.getBoundingClientRect();
                        var filterWindow = {
                            className: "toolkitFilterBox",
                            style: {
                                backgroundColor: "#eee",
                                left: position.left + "px",
                                top: position.bottom + "px",
                                position: "fixed"
                            },
                            Elements: {
                                CloseButton: {
                                    innerHTML: "x",
                                    onclick: function () {
                                        this.Parent.Remove();
                                        obj.ActiveFilterWindow = null;
                                    }
                                },
                                Container: {
                                    Init: function () {
                                        var values = [];
                                        for (var i = 0; i < obj.Rows.length; i++) {
                                            var value = obj.Rows[i][currentHeader.DataColumnName];
                                            if (values.indexOf(value) < 0)
                                                values.push(value);

                                            if (values.length >= obj.ThresholdFilterMultiselect) {
                                                break;
                                            }
                                        }

                                        if (!obj.ColumnFilter)
                                            obj.ColumnFilter = {};
                                        var filterFunc = function (rowObj, trObj) {
                                            for (var name in obj.ColumnFilter) {
                                                if (!obj.ColumnFilter[name])
                                                    continue;
                                                                                                
                                                if (obj.ColumnFilter[name].toLowerCase) { // text match, match if any of the text is in there
                                                    var lowerColumnSearch = obj.ColumnFilter[name].toLowerCase();

                                                    var foundInFieldValue = rowObj[name] && rowObj[name].toString().toLowerCase().indexOf(lowerColumnSearch) >= 0;
                                                    var foundInTdText = trObj.Elements && trObj.Elements[name] && trObj.Elements[name].innerText && trObj.Elements[name].innerText.toLowerCase().indexOf(lowerColumnSearch) >= 0;
                                                    if (!foundInFieldValue && !foundInTdText)
                                                        return false;
                                                    continue;
                                                }

                                                if (Array.isArray(obj.ColumnFilter[name]) && rowObj[name] !== undefined) {
                                                    if (obj.ColumnFilter[name].indexOf(rowObj[name]) < 0)
                                                        return false;
                                                } else if (obj.ColumnFilter[name] != rowObj[name]) { // match exact, for numbers etc.
                                                    return false;
                                                }
                                            }
                                            return true;
                                        };
                                        
                                        if (values.length < obj.ThresholdFilterMultiselect) {
                                            // Show multi select
                                            values = values.OrderBy(function (a) { return a; });
                                            var filterTable = {
                                                _: TK.Table,
                                                EnableFilter: false,
                                                Rows: [],
                                                Templates: obj.Templates,
                                                EnableCheckBoxes: true,
                                                ColumnTitles: {},
                                                CheckboxCheck: function () {
                                                    var rows = this.SelectedRows();
                                                    if (rows.length != this.Rows.length) {
                                                        var allowed = [];
                                                        for (var i = 0; i < rows.length; i++)
                                                            allowed.push(rows[i][currentHeader.DataColumnName]);
                                                        obj.ColumnFilter[currentHeader.DataColumnName] = allowed;
                                                    } else {
                                                        obj.ColumnFilter[currentHeader.DataColumnName] = null;
                                                    }
                                                    obj.ApplyFilter(filterFunc);                           
                                                }
                                            };
                                            filterTable.ColumnTitles[currentHeader.DataColumnName] = "Filter";

                                            for (var i = 0; i < values.length; i++) {
                                                var rowObj = {};
                                                rowObj.CheckBoxes = !obj.ColumnFilter || !obj.ColumnFilter[currentHeader.DataColumnName] || (obj.ColumnFilter[currentHeader.DataColumnName].indexOf(values[i]) >= 0);
                                                rowObj[currentHeader.DataColumnName] = values[i];
                                                filterTable.Rows.push(rowObj)
                                            }
                                            this.Add(filterTable);
                                        } else {
                                            // Show search field
                                            var inputElement = this.Add({
                                                _: "input",
                                                value: !obj.ColumnFilter || !obj.ColumnFilter[currentHeader.DataColumnName] ? "" : obj.ColumnFilter[currentHeader.DataColumnName],
                                                onkeyup: function (event) {

                                                    obj.ColumnFilter[currentHeader.DataColumnName] = (this.value == "") ? null : this.value;
                                                    obj.ApplyFilter(filterFunc);    

                                                    var x = event.which || event.keyCode;
                                                    if (x == 13) {
                                                        this.Near("CloseButton").onclick();
                                                    }
                                                }
                                            });
                                            setTimeout(function () {
                                                inputElement.focus();
                                            }, 1);
                                        }
                                    }
                                }
                            }
                        };

                        if (obj.ActiveFilterWindow)
                            obj.ActiveFilterWindow.Remove();
                        obj.ActiveFilterWindow = TK.Initialize(filterWindow);
                        document.body.appendChild(obj.ActiveFilterWindow);

                        if (event)
                            event.stopPropagation();
                        if (window.event)
                            window.event.cancelBubble = true;
                        return true;
                    }
                };
            }
        }
        this.TableUseColumns = columns;
        // Build contents
        var tbody = {
            _: "tbody",
            Elements: {}
        }
        this.CurrentAddedRowCount = 0;
        this.AddNewRowsToTableBody(tbody);
        this.Add(thead, "thead");
        var tbodyElement = this.Add(tbody, "tbody");
        if (this.FormAlwaysLoaded) {
            var trRows = tbodyElement.Elements.ToArray();
            for (var i = 0; i < trRows.length; i++) {
                this.RowClick(trRows[i].Row, trRows[i]);
                if (trRows[i].subTr) {
                    trRows[i].subTr.style.display = "none";
                }
            }
        }

        var tfoot = {
            _: "tfoot",
            Elements: {}
        };
        var includeTFoot = false;

        if (this.EnableTotals) {
            includeTFoot = true;
            tfoot.Elements.SubTotals = {
                _: "tr",
                Elements: {}
            };
            for (var i = 0; i < columns.length; i++) {
                var name = columns[i];
                if (name == "CheckBoxes" || name == "RemoveButtons") {
                    tfoot.Elements.SubTotals.Elements[name] = {
                        _: "td"
                    };
                    continue;
                }

                var allRowValues = this.Rows.Select(function (a) {
                    return a[name]
                });

                var total = null;
                
                for (var j = 0; j < allRowValues.length; j++) {
                    if (allRowValues[j] !== undefined && allRowValues[j] !== null && allRowValues[j] === +allRowValues[j])
                        total = (total === null ? 0 : total) + allRowValues[j];
                }      
                if (total === null)
                    total = "";
                
                tfoot.Elements.SubTotals.Elements[name] = {
                    _: this.Templates[name] ? this.Templates[name] : this.DefaultTemplate,
                    className: "totalColumn-" + name,
                    Data: total,
                    Values: allRowValues,
                    Table: this 
                };
            }
            
        }

        if (this.MaxRows != null || this.CurrentFilter != null || this.PageSize != null) {
            this.ApplyFilter(this.CurrentFilter, true);
            includeTFoot = true;
            if (this.PageSize) {
                tfoot.Elements.NavigationRow = {
                    _: "tr",
                    Elements: {
                        NavigationCell: {
                            _: "td",
                            className: "toolkitTableNavigationContainer",
                            colSpan: columns.length,
                            Init: function () {
                                this.Clear();
                                var pageCount = Math.ceil(obj.VisibleRowCount / obj.PageSize);
                                var currentPage = Math.floor(obj.PageOffset / obj.PageSize) + 1;                                
                                var maxBeforeAfter = 3;
                                var template = {
                                    _: "button",
                                    className: "toolkitTableNavigation",
                                    disabled: i == currentPage,
                                    innerHTML: i,
                                    onclick: function () {
                                        obj.PageOffset = this.Offset;
                                        obj.Refresh();
                                    }
                                };
                                if (currentPage > maxBeforeAfter + 1) {
                                    template.Offset = 0;
                                    template.innerHTML = 1;
                                    this.Add(template);
                                    this.Add({
                                        _: "span", innerHTML: "..."
                                    });
                                }
                                for (var i = (currentPage > maxBeforeAfter ? currentPage - maxBeforeAfter : 1); i <= pageCount && i < currentPage + maxBeforeAfter; i++) {
                                    template.Offset = (i - 1) * obj.PageSize;
                                    template.disabled = i == currentPage;
                                    template.innerHTML = i;
                                    this.Add(template);
                                }
                                if (currentPage + maxBeforeAfter < pageCount) {
                                    this.Add({
                                        _: "span", innerHTML: "..."
                                    });
                                    template.Offset = (pageCount - 1) * obj.PageSize;
                                    template.innerHTML = pageCount;
                                    this.Add(template);
                                }
                            }                        
                        }
                    }
                };
            }
        }

        if (includeTFoot)
            this.Add(tfoot, "tfoot");
    },
    AddRow: function (row, rowClick) {
        this.Rows.push(row);
        if (this.Elements.tbody) {
            var tr = this.AddNewRowsToTableBody()[0];
            if (!tr) {
                this.Refresh();
            } else  if (rowClick && tr) {
                this.RowClick(tr.Row, tr);
                return;
            }
        } else {
            this.Refresh();            
        }

        if (rowClick) {
            this.RowClick(row);
        }
    },
    UpdateRow: function (trRow) {
        var template = this.GenerateRowTemplate(trRow.Row, trRow.RowIndex);
        var tr = this.Elements.tbody.Add(template, "row" + trRow.RowIndex);
        trRow.parentNode.insertBefore(tr, trRow);
        if (trRow.subTr) {
            trRow.subTr.Remove();
        }
        trRow.Remove();        
    },
    AddNewRowsToTableBody: function (tbody) {
        if (!tbody)
            tbody = this.Elements.tbody;
        var newElements = [];
        var obj = this;
        for (var i = this.CurrentAddedRowCount; i < this.Rows.length; i++) {
            var tr = this.GenerateRowTemplate(this.Rows[i], i);
            if (tbody.Add) {
                newElements.push(tbody.Add(tr, "row" + i));
            } else {
                tbody.Elements["row" + i] = tr;
            }
        }
        this.CurrentAddedRowCount = this.Rows.length;
        return newElements;
    },
    GenerateRowTemplate: function (rowObj, rowIndex) {        
        var obj = this;
        var tr = {
            _: "tr",
            Elements: {},
            Row: rowObj,
            RowIndex: rowIndex,
            onclick: function (event) {
                if (obj.EnableFullRowCheckBoxToggle) {
                    var checkBoxElement = this.querySelector("input[type=checkbox]");
                    if (checkBoxElement != null) {
                        if (obj.EnableFullRowClickDeselectOthers && !event.shiftKey && !event.ctrlKey) {
                            var allCheckBoxes = obj.querySelectorAll("input[type=checkbox]");
                            for (var i = 0; i < allCheckBoxes.length; i++) {
                                allCheckBoxes[i].checked = false;
                            }
                        }
                        checkBoxElement.checked = !checkBoxElement.checked;
                        checkBoxElement.onclick(event);
                        checkBoxElement.onchange();
                        obj.PreviousCheckBox = checkBoxElement;
                    }
                }
                obj.RowClick(this.Row, this);
            },
            ondblclick: function () {
                if (obj.RowDoubleClick) {
                    obj.RowDoubleClick(this.Row, this);
                }
            }
        };
        
        for (var j = 0; j < this.TableUseColumns.length; j++) {
            var name = this.TableUseColumns[j];
            var templateToUse = this.DefaultTemplate;
            if (this.Templates[name]) {
                templateToUse = this.Templates[name];
            }
            tr.Elements[name] = {
                _: templateToUse,
                Data: rowObj[name],
                Row: rowObj,
                Table: this
                
            };

            if (rowObj[name] && rowObj[name].substr && rowObj[name].substr(0, 6) == "/Date(") {
                var tmp = rowObj[name].substr(6);
                tmp = tmp.substr(0, tmp.length - 2);
                rowObj[name + "-SortValue"] = new Date(parseInt(tmp)).getTime();
            }
        }
        return tr;
    }
};

window.TK.AjaxTable = {
    _: window.TK.Table,
    Url: null,
    Post: null,
    AjaxSettings: {},
    
    Init: function () {
        this.RefreshData();        
    },
    RefreshData: function () {        
        this.Clear();        
        var obj = this;
        
        if (this.Url) {
            var url = this.Url;
            
            if (url.indexOf("SORTBY") >= 0) {
                // Sort using ajax requests
                var tmp = this.SortedBy ? this.SortedBy : "";

                url = url.replace("SORTBY", encodeURIComponent(tmp));
                url = url.replace("SORTDESC", this.SortedDesc);
                this.SortCallBack = function () {
                    obj.RefreshData();
                };
            }

            if (url.indexOf("FILTER") >= 0) {
                // Limit rows using ajax requests
                var filter = this.CurrentFilter ? this.CurrentFilter : "";
                url = url.replace("FILTER", encodeURIComponent(filter));
                this.FilterCallBack = function () {
                    obj.RefreshData();
                };
            }
            if (url.indexOf("COUNT") >= 0) {
                // Limit rows using ajax requests
                // TODO
            }


            Ajax.do(url, this.Post, function (response) {
                if (!obj.Post || typeof obj.Post === "string" || obj.Post instanceof String) {
                    obj.Rows = JSON.parse(response);
                } else {
                    obj.Rows = response;
                }
                obj.Refresh();
                obj.Update();
            }, undefined, this.AjaxSettings);
        }
    },
    Update: function () { }
};
"use strict";
window.TK.Toast = {
    _: "component",
    Template: {
        _: "div",
        className: "toolkitToast",
        Title: "",
        Message: "",
        Action: null,
        Init: function () {
            if (this.Title) {
                this.Elements.TitleH3.appendChild(document.createTextNode(this.Title));
            } else {
                this.Elements.TitleH3.style.display = "none";
            }
            this.Elements.Message.appendChild(document.createTextNode(this.Message));
        },
        onclick: function () {
            if (this.Action)
                this.Action(this);            
        },
        Elements: {
            TitleH3: {},
            Message: {}
        },
        Destroy: function () {
            var obj = this;
            TK.Toast.CurrentToasts = TK.Toast.CurrentToasts.Where(function (a) { return a != obj });
        }
    },
    Position: 0,  // 0 Top, 0.5 Top right, 1 Right, 1.5 Bottom right, 2 Bottom, 2.5 Bottom left, 3 Left, 3.5 Top left
    VisibleMS: 3000,
    Width: 250,
    Height: 100,
    CurrentToasts: [],
    Create: function (title, message, action) {
        var toast = TK.Initialize({ _: this.Template, Title: title, Message: message, Action: action });
        toast.style.position = "fixed";
        toast.style.width = this.Width + "px";
        
        var offset = 5;
        var offsetStep = this.Position == 1 || this.Position == 3 ? this.Width : this.Height;
        for (var i = 0; i < TK.Toast.CurrentToasts.length; i++) {
            if (TK.Toast.CurrentToasts[i].ToastOffset + offsetStep > offset && TK.Toast.CurrentToasts[i].ToastPosition == this.Position) {
                offset = TK.Toast.CurrentToasts[i].ToastOffset + offsetStep + 5;
            }
        }
        toast.ToastOffset = offset;
        toast.ToastPosition = this.Position;
        TK.Toast.CurrentToasts.push(toast);
        //toast.style.height = this.Height + "px";
        if (this.Position == 0) {
            toast.style.top = offset + "px";
            toast.style.left = ((window.innerWidth / 2) - (this.Width / 2)) + "px";
        } else if (this.Position == 0.5) {
            toast.style.top = offset + "px";
            toast.style.right = "5px";
        } else if (this.Position == 1) {
            toast.style.top = ((window.innerHeight / 2) - (this.Height / 2)) + "px";
            toast.style.right = offset + "px";
        } else if (this.Position == 1.5) {
            toast.style.bottom = offset + "px";
            toast.style.right = "5px";
        } else if (this.Position == 2) {
            toast.style.bottom = offset +"px";
            toast.style.left = ((window.innerWidth / 2) - (this.Width / 2)) + "px";
        } else if (this.Position == 2.5) {
            toast.style.bottom = offset +"px";
            toast.style.left = "5px";
        } else if (this.Position == 3) {
            toast.style.top = ((window.innerHeight / 2) - (this.Height / 2)) + "px";
            toast.style.left = offset +"px";
        } else if (this.Position == 3.5) {
            toast.style.top = offset + "px";
            toast.style.left = "5px";
        }
        document.body.appendChild(toast);
        setTimeout(function () {
            toast.className += " toolkitVisible";
        }, 10);
        setTimeout(function () {
            toast.Remove();
        }, this.VisibleMS);

        

        return toast;
    }
};"use strict";
window.TK.Tree = {
    _: "ul",    
    IdField: "Id",
    ParentIdField: "ParentId",
    CurrentFilter: null,
    Rows: [],
    CurRows: null,
    className: "tree toolkitTree",
    EnableFullRowExpand: false,
    AutoExpandChildNodesDuringFilter: true, // When applying filter with showAllChildNodes=true and this setting is set to false, the child rows will be visible but not expanded
    Template: {
        _: "li",
        Data: null,
        Init: function () {
            this.Elements.Text.innerText = (this.Data && this.Data.Text) ? this.Data.Text : "";
        },
        Elements: {
            Text: { _: "span" }
        }
    },
    Expanded: function (row, byUserClick, rowElement) {

    },
    Collapsed: function (row, byUserClick, rowElement) {

    },    
    Init: function () {
        if (this.Rows.length == 0)
            return;
        this.Refresh();
    },    
    AddExpandButtonToRowElement: function (rowElement) {
        var obj = this;
        if (rowElement.SubList)
            return; // Already has an expand button
        rowElement.SubList = document.createElement("UL");
        rowElement.SubList.style.display = "none";
        rowElement.className += " collapsed";
        rowElement.appendChild(rowElement.SubList);
        var expandButton = document.createElement("SPAN");

        expandButton.className = "expandCollapseButton";
        var collapsed = window.SvgPath("M3,2L7,6L3,10", 12, 12, "#999");
        expandButton.innerHTML = collapsed;
        expandButton.Update = function () {
            if (this.parentNode.className.indexOf("expanded") >= 0) {
                this.innerHTML = window.SvgPath("M2,3L6,7L10,3", 12, 12, "#999");
            } else {
                this.innerHTML = collapsed;
            }
        };
        expandButton.onclick = function (e) {
            if (this.parentNode.className.indexOf("expanded") >= 0) {
                obj.Collapsed(this.parentNode.Data, true, this.parentNode);
                this.parentNode.SubList.style.display = "none";
                this.parentNode.className = this.parentNode.className.replace(/expanded/g, "") + " collapsed";
            } else {
                obj.Expanded(this.parentNode.Data, true, this.parentNode);
                this.parentNode.SubList.style.display = "";
                this.parentNode.className = this.parentNode.className.replace(/collapsed/g, "") + " expanded";
            }
            this.Update();
            if (e)
                e.stopPropagation();
            return false;
        };
        rowElement.ExpandCollapseButton = expandButton;
        rowElement.insertBefore(expandButton, rowElement.firstChild);
    },
    AddRows: function (rows) {
        var obj = this;
        if (!this.CurRows)
            this.CurRows = {};

        // First add all the rows
        var ignoredRows = [];
        var addedRows = [];

        for (var i = 0; i < rows.length; i++) {
            var rowId = rows[i][this.IdField];

            if (this.CurRows["id" + rowId]) { // Won't insert duplicated id's
                ignoredRows.push(rows[i]);
                continue;
            }
            var rowElement = this.Add({
                _: this.Template,
                Data: rows[i],
                onclick: function (e) {
                    if (e && e.target && (e.target.tagName == "INPUT" || e.target.tagName == "SELECT" || e.target.tagName == "TEXTAREA" || e.target.PreventRowClick))
                        return;
                    obj.RowClick(this.Data, e, this);
                    if (obj.EnableFullRowExpand && this.ExpandCollapseButton) {
                        this.ExpandCollapseButton.click();
                    }
                    e.stopPropagation();
                    return false;
                }
            });

            if (rows[i].AlwaysShowExpandButton) {
                this.AddExpandButtonToRowElement(rowElement);
            }

            if (this.CurrentFilter && rowElement.innerText.toLowerCase().indexOf(this.CurrentFilter) < 0) {
                rowElement.style.display = "none";
            }
            this.CurRows["id" + rowId] = rowElement;            
            addedRows.push(rows[i]);
            this.Rows.push(rows[i]);
        }

        // Then move them to the right items
        for (var i = 0; i < rows.length; i++) {            
            if (ignoredRows.indexOf(rows[i]) >= 0)
                continue;
            var rowId = rows[i][this.IdField];
            var parentId = rows[i][this.ParentIdField];

            if (!parentId || !this.CurRows["id" + parentId])
                continue;

            // Add expand button to the parent item
            var parent = this.CurRows["id" + parentId];
            this.AddExpandButtonToRowElement(parent);

            // Move this item to the right parent element
            parent.SubList.appendChild(this.CurRows["id" + rowId]);
        }

        return addedRows;
    },
    RemoveRows: function (rows) {
        for (var i = 0; i < rows.length; i++) {
            var rowId = rows[i][this.IdField];
            var rowElement = this.CurRows["id" + rowId];

            if (rowElement)
                rowElement.parentNode.removeChild(rowElement);
            var posIndex = this.Rows.indexOf(rows[i]);
            if (posIndex >= 0) {
                this.Rows.splice(posIndex, 1);
            }
        }
    },
    Refresh: function () {
        this.Clear();
        var rows = this.Rows;
        this.Rows = []; // Will be filled again
        this.CurRows = {};
        this.AddRows(rows);
    },
    ApplyFilter: function (filter, showAllChildNodes, callBackFoundRows) {
        filter = filter.toLowerCase();
        if (filter == "") {
            this.Refresh(); // Collapse everything
            return;
        }

        // Show item and all parent nodes, display:none the rest
        this.style.display = "none"; // Faster when updating

        // First hide everything
        for (var item in this.CurRows) {
            var row = this.CurRows[item];
            row.style.display = "none";
        }
        var foundRows = [];

        // Then make everything matching visible, including all parents and optionally all child nodes
        var filterParts = filter.split(/;/g);
        for (var i = 0; i < filterParts.length; i++) {
            for (var item in this.CurRows) {
                var row = this.CurRows[item];
                var txt = "";
                if (row.SubList) { // Only look at the text of this element
                    for (var j = 0; j < row.childNodes.length; j++) {
                        if (row.childNodes[j] != row.SubList)
                            txt += row.childNodes[j].innerText;
                    }
                } else {
                    txt = row.innerText;
                }

                if (txt.toLowerCase().indexOf(filterParts[i]) >= 0) {
                    row.style.display = "";
                    foundRows.push(row);

                    if (!this.AutoExpandChildNodesDuringFilter && row.className.indexOf("collapsed") < 0) {
                        row.className = row.className.replace(/expanded/g, "") + " collapsed";
                        if (row.ExpandCollapseButton)
                            row.ExpandCollapseButton.Update();
                    }
                    
                    if (showAllChildNodes && row.SubList) {                        
                        var subLists = [row.SubList];
                        for (var j = 0; j < subLists.length; j++) {
                            var curList = subLists[j];
                            var addClass = "expanded";
                            var removeClass = "collapsed";
                            var setStyle = "";

                            if (!this.AutoExpandChildNodesDuringFilter) {
                                addClass = "collapsed";
                                removeClass = "expanded";
                                setStyle = "none";
                            }

                            curList.style.display = setStyle;

                            for (var n = 0; n < curList.childNodes.length; n++) {
                                var li = curList.childNodes[n];
                                if (li.className.indexOf(addClass) < 0) {
                                    li.className = li.className.replace(removeClass, "") + " " + addClass;
                                    if (addClass == "expanded")
                                        this.Expanded(li.Data, false, curList);
                                    else
                                        this.Collapsed(li.Data, false, curList);

                                    if (li.ExpandCollapseButton)
                                        li.ExpandCollapseButton.Update();
                                }
                                if (li.style)
                                    li.style.display = "";
                                if (li.SubList)
                                    subLists.push(li.SubList);
                            }
                        }
                    }

                    // Expand all items above
                    while (row.parentNode.Rows == undefined) {
                        row = row.parentNode;
                        if (row.SubList && row.className.indexOf("expanded") < 0) {
                            row.className = row.className.replace(/collapsed/g, "") + " expanded";
                            this.Expanded(row.Data, false, row);
                            if (row.ExpandCollapseButton)
                                row.ExpandCollapseButton.Update();
                        }
                        row.style.display = "";
                    }                    
                }
            }
        }
        this.style.display = "";
        if (callBackFoundRows) {
            callBackFoundRows(foundRows);
        }
    },
    SelectRow: function (id) {
        // Select a single item and expand+scroll the tree to that item
        var curSelectedItem = this.querySelector(".selectedItem");
        if (curSelectedItem)
            curSelectedItem.className = curSelectedItem.className.replace(/selectedItem/g, "");

        var currentRow = this.CurRows["id" + id];
        if (!currentRow)
            return;

        currentRow.className += " selectedItem";
        var row = currentRow;

        row.style.display = "";
        if (row.SubList) {
            this.Expanded(row.Data, false, row);
            row.className = row.className.replace(/collapsed/g, "") + " expanded";            
            row.SubList.style.display = "";
        }
        while (row.parentNode.Rows == undefined) {
            row = row.parentNode;
            if (row.SubList) {
                this.Expanded(row.Data, false, row);
                row.className = row.className.replace(/collapsed/g, "") + " expanded";
            }
            row.style.display = "";
        }
        currentRow.scrollIntoView();

        return currentRow;
    },
    RowClick: function (rowObj, jsEvent) { }
};
window.TK.AjaxTree = {
    _: window.TK.Tree,
    Url: null,
    Post: "",
    AjaxSettings: {},
    Init: function () {
        this.Clear();
        var obj = this;
        if (this.Url) {
            Ajax.do(this.Url, this.Post, function (response) {
                if (response && response.substr)
                    response = JSON.parse(response);
                obj.Rows = response;
                obj.Refresh();
                obj.Update();
            }, undefined, this.AjaxSettings);
        }
    },
    Update: function () { }
};"use strict";
/* Minify Order(110) */
// Dragable items on a board
window.TK.Dashboard = {
    _: "div",
    EnableMove: true,
    EnableCopy: true,
    EnableResize: true,
    EnableRemove: true,
    EnableEdit: true,
    EnableLimitX: true,
    EnableLimitY: true,
    EnableDrop: false,
    Spacing: 5,
    SnapSize: 100,
    EditMode: 1, // 0: None, 1: Show edit buttons when hovering, 2: Always show edit buttons
    className: "toolkitDashboard",
    DashboardItems: [],
    DefaultWidth: 600,
    AutoGrow: true, // Automatic increase size of this element (Adds [SnapSize] spacing to this div when moving/resizing elements)
    AutoShrink: false,
    AutoWidthCount: null, // When this is a positive value, the snap size will be adjusted automatically to make sure there are always X 'blocks' in the width

    Init: function () {
        this.SetEditMode(this.EditMode);
        
        if (this.DashboardItems) {
            var obj = this;
            setTimeout(function () {
                obj.Load(obj.DashboardItems);
            }, 1);
        }
    },
    SetEditMode: function (newEditMode) {
        this.EditMode = newEditMode;
        var newClassName = this.className.replace(/toolkitDashboardEditable/g, "").replace(/toolkitDashboardAlwaysEditable/g, "");

        if (this.EditMode == 1)
            newClassName += " toolkitDashboardEditable toolkitDragDropContainer";
        else if (this.EditMode == 2)
            newClassName += " toolkitDashboardAlwaysEditable toolkitDragDropContainer";
        this.className = newClassName;
    },
    Save: function () {
        var state = [];
        var items = this.Elements.ToArray();
        for (var i = 0; i < items.length; i++) {
            if (!items[i].Elements || !items[i].Elements.Content || !items[i].Elements.Content.StateProperties)
                continue;
            var c = items[i].Elements.Content;
            var stateProperties = {};
            for (var j = 0; j < c.StateProperties.length; j++) {
                stateProperties[c.StateProperties[j]] = c[c.StateProperties[j]];
            }
            state.push({ _: c.StateObjectName, State: stateProperties, Top: items[i].Top, Left: items[i].Left, Width: items[i].Width, Height: items[i].Height });
        }
        this.DashboardItems = state;
        return JSON.stringify(state);
    },
    Load: function (state) {
        if (state.substr)
            state = JSON.parse(state);
        this.Clear();       
        var regex = /[^A-Za-z0-9\.]/g;
       
        if (this.AutoWidthCount) {            
            this.SnapSize = Math.floor(this.offsetWidth / this.AutoWidthCount);
            while (this.offsetWidth / (this.SnapSize + this.Spacing) < this.AutoWidthCount && this.SnapSize > 30) {
                this.SnapSize -= 5;
            }
        }
        
        for (var i = 0; i < state.length; i++) {
            if (regex.exec(state[i]._))
                continue;
            var tmp = eval(state[i]._ + ".StateObjectName");
            if (!tmp)
                continue;
            var stateProperties = state[i].State;
            stateProperties._ = state[i]._;
            this.AddDashboardItem(stateProperties, null, state[i].Left, state[i].Top, state[i].Width, state[i].Height);
        }
    },
    CanDrop: function (elementOrTemplate) {
        if (!this.EnableDrop)
            return false;
        for (var i = 0; i < 30 && elementOrTemplate._ && !elementOrTemplate.StateObjectName; i++)
            elementOrTemplate = elementOrTemplate._;
        return (elementOrTemplate && elementOrTemplate.StateObjectName);
    },
    Drop: function (elementOrTemplate, x, y) {
        if (!this.EnableDrop)
            return;
        var size = this.SnapSize + this.Spacing;
        y = Math.round(y / size);
        x = Math.round(x / size);

        if (y < 0) y = 0;
        if (x < 0) x = 0;

        var width = (elementOrTemplate.Width ? elementOrTemplate.Width : 1);
        var height = (elementOrTemplate.Height ? elementOrTemplate.Height : 1);
        if (!elementOrTemplate.appendChild) { // A template has been dropped
            return this.AddDashboardItem(elementOrTemplate, "block" + new Date().getTime(), x, y, width, height);
        } else { // An element has been dropped, add a block and then replace the content element
            var addedBlock = this.AddDashboardItem({}, "block" + new Date().getTime(), x, y, width, height);
            addedBlock.Elements.Content.Remove();
            addedBlock.Elements.Content = elementOrTemplate;
            elementOrTemplate.Parent = addedBlock;
            addedBlock.appendChild(elementOrTemplate);
            return addedBlock;
        }
    },
    AutoGrowHandler: function (restore) {
        if (restore) {
            this.className = this.className.replace(/toolkitDashboardEditing/g, "");
        } else if (this.className.indexOf("Editing") < 0) {            
            this.className += " toolkitDashboardEditing";
        }

        if (!this.AutoGrow || this.offsetHeight == 0)
            return;

        var items = this.Elements.ToArray();
        var maxBottomY = 0;
        for (var i = 0; i < items.length; i++) {
            if (!items[i].Elements || !items[i].Elements.Content || !items[i].Height)
                continue;
            var bottomY = this.TopOrLeftSquaresToPX(items[i].Top) + this.HeightOrWidthSquaresToPX(items[i].Height);
            if (maxBottomY < bottomY)
                maxBottomY = bottomY;
        }
        var newHeight = maxBottomY + (this.SnapSize + this.Spacing);
        if (!this.style.height || parseInt(this.style.height) < newHeight || this.AutoShrink)
            this.style.height = newHeight + "px";
    },

    TemplateDashboardItem: {
        style: {
            position: "absolute"
        },
        DashboardElement: null,
         // Position/Sizes are in snap-index
        Left: 0,
        Top: 0,
        Width: 1,
        Height: 1,
        ontouchstart: function () {
            if (this.DashboardElement.EditMode == 0)
                return;

            if (this.className.indexOf("toolkitSelectedDashboardItem") < 0) {
                this.className += " toolkitSelectedDashboardItem";
            } else {
                this.className = this.className.replace(/toolkitSelectedDashboardItem/g, "");
            }            
        },
        Init: function () {
            var obj = this;
            if (this.DashboardElement.EnableMove) {
                this.Add({
                    _: "div",
                    className: "tkDashboardButton",
                    innerHTML: Svg.Icons.Move,
                    ontouchstart: function (e) {
                        this.onmousedown(e.touches[0]);
                        e.stopPropagation();
                    },
                    onmousedown: function (e) {
                        var x, y;
                        try { x = e.pageX; y = e.pageY; } catch (errie) { var e2 = window.event; x = e2.clientX; y = e2.clientY; }
                        var startX = x - obj.offsetLeft;
                        var startY = y - obj.offsetTop;
                        var startWidth = obj.offsetWidth;
                        var startHeight = obj.offsetHeight;
                        var totalWidth = obj.DashboardElement.offsetWidth;
                        var totalHeight = obj.DashboardElement.offsetHeight;

                        window.onmousemove = function (e) {
                            var x, y;
                            try { x = e.pageX; y = e.pageY; } catch (errie) { var e2 = window.event; x = e2.clientX; y = e2.clientY; }
                            var newLeft = (x - startX);
                            var newTop = (y - startY);
                            var size = obj.DashboardElement.SnapSize + obj.DashboardElement.Spacing;
                            newTop = Math.round(newTop / size);
                            newLeft = Math.round(newLeft / size);
                            if (newTop < 0) newTop = 0;
                            if (newLeft < 0) newLeft = 0;

                            totalWidth = obj.DashboardElement.offsetWidth;
                            totalHeight = obj.DashboardElement.offsetHeight;

                            if (obj.DashboardElement.EnableLimitX && totalWidth > 0 && (newLeft * size) + startWidth > totalWidth) newLeft = Math.floor((totalWidth - startWidth) / size);
                            if (obj.DashboardElement.EnableLimitY && totalHeight > 0 && (newTop * size) + startHeight > totalHeight) newTop = Math.floor((totalHeight - startHeight) / size);

                            if (newLeft < 0) newLeft = 0;
                            if (newTop < 0) newTop = 0;

                            obj.Left = newLeft;
                            obj.Top = newTop;
                            obj.SetSize();
                            obj.DashboardElement.AutoGrowHandler();
                        };
                        
                        window.onmouseup = function () {
                            window.onmousemove = null;
                            window.onmouseup = null;
                            window.onselectstart = null;
                            window.ontouchend = null;
                            window.ontouchmove = null;
                            obj.DashboardElement.AutoGrowHandler(true);
                        };
                        window.ontouchmove = function (e) {
                            if (window.onmousemove)
                                window.onmousemove(e.touches[0]);
                            e.stopPropagation();
                        };
                        window.ontouchend = function (e) {
                            if (window.onmouseup)
                                window.onmouseup();
                            e.stopPropagation();
                        };
                        window.onselectstart = function () { return false; };

                        if (e && e.preventDefault)
                            e.preventDefault();
                        else
                            window.event.returnValue = false;
                    }
                }, "MoveButton");
            }

            if (this.DashboardElement.EnableResize) {
                this.Add({
                    _: "div",
                    className: "tkDashboardButton",
                    innerHTML: Svg.Icons.Resize,
                    ontouchstart: function (e) {
                        this.onmousedown(e.touches[0]);
                        e.stopPropagation();
                    },
                    onmousedown: function (e) {
                        var startX, startY;
                        try { startX = e.pageX; startY = e.pageY; } catch (errie) { var e2 = window.event; startX = e2.clientX; startY = e2.clientY; }
                        var startWidth = obj.offsetWidth;
                        var startHeight = obj.offsetHeight;
                        var totalWidth = obj.DashboardElement.offsetWidth;
                        var totalHeight = obj.DashboardElement.offsetHeight;

                        window.onmousemove = function (e) {
                            var x, y;
                            try { x = e.pageX; y = e.pageY; } catch (errie) { var e2 = window.event; x = e2.clientX; y = e2.clientY; }
                            var newWidth = (x - startX) + startWidth;
                            var newHeight = (y - startY) + startHeight;
                            var size = obj.DashboardElement.SnapSize;
                            newHeight = Math.round(newHeight / size);
                            newWidth = Math.round(newWidth / size);

                            var newWidthPx = ((newWidth * obj.DashboardElement.SnapSize) + ((newWidth - 1) * obj.DashboardElement.Spacing));                            
                            var newHeightPx = ((newHeight * obj.DashboardElement.SnapSize) + ((newHeight - 1) * obj.DashboardElement.Spacing));

                            totalWidth = obj.DashboardElement.offsetWidth;
                            totalHeight = obj.DashboardElement.offsetHeight;

                            if (obj.DashboardElement.EnableLimitX && totalWidth > 0 && obj.DashboardElement.TopOrLeftSquaresToPX(obj.Left) + newWidthPx > totalWidth) newWidth = Math.floor((totalWidth + obj.DashboardElement.Spacing) / (size + obj.DashboardElement.Spacing)) - obj.Left;
                            if (obj.DashboardElement.EnableLimitY && totalHeight > 0 && obj.DashboardElement.TopOrLeftSquaresToPX(obj.Top) + newHeightPx > totalHeight) newHeight = Math.floor((totalHeight + obj.DashboardElement.Spacing) / (size + obj.DashboardElement.Spacing)) - obj.Top;

                            obj.Width = newWidth;
                            obj.Height = newHeight;
                            obj.SetSize(true);
                            obj.DashboardElement.AutoGrowHandler();
                            
                        };
                        window.onmouseup = function () {
                            window.onmousemove = null;
                            window.onmouseup = null;
                            window.onselectstart = null;
                            window.ontouchend = null;
                            window.ontouchmove = null;
                            obj.DashboardElement.AutoGrowHandler(true);
                        };
                        window.ontouchmove = function (e) {
                            if (window.onmousemove)
                                window.onmousemove(e.touches[0]);
                            e.stopPropagation();
                        };
                        window.ontouchend = function (e) {
                            if (window.onmouseup)
                                window.onmouseup();
                            e.stopPropagation();
                        };
                        window.onselectstart = function () { return false; };

                        if (e && e.preventDefault)
                            e.preventDefault();
                        else
                            window.event.returnValue = false;
                    }
                }, "ResizeButton");
            }

            if (this.DashboardElement.EnableRemove) {
                this.Add({
                    _: "div",
                    className: "tkDashboardButton",
                    innerHTML: Svg.Icons.Close,
                    ontouchstart: function (e) {
                        e.stopPropagation();
                    },
                    onclick: function () {
                        obj.Remove();
                    }
                }, "RemoveButton");
            }

            if (this.DashboardElement.EnableEdit && this.Elements.Content && this.Elements.Content.Editor) {
                this.Add({
                    _: "div",
                    className: "tkDashboardButton",
                    innerHTML: Svg.Icons.Settings,
                    ontouchstart: function (e) {
                        e.stopPropagation();
                    },
                    onclick: function () {
                        obj.Elements.Content.Add({ _: obj.Elements.Content.Editor });
                    }
                }, "EditButton");
            }

            if (this.DashboardElement.EnableCopy) {
                this.Add({
                    _: "div",
                    className: "tkDashboardButton",
                    innerHTML: Svg.Icons.Copy,
                    ontouchstart: function (e) {
                        this.onmousedown(e.touches[0]);
                        e.stopPropagation();
                    },
                    onmousedown: function (e) {
                        var x, y;
                        try { x = e.pageX; y = e.pageY; } catch (errie) { var e2 = window.event; x = e2.clientX; y = e2.clientY; }
                        var startX = x - obj.offsetLeft;
                        var startY = y - obj.offsetTop;
                        var startWidth = obj.offsetWidth;
                        var startHeight = obj.offsetHeight;
                        var totalWidth = obj.DashboardElement.offsetWidth;
                        var totalHeight = obj.DashboardElement.offsetHeight;

                        var duplicate = null;
                        window.onmousemove = function (e) {                            

                            var x, y;
                            try { x = e.pageX; y = e.pageY; } catch (errie) { var e2 = window.event; x = e2.clientX; y = e2.clientY; }
                            var newLeft = (x - startX);
                            var newTop = (y - startY);
                            var size = obj.DashboardElement.SnapSize + obj.DashboardElement.Spacing;
                            newTop = Math.round(newTop / size);
                            newLeft = Math.round(newLeft / size);
                            if (newTop < 0) newTop = 0;
                            if (newLeft < 0) newLeft = 0;

                            totalWidth = obj.DashboardElement.offsetWidth;
                            totalHeight = obj.DashboardElement.offsetHeight;

                            if (obj.DashboardElement.EnableLimitX && totalWidth > 0 && (newLeft * size) + startWidth > totalWidth) newLeft = Math.floor((totalWidth - startWidth) / size);
                            if (obj.DashboardElement.EnableLimitY && totalHeight > 0 && (newTop * size) + startHeight > totalHeight) newTop = Math.floor((totalHeight - startHeight) / size);

                            if (newLeft < 0) newLeft = 0;
                            if (newTop < 0) newTop = 0;

                            if (newLeft == obj.Left && newTop == obj.Top)
                                return;

                            if (!duplicate) {           
                                var c = obj.Elements.Content;
                                var stateProperties = {}                                
                                for (var i = 0; c.StateProperties && i < c.StateProperties.length; i++) {
                                    stateProperties[c.StateProperties[i]] = c[c.StateProperties[i]];
                                }
                                stateProperties = JSON.parse(JSON.stringify(stateProperties)); // Make sure all objects are cloned   
                                stateProperties._ = c.StateObjectName;
                                
                                duplicate = obj.DashboardElement.AddDashboardItem(stateProperties);
                                duplicate.Width = obj.Width;
                                duplicate.Height = obj.Height;
                            }

                            duplicate.Left = newLeft;
                            duplicate.Top = newTop;
                            duplicate.SetSize();
                            obj.DashboardElement.AutoGrowHandler();
                        };
                        window.onmouseup = function () {
                            window.onmousemove = null;
                            window.onmouseup = null;
                            window.onselectstart = null;
                            window.ontouchend = null;
                            window.ontouchmove = null;
                            obj.DashboardElement.AutoGrowHandler(true);
                        };
                        window.ontouchmove = function (e) {
                            if (window.onmousemove)
                                window.onmousemove(e.touches[0]);
                            e.stopPropagation();
                        };
                        window.ontouchend = function (e) {
                            if (window.onmouseup)
                                window.onmouseup();
                            e.stopPropagation();
                        };
                        window.onselectstart = function () { return false; };

                        if (e && e.preventDefault)
                            e.preventDefault();
                        else
                            window.event.returnValue = false;
                    }
                }, "CopyButton");
            }

            this.SetSize();
        },
        SetSize: function (sizeActuallyChanged) {
            var newWidth = this.DashboardElement.HeightOrWidthSquaresToPX(this.Width) + "px";
            var newHeight = this.DashboardElement.HeightOrWidthSquaresToPX(this.Height) + "px";
            this.style.top = this.DashboardElement.TopOrLeftSquaresToPX(this.Top) + "px";
            this.style.left = this.DashboardElement.TopOrLeftSquaresToPX(this.Left) + "px";

            if (newWidth != this.style.width || newHeight != this.style.height) {
                this.style.width = this.DashboardElement.HeightOrWidthSquaresToPX(this.Width) + "px";
                this.style.height = this.DashboardElement.HeightOrWidthSquaresToPX(this.Height) + "px";
            } else {
                sizeActuallyChanged = false;
            }

            if (sizeActuallyChanged && this.Elements.Content.SizeChanged)
                this.Elements.Content.SizeChanged();
        }
    },
    TopOrLeftSquaresToPX: function (topOrLeft) {
        return (topOrLeft * (this.SnapSize + this.Spacing));
    },
    HeightOrWidthSquaresToPX: function (heightOrWidth) {
        return ((heightOrWidth * this.SnapSize) + ((heightOrWidth - 1) * this.Spacing));
    },
    AddDashboardItem: function (element, name, x, y, width, height) {
        if (!width) width = 1;
        if (!height) height = 1;

        if (x === undefined || x === null || y === null || y === undefined) {
            // Auto find available place            
            var totalWidth = this.offsetWidth;
            if (totalWidth == 0)
                totalWidth = this.DefaultWidth;
            
            var totalWidthInSquares = Math.floor((totalWidth + this.Spacing) / (this.SnapSize + this.Spacing));
            
            y = 0;
            var found = false;
            while (y < 100) {                
                x = 0;
                while (x <= totalWidthInSquares - width) {
                    // Check if there is overlap with existing items
                    var items = this.Elements.ToArray();
                    found = true;                    
                    for (var i = 0; i < items.length; i++) {
                        if (!items[i].Elements || !items[i].Elements.Content || !items[i].Height)
                            continue;                        
                        if (x >= items[i].Left + items[i].Width || items[i].Left >= x + width)
                            continue;
                        if (y >= items[i].Top + items[i].Height || items[i].Top >= y + height)
                            continue;
                        found = false;
                        break;
                    }
                    if (found)
                        break;
                    x++;
                }             
                if (found)
                    break;
                y++;
            }            
        }


        var addedBlock = this.Add({
            _: this.TemplateDashboardItem,
            DashboardElement: this,
            Elements: {
                Content: element
            },
            Top: y,
            Left: x,
            Width: width,
            Height: height 
        }, name);
        this.AutoGrowHandler(true);
        return addedBlock;
    }
};

// Items with a saveable state
window.TK.DashboardTemplates = {};
window.TK.DashboardTemplates.BaseWithEditor = {
    Editor: {
        _: TK.Popup,
        Title: "Edit block",
        Template: {            
            Init: function () {
                var element = this.Parent.Parent;
                var properties = {};
                for (var i = 0; i < element.StateProperties.length; i++)
                    properties[element.StateProperties[i]] = element.Properties && element.Properties[element.StateProperties[i]] ? element.Properties[element.StateProperties[i]] : { };
                
                this.Add({
                    _: TK.Form,
                    Model: element,
                    Fields: properties,
                    IgnoreRest: true,
                    ApplyToModelDirectly: true,
                    Save: function () {
                        element.Init();
                    }
                });
            }
        }
    }
};

window.TK.DashboardTemplates.Text = {
    _: window.TK.DashboardTemplates.BaseWithEditor,
    StateObjectName: "TK.DashboardTemplates.Text",
    StateProperties: ["Text"],
    Text: null,
    Init: function () {
        if (this.Text) {
            var obj = this;
            this.Clear();
            this.Add({
                _: "span",
                Init: function () {
                    this.appendChild(document.createTextNode(obj.Text));
                }
            });
        }
    }
};"use strict";
/* Minify Order(110) */
// TODO: Support for moment.js, country code: moment.tz.zone(timeZone).abbr(timeZoneOffset);
window.TK.DateTime = {
    _: "div",    
    className: "toolkitDateTime",    
    MonthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    EnableTime: true,
    EnableTimeZone: true,
    EnableRelative: false,
    TimeZone: "Local", // UTC, Local
    UseGlobalTimeZone: true, // If true, the time zone will be based on the static TK.DateTime.TimeZone , and not this instance
    AlwaysNavigateToStartOfDay: false, // When set to true, selecting a day will always set time to 00:00, even if there was already a value or the day is today
    WeekStart: 1, // 0 Sunday, 1 Monday
    ValueIsEpoch: false,
    Data: null,
    onchange: function () { },
    readOnly: false,
    disabled: false,
    DisplayCodes: {
        EuropeAmsterdam: "NL",
        EuropeParis: "FR",
        EuropeLondon: "UK",
        EuropeDublin: "IE",
        EuropeLuxembourg: "LU",
        EuropeBerlin: "DE",
        EuropeBrussels: "BR",
        EuropeOslo: "NO",
        EuropeStockholm: "SE",
        AsiaTokyo: "JP",        
    },
    
    Init: function () {
        if (this.DataSettings) {
            var fields = ["ValueIsEpoch", "EnableTime", "EnableTimeZone", "EnableRelative", "TimeZone", "WeekStart", "UseGlobalTimeZone"];
            for (var i = 0; i < fields.length; i++) {
                if (this.DataSettings[fields[i]] !== undefined)
                    this[fields[i]] = this.DataSettings[fields[i]];
            }
        }
        if (this.EnableRelative && this.Data == "now") {
            this.Data = "|";
        }
        if (!this.EnableTimeZone) {
            this.UseGlobalTimeZone = false;
            this.TimeZone = "UTC";
        }

        if (this.ValueIsEpoch && this.Data && (!this.Data.indexOf || this.Data == parseInt(this.Data).toString()))
        {
            this.Data = new Date(parseInt(this.Data) * 1000).toISOString();
        }
        this.RenderDateInput(this.Elements.Selection, this.Data);
        this.RefreshDateInput(true);
        this.Elements.DateInputContainer.Elements.TimeZoneInfo.style.display = (this.EnableTimeZone ? "" : "none");
    },
    GetValue: function () {
        var isoDate = this.Data;
        if (this.EnableRelative && isoDate && isoDate.indexOf && isoDate.indexOf("|") >= 0) {
            return isoDate;
        }

        if (this.ValueIsEpoch) {
            return Math.floor(new Date(isoDate).getTime() / 1000);
        }
        if (this.EnableTime)
            return isoDate;    
        
        if (!isoDate)
            return null;
        
        var dateObj = new Date(isoDate);

        if (this.GetTimeZone() == "UTC") {
            dateObj.setUTCHours(0);
            dateObj.setUTCMinutes(0);
            dateObj.setUTCSeconds(0);
        } else if (this.GetTimeZone() == "Local") {
            dateObj.setHours(0);
            dateObj.setMinutes(0);
            dateObj.setSeconds(0);            
        } else {
            // TODO
        }
        
        return dateObj.toISOString();
    },
    Elements: {
        DateInputContainer: {
            className: "dateTimeContainer",
            Elements: {
                TimeZoneInfo: {
                    className: "timeZoneInfo",
                    onclick: function () {
                        this.Parent.Parent.SetTimeZone(this.Parent.Parent.GetTimeZone() == "UTC" ? "Local" : "UTC");
                        this.Parent.Elements.DateInput.focus();
                    }
                }, 
                DateInput: {
                    onkeyup: function () {
                        if (this.value == "") {
                            this.className = "";
                            this.Parent.Parent.Data = null;
                            return;
                        }
                        var v = this.value.replace(/\\/g, "-").replace(/\//g, "-").replace(/T/g, " ").replace(/\.000/g, "").replace(/Z/g, "");
                        
                        var parts = v.split(" ");
                        var dParts = parts[0].split("-");
                        var tParts = [];
                        if (parts.length > 1)
                            tParts = parts[1].split(":");

                        var year=0, month=1, day=1, hour=0, minute=0, second=0;

                        if (dParts.length >= 3) {
                            if (dParts[0].length > 2) { // Starts with year
                                year = parseInt(dParts[0]);
                                month = parseInt(dParts[1]);
                                day = parseInt(dParts[2]);
                            } else if (dParts[0].length == 2 && dParts[1].length == 2 && dParts[2].length == 2) { // dd-MM-yy
                                day = parseInt(dParts[0]);
                                month = parseInt(dParts[1]);
                                year = 2000 + parseInt(dParts[2]);                                
                            } else {
                                day = parseInt(dParts[0]);
                                month = parseInt(dParts[1]);
                                year = parseInt(dParts[2]);
                            }
                        }

                        if (tParts.length >= 2) {
                            hour = parseInt(tParts[0]);
                            minute = parseInt(tParts[1]);
                            if (tParts.length >= 3)
                                second = parseInt(tParts[2]);                            
                        }
                        var validDate = true;
                        if (year < 1900 || year > 9999 || day > 31 || day < 1 || month < 1 || month > 12 || hour >= 24 || hour < 0 || minute < 0 || minute >= 60 || second < 0 || second >= 60) {
                            validDate = false;
                        }

                        var tmpDateTime = null;
                        var obj = this.Parent.Parent;
                        if (obj.GetTimeZone() == "UTC") {
                            tmpDateTime = new Date(year + "-" + obj.NumberFormat(month) + "-" + obj.NumberFormat(day) + "T" + obj.NumberFormat(hour) + ":" + obj.NumberFormat(minute) + ":" + obj.NumberFormat(second)+"Z");
                        } else {
                            tmpDateTime = new Date(year, month - 1, day, hour, minute, second);
                        }

                        if (!validDate || isNaN(tmpDateTime.getHours())) {
                            this.className = "invalidDate";
                            return;
                        }
                        this.className = "";
                        this.Parent.Parent.RenderDateInput(this.Parent.Parent.Elements.Selection, tmpDateTime.toISOString());
                    },
                    onblur: function () {
                        if (this.Parent.Parent.readOnly || this.Parent.Parent.disabled)
                            return;
                        var obj = this;
                        if (obj.Parent.Parent.Elements.Selection.InRelativeEditor)
                            return; // Don't auto hide the relative editor

                        this.TimeOut = setTimeout(function () {
                            obj.TimeOut = 0;
                            if (obj.Parent.Parent.Elements.Selection) {
                                obj.Parent.Parent.Elements.Selection.style.display = "none";
                                obj.Parent.Parent.Elements.Selection.style.position = "absolute";
                                obj.Parent.Parent.Elements.Selection.style.top = "";
                                obj.Parent.Parent.Elements.Selection.style.left = "";
                                obj.Parent.Parent.appendChild(obj.Parent.Parent.Elements.Selection); // Move element back (so the next time the position will be correct as well)
                            }
                        }, 250);
                    },
                    onfocus: function () {
                        if (this.Parent.Parent.readOnly || this.Parent.Parent.disabled)
                            return;
                        if (this.TimeOut)
                            clearTimeout(this.TimeOut);
                        // TODO: Append the selection div to the body and use a fixed positioning so the selection div will be over anything
                        this.Parent.Parent.Elements.Selection.style.display = "";
                        this.Parent.Parent.Elements.Selection.style.zIndex = "20000";
                        this.Parent.Parent.Elements.Selection.DetachElementFromParent();
                    }
                },
            }
        }, 
        Selection: {
            style: { display: "none"}
        }
    },
    NumberFormat: function (d) {
        return d < 10 ? "0" + d : "" + d;
    },
    FormatOffset: function (offsetInMinutes) {
        var direction = offsetInMinutes < 0 ? "-" : "+";
        offsetInMinutes = Math.abs(offsetInMinutes);
        var hours = Math.floor(offsetInMinutes / 60);
        var minutes = offsetInMinutes % 60;
        
        return direction + this.NumberFormat(hours) + ":" + this.NumberFormat(minutes);
    },
    RefreshDateInput: function (dontFocus) {
        var obj = this;
        
        if (this.EnableTimeZone) {
            if (this.GetTimeZone() == "UTC") {
                this.Elements.DateInputContainer.Elements.TimeZoneInfo.innerHTML = "UTC";
                this.Elements.DateInputContainer.Elements.TimeZoneInfo.title = "Universal timezone";
            } else if (this.GetTimeZone() == "Local") {
                if (this.Data) {
                    this.Elements.DateInputContainer.Elements.TimeZoneInfo.innerHTML = this.FormatOffset(-(new Date(this.Data).getTimezoneOffset()));
                    //this.Elements.DateInputContainer.Elements.TimeZoneInfo.style.display = "";
                } else {
                    this.Elements.DateInputContainer.Elements.TimeZoneInfo.innerHTML = this.FormatOffset(-(new Date().getTimezoneOffset()));
                    //this.Elements.DateInputContainer.Elements.TimeZoneInfo.style.display = "none";
                }

                try {
                    var timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                    this.Elements.DateInputContainer.Elements.TimeZoneInfo.title = timeZone;
                    timeZone = timeZone.replace("/", "");
                    if (this.DisplayCodes[timeZone]) {
                        this.Elements.DateInputContainer.Elements.TimeZoneInfo.innerHTML = this.DisplayCodes[timeZone];
                    }

                } catch (errie) {
                    this.Elements.DateInputContainer.Elements.TimeZoneInfo.title = "Local timezone";
                }

            } else {
                // TODO
            }
        }
        
        this.Elements.DateInputContainer.Elements.DateInput.readOnly = this.readOnly ? true : false;
        this.Elements.DateInputContainer.Elements.DateInput.disabled = this.disabled ? true : false;

        var isRelative = (this.EnableRelative && this.Data && this.Data.indexOf && this.Data.indexOf("|") >= 0);
        this.className = "toolkitDateTime" + (this.disabled ? " toolkitDateTimeDisabled" : "") + (this.readOnly ? " toolkitDateTimeReadOnly" : "") + (isRelative ? " toolkitDateTimeRelative" : "");

        if (!this.Data) {
            this.Elements.DateInputContainer.Elements.DateInput.value = "";
            return;
        }
        var d;
        if (isRelative) {
            // Parse and display
            d = window.TK.DateTimeRelativeToDateObj(this.Data, this.GetTimeZone());
        } else {
            var d = new Date(this.Data);
        }
        
        if (this.GetTimeZone() == "UTC") {
            this.Elements.DateInputContainer.Elements.DateInput.value = obj.NumberFormat(d.getUTCFullYear()) + "-" + obj.NumberFormat(d.getUTCMonth() + 1) + "-" + obj.NumberFormat(d.getUTCDate());
            if (this.EnableTime)
                this.Elements.DateInputContainer.Elements.DateInput.value += " " + obj.NumberFormat(d.getUTCHours()) + ":" + obj.NumberFormat(d.getUTCMinutes()) + ":" + obj.NumberFormat(d.getUTCSeconds());
        } else if (this.GetTimeZone() == "Local") {
            this.Elements.DateInputContainer.Elements.DateInput.value = obj.NumberFormat(d.getFullYear()) + "-" + obj.NumberFormat(d.getMonth() + 1) + "-" + obj.NumberFormat(d.getDate());
            if (this.EnableTime)
                this.Elements.DateInputContainer.Elements.DateInput.value += " " + obj.NumberFormat(d.getHours()) + ":" + obj.NumberFormat(d.getMinutes()) + ":" + obj.NumberFormat(d.getSeconds());
        } else {
            // TODO: Implement custom timezones
        }

        if (!dontFocus)
            this.Elements.DateInputContainer.Elements.DateInput.focus();
    },
    GetTimeZone: function () {
        return this.UseGlobalTimeZone ? window.TK.DateTime.TimeZone : this.TimeZone;
    },
    SetTimeZone: function (newTimeZone) {
        if (this.UseGlobalTimeZone) {
            window.TK.DateTime.TimeZone = newTimeZone;
            var allPickers = document.querySelectorAll(".toolkitDateTimeSelector");
            for (var i = 0; i < allPickers.length; i++) {
                if (allPickers[i].Parent && allPickers[i].Parent.RenderDateInput && allPickers[i].Parent.UseGlobalTimeZone) {
                    allPickers[i].Parent.RenderDateInput(allPickers[i], allPickers[i].DateISO);
                    allPickers[i].Parent.RefreshDateInput(true);
                }
            }
        } else {
            this.TimeZone = newTimeZone;
            this.RenderDateInput(this.Elements.Selection, this.Data);
            this.RefreshDateInput(true);
        }
    },
    RenderDateInput: function (element, dateISO) {
        var obj = this;     
        if (this.NotFirst && dateISO != this.Data) {
            this.Data = dateISO;
            if (this.onchange)
                this.onchange();
        }
        this.NotFirst = true;

        this.Data = dateISO;
        element.DateISO = dateISO;
        
        if (!dateISO)
            dateISO = new Date().toISOString();        

        if (this.EnableRelative && dateISO.indexOf("|") >= 0) {
            element.InRelativeEditor = true;
            // Show relative editor
            element.className = "toolkitDateTimeSelector toolkitDateTimeSelectorRelative";
            element.innerHTML = "";
            element.onclick = function () { };

            var topButtonContainerR = document.createElement("DIV");
            topButtonContainerR.className = "topButtonContainer";

            var switchRelativeButtonR = document.createElement("DIV");
            switchRelativeButtonR.className = "switchRelativeButton";
            switchRelativeButtonR.innerHTML = "Relative Date";
            switchRelativeButtonR.onclick = function () {
                // Switch back
                obj.RenderDateInput(element, window.TK.DateTimeRelativeToDateObj(dateISO, obj.GetTimeZone()).toISOString());
            };
            topButtonContainerR.appendChild(switchRelativeButtonR);
            element.appendChild(topButtonContainerR);
            
            var parts = dateISO.split(/\|/g);
            var lineContainer = document.createElement("DIV");
            
            for (var i = 0; i < parts.length; i++) {
                var p = parts[i];
                if (p.length == 0)
                    continue;
                var line = document.createElement("DIV");
                line.className = "toolkitRelativeDateLine";
                var selectPart = document.createElement("SELECT");
                selectPart.appendChild(new Option("Year", "y"));
                selectPart.appendChild(new Option("Month", "M"));
                selectPart.appendChild(new Option("Day", "d"));
                selectPart.appendChild(new Option("Hour", "H"));
                selectPart.appendChild(new Option("Minute", "m"));
                selectPart.appendChild(new Option("Weekday", "w"));
                selectPart.value = p.substr(0, 1);
                p = p.substr(1);
                line.appendChild(selectPart);

                var selectMutation = document.createElement("SELECT");
                selectMutation.appendChild(new Option("=>", ""));
                selectMutation.appendChild(new Option("+"));
                selectMutation.appendChild(new Option("-"));
                selectMutation.value = "";
                if (p.length > 0 && p.substr(0, 1) == "+" || p.substr(0, 1) == "-") {
                    selectMutation.value = p.substr(0, 1);
                    p = p.substr(1);
                }
                line.appendChild(selectMutation);

                var inputValue = document.createElement("INPUT");
                line.appendChild(inputValue);
                if (p.length > 0) {
                    inputValue.value = p;
                }
                var removeLineButton = document.createElement("BUTTON");
                removeLineButton.innerHTML = "x";
                removeLineButton.onclick = function () {
                    this.parentNode.parentNode.removeChild(this.parentNode);
                };
                removeLineButton.className = "removeLineButton";
                line.appendChild(removeLineButton);
                line.Part = selectPart;
                line.Mutation = selectMutation;
                line.Value = inputValue;
                lineContainer.appendChild(line);        
            }
            lineContainer.GetRelativeDate = function () {
                var str = "|";
                for (var i = 0; i < this.childNodes.length; i++) {
                    if (this.childNodes[i].Value.value != "" && !isNaN(parseInt(this.childNodes[i].Value.value)))
                        str += this.childNodes[i].Part.value + this.childNodes[i].Mutation.value + this.childNodes[i].Value.value + "|";
                }
                return str;
            };
            element.appendChild(lineContainer);

            var addLineButton = document.createElement("BUTTON");
            addLineButton.className = "toolkitAddLineButton";
            addLineButton.innerHTML = "+";
            addLineButton.onclick = function () {
                obj.RenderDateInput(element, lineContainer.GetRelativeDate() + "|d-1");
            };
            element.appendChild(addLineButton);

            var applyButton = document.createElement("BUTTON");
            applyButton.className = "toolkitApplyButton";
            applyButton.innerHTML = "Apply";
            applyButton.onclick = function () {
                obj.RenderDateInput(element, lineContainer.GetRelativeDate());
                obj.RefreshDateInput();
                element.style.display = "none";
            };
            element.appendChild(applyButton);

            obj.Elements.DateInputContainer.Elements.DateInput.focus();
            return;
        }
        element.InRelativeEditor = false;
        var dateObj = new Date(dateISO);
        element.className = "toolkitDateTimeSelector";
        element.innerHTML = "";

        element.onclick = function () {
            obj.Elements.DateInputContainer.Elements.DateInput.focus();
        };

        window.TK.DateTimeUpdateDateObject(dateObj, obj.GetTimeZone());

        var getButtons = function (text, funcPrevious, funcNext) {
            var div = document.createElement("DIV");
            div.className = "buttonLine";
            div.PreviousButton = document.createElement("BUTTON");
            div.PreviousButton.innerHTML = "<";
            div.PreviousButton.className = "previousButton";
            div.PreviousButton.onclick = funcPrevious;
            div.PreviousButton.type = "button";
            div.PreviousButton.tabIndex = -1;

            div.StatusText = document.createElement("DIV");
            div.StatusText.className = "statusText";
            div.StatusText.innerHTML = text;

            div.NextButton = document.createElement("BUTTON");
            div.NextButton.innerHTML = ">";            
            div.NextButton.onclick = funcNext;
            div.NextButton.className = "nextButton";
            div.NextButton.type = "button";
            div.NextButton.tabIndex = -1;
            div.appendChild(div.PreviousButton);
            div.appendChild(div.StatusText);
            div.appendChild(div.NextButton);
            return div;
        };
        var topButtonContainer = document.createElement("DIV");
        topButtonContainer.className = "topButtonContainer";

        if (this.EnableTimeZone) {
            var switchUTCButton = document.createElement("DIV");
            switchUTCButton.className = "switchUTCButton";
            switchUTCButton.innerHTML = this.GetTimeZone() == "UTC" ? "UTC" : obj.FormatOffset(-dateObj.getTimezoneOffset());
            switchUTCButton.tabIndex = -1;

            try {
                if (this.GetTimeZone() == "Local") {
                    var timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
                    switchUTCButton.title = timeZone;
                    timeZone = timeZone.replace("/", "");
                    if (this.DisplayCodes[timeZone]) {
                        switchUTCButton.innerHTML = this.DisplayCodes[timeZone];
                    }
                }
            } catch (errie) { }


            switchUTCButton.onclick = function () {
                obj.SetTimeZone(obj.GetTimeZone() == "UTC" ? "Local" : "UTC");
            };
            switchUTCButton.title = dateISO + " - " + dateObj.toLocaleString();
            topButtonContainer.appendChild(switchUTCButton);
        }

        if (this.EnableRelative) {
            var switchRelativeButton = document.createElement("DIV");
            switchRelativeButton.innerHTML = "Fixed date";
            switchRelativeButton.className = "switchRelativeButton";
            switchRelativeButton.onclick = function () {
                // Switch to relative                
                obj.RenderDateInput(element, "y" + dateObj.getFullYear() + "|M" + (dateObj.getMonth() + 1) + "|d" + dateObj.getDate() + "|H" + dateObj.getHours() + "|m" + dateObj.getMinutes());
            };
            switchRelativeButton.tabIndex = -1;
            topButtonContainer.appendChild(switchRelativeButton);
        }

        element.appendChild(topButtonContainer);

        element.appendChild(getButtons(dateObj.getFullYear(),
            function () {
                dateObj.setFullYear(dateObj.getFullYear() - 1);
                obj.RenderDateInput(element, dateObj.toISOString());
                obj.RefreshDateInput();
            },function () {
                dateObj.setFullYear(dateObj.getFullYear() + 1);
                obj.RenderDateInput(element, dateObj.toISOString());
                obj.RefreshDateInput();
                obj.Elements.DateInputContainer.Elements.DateInput.focus();
            }));

        element.appendChild(getButtons(obj.MonthNames[dateObj.getMonth()],
            function () {
                var expectedMonth = (dateObj.getMonth() - 1) % 12;
                dateObj.setMonth(dateObj.getMonth() - 1);
                if (dateObj.getMonth() != expectedMonth)
                    dateObj.setDate(dateObj.getDate() - 1);
                obj.RenderDateInput(element, dateObj.toISOString());
                obj.RefreshDateInput();
            }, function () {
                var expectedMonth = (dateObj.getMonth() + 1) % 12;
                dateObj.setMonth(dateObj.getMonth() + 1);
                if (dateObj.getMonth() != expectedMonth)
                    dateObj.setDate(dateObj.getDate() - 1);
                obj.RenderDateInput(element, dateObj.toISOString());
                obj.RefreshDateInput();
            }));

        var daySelection = getButtons("",
            function () {
                dateObj.setDate(dateObj.getDate() - 1);
                obj.RenderDateInput(element, dateObj.toISOString());
                obj.RefreshDateInput();
            }, function () {
                dateObj.setDate(dateObj.getDate() + 1);
                obj.RenderDateInput(element, dateObj.toISOString());
                obj.RefreshDateInput();
            });
        daySelection.StatusText.className = "statusText daySelection";
        var firstDay = new Date(dateISO);
        firstDay.setDate(1);
        
        var getDay = function (dateObj) {
            return (dateObj.getDay() - obj.WeekStart) < 0 ? 7 + (dateObj.getDay() - obj.WeekStart) : (dateObj.getDay() - obj.WeekStart);
        };
        
        var lineCount = 0;

        for (var i = 1 - getDay(firstDay); i <= 31 || lineCount < 7; i++) {
            if (lineCount == 7) {
                daySelection.StatusText.appendChild(document.createElement("BR"));
                lineCount = 0;
            }

            lineCount++;
            var tmpDateObj = new Date(dateISO);
            var curMonth = tmpDateObj.getMonth();
            tmpDateObj.setDate(i);

            if (i >= 28 && lineCount == 1 && tmpDateObj.getMonth() != curMonth) 
                break;
            
            var dayItem = document.createElement("BUTTON");
            dayItem.innerHTML = tmpDateObj.getDate();
            dayItem.className = "dayItem " + (i == dateObj.getDate() ? "selected" : "") + (tmpDateObj.getMonth() != curMonth ? " otherMonth" : "");

            //dayItem.title = tmpDateObj.toISOString();
            dayItem.DateIndex = i;
            dayItem.tabIndex = -1;
            dayItem.onclick = function (e) {
                dateObj.setDate(this.DateIndex);
                dateObj.setMilliseconds(0);
                if (obj.AlwaysNavigateToStartOfDay || (!obj.Data && (dateObj.getDate() != new Date().getDate() || dateObj.getDay() != new Date().getDay() || dateObj.getFullYear() != new Date().getFullYear()))) {                    
                    // Different day, default to 00:00:00
                    dateObj.setHours(0);
                    dateObj.setMinutes(0);
                    dateObj.setSeconds(0);
                }
                obj.RenderDateInput(element, dateObj.toISOString());
                obj.RefreshDateInput(true);
                var event = e || window.event;
                event.stopPropagation();
                return false;
            };
            daySelection.StatusText.appendChild(dayItem);
        }
        element.appendChild(daySelection);

        if (this.EnableTime) {
            element.appendChild(getButtons(obj.NumberFormat(dateObj.getHours()) + ":" + obj.NumberFormat(dateObj.getMinutes()) + ":" + obj.NumberFormat(dateObj.getSeconds()),
                function () {
                    dateObj.setUTCMinutes(dateObj.getUTCMinutes() - 15);
                    obj.RenderDateInput(element, dateObj.toISOString());
                    obj.RefreshDateInput();
                }, function () {
                    dateObj.setUTCMinutes(dateObj.getUTCMinutes() + 15);                    
                    obj.RenderDateInput(element, dateObj.toISOString());
                    obj.RefreshDateInput();
                }));


        }

        //element.appendChild(document.createTextNode(dateObj.toString()));
    },
    Destroy: function () {
        if (this.Elements.Selection)
            this.Elements.Selection.Remove();
    }
    
};

window.TK.DateTime.TimeZone = "Local";
window.TK.DateTimeUpdateDateObject = function (dateObj, timeZone) {
    if (timeZone == "UTC") {
        dateObj.getMonth = dateObj.getUTCMonth;
        dateObj.setMonth = dateObj.setUTCMonth;
        dateObj.getHours = dateObj.getUTCHours;
        dateObj.setHours = dateObj.setUTCHours;
        dateObj.getMinutes = dateObj.getUTCMinutes;
        dateObj.setMinutes = dateObj.setUTCMinutes;
        dateObj.getSeconds = dateObj.getUTCSeconds;
        dateObj.setSeconds = dateObj.setUTCSeconds;
        dateObj.getDate = dateObj.getUTCDate;
        dateObj.setDate = dateObj.setUTCDate;
    }
};
window.TK.DateTimeRelativeToDateObj = function (dateStr, timeZone) {
    var dateObj = new Date();    
    window.TK.DateTimeUpdateDateObject(dateObj, timeZone);
    dateObj.setSeconds(0);
    dateObj.setMilliseconds(0);
    var parts = dateStr.split('|');
    for (var i = 0; i < parts.length; i++) {
        if (parts[i].length < 2)
            continue;
        if (parts[i][1] == "+" || parts[i][1] == "-") {
            var value = parseInt(parts[i].substr(2));
            if (parts[i][1] == "-")
                value = -value;

            if (parts[i][0] == "y")
                dateObj.setFullYear(dateObj.getFullYear() + value);
            else if (parts[i][0] == "M")
                dateObj.setMonth(dateObj.getMonth() + (value));
            else if (parts[i][0] == "d")
                dateObj.setDate(dateObj.getDate() + value);
            else if (parts[i][0] == "H")
                dateObj.setHours(dateObj.getHours() + value);
            else if (parts[i][0] == "m")
                dateObj.setMinutes(dateObj.getMinutes() + value);
            else if (parts[i][0] == "s")
                dateObj.setSeconds(dateObj.getSeconds() + value);
            else if (parts[i][0] == "w") {
                var realModification = Math.abs(value);
                if (realModification == 7)
                    realModification = 0;

                dateObj.setDate(dateObj.getDate() + (realModification - dateObj.getDay()));
                if (dateObj.getDay() < realModification) {
                    if (value < 0)
                        dateObj.setDate(dateObj.getDate() - 7);
                }
                else {
                    if (value > 0)
                        dateObj.setDate(dateObj.getDate() + 7);
                }
            }
        } else { // Set
            var value = parseInt(parts[i].substr(1));
            if (parts[i][0] == "y")
                dateObj.setFullYear(value);
            else if (parts[i][0] == "M")
                dateObj.setMonth(value - 1);
            else if (parts[i][0] == "d")
                dateObj.setDate(value);
            else if (parts[i][0] == "H")
                dateObj.setHours(value);
            else if (parts[i][0] == "m")
                dateObj.setMinutes(value);
            else if (parts[i][0] == "s")
                dateObj.setSeconds(value);
            else if (parts[i][0] == "w") {
                var isoDay = dateObj.getDay();
                if (isoDay == 0)
                    isoDay = 7;
                dateObj.setDate(dateObj.getDate() + (value - isoDay));
            }
        }
    }
    return dateObj;
};



if (window.TK.Form) {
    window.TK.Form.DefaultTemplates.datetime = {
        _: TK.DateTime
    };
    window.TK.Form.DefaultTemplates.date = {
        _: TK.DateTime,
        EnableTime: false
    };
    window.TK.Form.DefaultTemplates.datetimeasp = {
        className: "dateTimeAsp",
        Init: function () {
            var isoString = null;
            if (this.Data) {
                isoString = window.ConvertFromASPTime(this.Data);
                if (!isoString)
                    isoString = new Date().toISOString();
            }
            this.Add({
                _: TK.DateTime,
                Data: isoString,
                disabled: this.disabled,
                readOnly: this.readOnly,
                onchange: this.onchange,
                onfocus: this.onfocus,
                onblur: this.onblur,
                DataSettings: this.DataSettings
            }, "DateInput");
        },
        GetValue: function () {
            var value = this.Elements.DateInput.GetValue();
            if (!value)
                return value;
            var time = new Date(value).getTime();
            if (isNaN(time)) {
                alert("Date time value of " + value + " is not valid.");
                throw "Date time value of " + value + " is not valid.";
            }
            return "/Date(" + time + ")/";
        }
    };
}
"use strict";
/* Minify Order(110) */
TK.HtmlEditor = {
    className: "toolkitHtmlEditor",
    FillContainer: false,
    Buttons: ["IncreaseFontSize", "DecreaseFontSize", "Bold", "Italic", "Underline", "AlignLeft", "AlignCenter", "AlignRight", "Indent", "Outdent", "Paragraph", "Header1", "Header2", "Header3", "CodeBlock", "QuoteBlock"],
    __RecursivePropertiesButtonTemplates: true,
    EnableHTMLPasting: true,
    RemoveScripts: true,
    RemoveScriptsHandler: function (html) {
        var len = -1;
        while (len != html.length) {
            len = html.length;
            html = html.replace(/<(script|link|iframe|noscript|meta|object|embed|frameset|style)/ig, "<r ").replace(/javascript:/ig, "removed:").replace(/ (href|src)=(?!"http|"data|"\/)/ig, " r=\"").replace(/\/\*[\S]*\*\//ig, "").replace(/\&\#(010|X0A);/ig, "").replace(/expression\(/ig, "r(").replace(/( |\/)on(\w+)( *)=/ig, " r=");
        }
        return html;
    },
    ButtonTemplates: {
        IncreaseFontSize: {
            innerHTML: Svg.Icons.TextIncrease,
            onmousedown: function () {
                if (this.Parent.CurSize < 7)
                    this.Parent.CurSize++;
                document.execCommand("fontSize", false, this.Parent.CurSize);
                this.Near("Editor").focus();
            }
        },
        DecreaseFontSize: {
            innerHTML: Svg.Icons.TextDecrease,
            onmousedown: function () {
                if (this.Parent.CurSize > 1)
                    this.Parent.CurSize--;
                document.execCommand("fontSize", false, this.Parent.CurSize);
                this.Near("Editor").focus();
            }
        },
        Bold: {
            innerHTML: Svg.Icons.TextBold,
            onmousedown: function () {
                document.execCommand("bold", false, null);
                this.Near("Editor").focus();
            }
        },
        Italic: {
            innerHTML: Svg.Icons.TextItalic,
            onmousedown: function () {
                document.execCommand("italic", false, null);
                this.Near("Editor").focus();
            }
        },
        Underline: {
            innerHTML: Svg.Icons.TextUnderline,
            onmousedown: function () {
                document.execCommand("underline", false, null);
                this.Near("Editor").focus();
            }
        },
        AlignLeft: {
            innerHTML: Svg.Icons.TextAlignLeft,
            onmousedown: function () {
                document.execCommand("justifyLeft", false, null);
                this.Near("Editor").focus();
            }
        },
        AlignCenter: {
            innerHTML: Svg.Icons.TextAlignCenter,
            onmousedown: function () {
                document.execCommand("justifyCenter", false, null);
                this.Near("Editor").focus();
            }
        },
        AlignRight: {
            innerHTML: Svg.Icons.TextAlignRight,
            onmousedown: function () {
                document.execCommand("justifyRight", false, null);
                this.Near("Editor").focus();
            }
        },
        Indent: {
            innerHTML: Svg.Icons.TextIndent,
            onmousedown: function () {
                document.execCommand("indent", false, null);
                this.Near("Editor").focus();
            }
        },
        Outdent: {
            innerHTML: Svg.Icons.TextOutdent,
            onmousedown: function () {
                document.execCommand("outdent", false, null);
                this.Near("Editor").focus();
            }
        },
        Paragraph: {
            title: "Paragraph",
            innerHTML: Svg.Icons.TextParagraph,
            onmousedown: function () {
                document.execCommand("formatBlock", false, "p");
                this.Near("Editor").focus();
            }
        },
        Header1: {
            title: "Header 1",
            innerHTML: Svg.Icons.TextHeader1,
            onmousedown: function () {
                document.execCommand("formatBlock", false, "h1");
                this.Near("Editor").focus();
            }
        },
        Header2: {
            title: "Header 2",
            innerHTML: Svg.Icons.TextHeader2,
            onmousedown: function () {
                document.execCommand("formatBlock", false, "h2");
                this.Near("Editor").focus();
            }
        },
        Header3: {
            title: "Header 3",
            innerHTML: Svg.Icons.TextHeader3,
            onmousedown: function () {
                document.execCommand("formatBlock", false, "h3");
                this.Near("Editor").focus();
            }
        },
        CodeBlock: {
            title: "Code block",
            innerHTML: Svg.Icons.TextCodeBlock,
            onmousedown: function () {
                document.execCommand("formatBlock", false, "pre");
                this.Near("Editor").focus();
            }
        },
        QuoteBlock: {
            title: "Quote block",
            innerHTML: Svg.Icons.TextQuoteBlock,
            onmousedown: function () {
                document.execCommand("formatBlock", false, "blockquote");
                
            }
        }
    },
    Data: null,
    Init: function () {
        if (this.Data)
            this.Elements.Editor.innerHTML = this.RemoveScripts ? this.RemoveScriptsHandler(this.Data) : this.Data;
        if (this.FillContainer) {
            this.style.position = "absolute";
            this.style.top = "0px";
            this.style.left = "0px";
            this.style.right = "0px";
            this.style.bottom = "0px";

            this.Elements.MenuBar.style.position = "absolute";
            this.Elements.MenuBar.style.top = "0px";
            this.Elements.MenuBar.style.left = "0px";
            this.Elements.MenuBar.style.right = "0px";
            this.Elements.MenuBar.style.height = "35px";

            this.Elements.Editor.style.position = "absolute";
            this.Elements.Editor.style.top = "35px";
            this.Elements.Editor.style.left = "0px";
            this.Elements.Editor.style.right = "0px";
            this.Elements.Editor.style.bottom = "0px";
        }
    },
    GetValue: function () {
        return this.Elements.Editor.innerHTML.replace(/<b>/g, "<strong>").replace(/<\/b>/g, "</strong>").replace(/<i>/g, "<em>").replace(/<\/i>/g, "</em>");
    },
    Elements: {
        MenuBar: {
            CurSize: 3,
            Init: function () {
                for (var i = 0; i < this.Parent.Buttons.length;i++) {
                    if (this.Parent.ButtonTemplates[this.Parent.Buttons[i]])
                        this.Add({
                            _: this.Parent.ButtonTemplates[this.Parent.Buttons[i]],
                            onmouseup: function () {
                                this.Near("Editor").focus();
                            }
                        });
                }                
            },
            onselectstart: function () { return false; }
        },
        Editor: {
            contentEditable: true,
            onclick: function () {
                this.Near("MenuBar").CurSize = 3; // TODO: Handle this a lot better.. but at least this works in Chrome
            },
            onpaste: function (e) {
                if (e.clipboardData) {
                    e.preventDefault();
                    if (this.Parent.EnableHTMLPasting && e.clipboardData.types && e.clipboardData.types.indexOf("text/html") >= 0) {
                        try {
                            var html = e.clipboardData.getData("text/html");
                            document.execCommand("insertHTML", false, this.Parent.RemoveScripts ? this.Parent.RemoveScriptsHandler(html) : html);
                            return;
                        } catch (errie) { } // If insertHTML is not supported for any reason, we will still paste it as text                        
                    }

                    var text = e.clipboardData.getData("text");
                    document.execCommand("insertText", false, text);                    
                }
            },
            onkeydown: function (e) {
                if (e.keyCode === 13 && !e.shiftKey) {
                    this.RemoveFormat = true;
                }
            },
            onkeyup: function (e) {
                if (this.RemoveFormat) {
                    document.execCommand("formatBlock", false, "div");
                    this.RemoveFormat = null;
                }
            }
        }
    }
};

if (window.TK.Form) {
    window.TK.Form.DefaultTemplates.html = {
        _: TK.HtmlEditor
    };
}
"use strict";
/* Minify Skip */
/* Minify Order(150) */

TK.Draw = {
    _: "canvas",
    Width: 100,
    Height: 100,
    Scale: 2, // Rendering scale, increase to keep sharpness when zooming in on the page but decrease performance
    Zoom: 1,
    ViewPortX: 0,
    ViewPortY: 0,
    EnableNavigation: false, // If true, the canvas can be dragged around and zoomed in/out using mouse wheel
    EnableZoom: false,
    MinZoom: 0.2,
    MaxZoom: 10,
    Animations: [],
    Init: function () {
        this.Context = this.GetContext();
        this.Context.CanvasObj = this;
        this.SetSize(this.Width, this.Height);      
    },
    SetSize: function (width, height, parsePositionTags) {
        this.Width = width;
        this.Height = height;
        this.width = width * this.Scale;
        this.height = height * this.Scale;
        this.style.width = width + "px";
        this.style.height = height + "px";
        if (parsePositionTags && this.SortedElements) {
            for (var i = 0; i < this.SortedElements.length; i++) {
                if (this.SortedElements[i]._NormalizePositions !== false)
                    TK.Draw.SetPositionsUsingPositionProperty(this.SortedElements[i]);
                if (this.SortedElements[i].Resize)
                    this.SortedElements[i].Resize();
            }
        }
        this.Refresh();
    },
    GetContext: function () {
        return this.getContext("2d");
    },
    Refresh: function (skipSortElements) {
        if (this.RefreshAlreadyQueued) {
            if (!skipSortElements)
                this.ForceSortElements = true;
            return;
        }
        if (this.width != this.Width * this.Scale || this.height != this.Height * this.Scale) {
            this.width = this.Width;
            this.height = this.Height;
        }
        var obj = this;
        
        var hasAnimation = this.ProcessAnimations();

        // TODO: If EnableNavigation is true, Draw on an offscreen canvas
        // TODO: Find a way to only redraw whats needed

        this.Context.setTransform(this.Scale, 0, 0, this.Scale , 0, 0);
        this.Context.clearRect(0, 0, this.Width, this.Height);        

        if (!skipSortElements || !this.SortedElements || this.ForceSortElements) {
            this.SortElements();
        }

        for (var i = 0; i < this.SortedElements.length; i++) {
            this.Context.OffsetX = -this.ViewPortX;
            this.Context.OffsetY = -this.ViewPortY;
            this.Context.Scale = this.Scale * this.Zoom;
            if (this.SortedElements[i].Draw)
                this.SortedElements[i].Draw(this.Context);
        }

        if (hasAnimation) {
            this.RefreshAlreadyQueued = true;
            requestAnimationFrame(function () { obj.RefreshAlreadyQueued = false; obj.Refresh(true); });
        }
    },
    ProcessAnimations: function () {
        // Process animations
        var cur = new Date().getTime();
        var hasAnimation = false;
        for (var i = 0; i < this.Animations.length; i++) {
            if (!this.Animations[i])
                continue;
            var a = this.Animations[i];
            var r = (cur - a.S) / a.L; // 500 - 400 = 100 / 400 = 0.25

            if (r >= 1) {
                r = 1;
                this.Animations[i] = null;
                if (a.I.AnimationEnded)
                    a.I.AnimationEnded(a.P);
                if (a.AnimationEnded)
                    a.AnimationEnded(a.P);
                
            }
            if (Array.isArray(a.O)) {
                var rgba = [0, 0, 0, 0];
                for (var j = 0; j < a.O.length; j++) {
                    if (Array.isArray(a.O[j])) {
                        // Point array                        
                        for (var n = 0; n < a.O[j].length; n++) {
                            a.I[a.P][j][n] = a.E(a.O[j][n], a.T[j][n], r);

                        }
                    } else if (a.O.length == 4) {
                        // Colors
                        rgba[j] = a.E(a.O[j], a.T[j], r);
                    }
                }
                if (a.O.length == 4) {
                    a.I[a.P] = "rgba(" + rgba.join(",") + ")";
                }
            } else {
                a.I[a.P] = a.E(a.O, a.T, r);
            }
            //a.I[a.P] = a.O + ((a.T - a.O) * r);            
            hasAnimation = true;
            if (a.I.Invalidate) {
                a.I.Invalidate();
            }
        }
        return hasAnimation;
    },
    SortElements: function () {
        this.ForceSortElements = false;
        this.SortedElements = [];
        for (var ele in this.Elements) {
            if (this.Elements[ele].Draw) {
                this.SortedElements.push(this.Elements[ele]);
            }
        }
        this.SortedElements = this.SortedElements.OrderBy(function (a) {
            return a.ZIndex;
        });           
    },
    onclick: function (e) {
        this.HandleMouseEvent(e, "Click");
    },
    onmousemove: function (e) {
        this.HandleMouseEvent(e, "MouseOver"); 
        this.HandleMouseEvent(e, "MouseMove");
        this.HandleMouseEvent(e, "MouseOut");
    },
    ontouchmove: function (e) {
        this.HandleMouseEvent(e, "MouseOver");
        this.HandleMouseEvent(e, "MouseMove");
        this.HandleMouseEvent(e, "MouseOut");
        e.preventDefault();
    },
    onmouseout: function (e) {
        this.HandleMouseEvent(e, "MouseOut");
    },
    onmousedown: function (e) {
        this.HandleMouseEvent(e, "MouseDown");
    },
    ontouchstart: function (e) {
        this.HandleMouseEvent(e, "MouseDown");
        e.preventDefault();
    },
    onmouseup: function (e) {
        this.HandleMouseEvent(e, "MouseUp");
    },
    ontouchend: function (e) {
        this.HandleMouseEvent(e, "MouseUp");
        e.preventDefault();
    },
    /*onpointerdown: function (e) {
        this.HandleMouseEvent(e, "MouseDown");
    },
    onpointermove: function (e) {
        this.HandleMouseEvent(e, "MouseOver");
        this.HandleMouseEvent(e, "MouseMove");
        this.HandleMouseEvent(e, "MouseOut");
    },
    onpointerup: function (e) {
        this.HandleMouseEvent(e, "MouseUp");
    },*/
    onwheel: function (event) {
        if (this.EnableZoom) {
            if (!event)
                event = window.event;
            if (event.preventDefault)
                event.preventDefault();            
            var zoomInPos = [this.ViewPortX + (this.Width / 2 / this.Zoom), this.ViewPortY + (this.Height / 2 / this.Zoom)];
            
            this.Zoom -= event.deltaY < 0 ? -0.25 : 0.25;
            if (this.Zoom < this.MinZoom)
                this.Zoom = this.MinZoom;
            else if (this.Zoom > this.MaxZoom)
                this.Zoom = this.MaxZoom;
            
            // Adjust viewport as we want to zoom in with zoomInPos as center
            this.Center(zoomInPos[0], zoomInPos[1]);
            this.Refresh(true);
        }
    },
    Center: function (x, y, animateLength, animateEase) { // world space px
        // Adjust ViewPortX and ViewPortY so that the x and y positions are in the middle
        x = x - ((this.Width / 2) / this.Zoom); // world space px
        y = y - ((this.Height / 2) / this.Zoom);        
        if (animateLength) {
            this.Animations.push({ I: this, P: "ViewPortX", O: this.ViewPortX, T: x, L: animateLength, E: animateEase ? animateEase : TK.Draw.EaseExponential, S: new Date().getTime() });
            this.Animations.push({ I: this, P: "ViewPortY", O: this.ViewPortY, T: y, L: animateLength, E: animateEase ? animateEase : TK.Draw.EaseExponential, S: new Date().getTime() });
            this.Refresh();
        } else {
            this.ViewPortX = x;
            this.ViewPortY = y;
        }
    },
    HandleMouseEvent: function (e, func) {
        var eventHandled = false;
        var x, y;
        try { x = e.clientX; y = e.clientY; } catch (errie) { var e2 = window.event; x = e2.clientX; y = e2.clientY; }

        if (e && e.changedTouches && e.changedTouches.length > 0) {
            x = e.changedTouches[0].clientX;
            y = e.changedTouches[0].clientY;
        }
        
        var rect = this.getBoundingClientRect();        
        // Make sure top/left is always 0,0, then Compensate for the zoom level, then Add the offset from the viewport
        x = ((x - rect.left) / this.Zoom) + this.ViewPortX;
        y = ((y - rect.top) / this.Zoom) + this.ViewPortY;
        var stoppedPropagation = false;

        if (!this.SortedElements || this.ForceSortElements) {
            this.SortElements();
        }

        for (var i = this.SortedElements.length - 1; i >= 0; i--) {
            var el = this.SortedElements[i];
            if (!el[func] || !el.GetRect)
                continue;
            var r = el.GetRect();
            if (r === null)
                continue;
            //r[0] -= this.ViewPortX;
            //r[1] -= this.ViewPortY;
            var match = false;
            for (var j = 0; this.CurrentMouseDownElements && j < this.CurrentMouseDownElements.length; j++) {
                if (this.CurrentMouseDownElements[j] == el) {
                    match = true;
                    break;
                }
            }
            if (match || (r[0] < x && r[0] + r[2] > x && r[1] < y && r[1] + r[3] > y && (!el.CheckMouseOver || el.CheckMouseOver(x, y))) && !stoppedPropagation) {          

                if (func == "MouseDown" && this.CurrentMouseDownElements && this.CurrentMouseDownElements.indexOf(el) >= 0) {
                    el.CurrentlyMouseOver = true;
                    eventHandled = true;
                    continue;
                }

                if (func != "MouseOut" && (func != "MouseOver" || !el.CurrentlyMouseOver)) {            
                    if (el[func](x, y) === true) {
                        stoppedPropagation = true;
                        el.StoppedPropagation = true;
                    }
                    eventHandled = true;
                }
                if (el.CurrentlyMouseOver && el.StoppedPropagation) {
                    stoppedPropagation = true;
                }
                if (func == "MouseDown") {
                    if (!this.CurrentMouseDownElements)
                        this.CurrentMouseDownElements = [];
                    this.CurrentMouseDownElements.push(el);
                }

                el.CurrentlyMouseOver = true;
            } else if (func == "MouseOut" && el.CurrentlyMouseOver) {
                el[func](x, y);
                eventHandled = true;
                el.CurrentlyMouseOver = false;
                el.StoppedPropagation = false;
            }
        }

        
        if (func == "MouseUp" && this.CurrentMouseDownElements) {
            this.CurrentMouseDownElements = null;
        }

        x = (x - this.ViewPortX) * this.Zoom;
        y = (y - this.ViewPortY) * this.Zoom;
        if (this.CurrentCanvasInteraction) {
            if (func == "MouseMove") {
                this.ViewPortX = this.CurrentCanvasInteraction[2] + ((this.CurrentCanvasInteraction[0] - x) / this.Zoom);
                this.ViewPortY = this.CurrentCanvasInteraction[3] + ((this.CurrentCanvasInteraction[1] - y) / this.Zoom);
            } else if (func == "MouseUp") {
                this.CurrentCanvasInteraction = null;
            }
        } else if (!eventHandled && !this.CurrentMouseDownElements && this.EnableNavigation && func == "MouseDown") {
            // Interaction on the canvas itself
            this.CurrentCanvasInteraction = [x, y, this.ViewPortX, this.ViewPortY];
        }
        this.Refresh();
    }
};
TK.Draw.AnimationsEnabled = true;
TK.Draw.AnchorLeft = 1;
TK.Draw.AnchorCenter = 2;
TK.Draw.AnchorRight = 4;
TK.Draw.AnchorTop = 8;
TK.Draw.AnchorMiddle = 16;
TK.Draw.AnchorBottom = 32;

TK.Draw.SmoothNone = 0;
TK.Draw.SmoothQuadratic = 1; // Quadratic curvers with the center in between the two points
TK.Draw.SmoothCorners = 2; // Only use horizontal and vertical lines, or small 90 degree corners

TK.Draw.DirectionTop = 0;
TK.Draw.DirectionRight = 1;
TK.Draw.DirectionBottom = 2;
TK.Draw.DirectionLeft = 3;

TK.Draw.EaseLinear = function (a, b, r) { return a + ((b - a) * r); };
TK.Draw.EaseExponential = function (a, b, r) {
    var m;
    if (r < 0.5) {
        m = ((r == 0) ? 0 : Math.pow(2, 10 * (r * 2 - 1)) - 0.001) * 0.5;
    } else {
        r = (r * 2) - 1;
        m = (r == 1) ? 1 : (-Math.pow(2, -10 * r) + 1);
        m = 0.5 + 0.5 * m;
    }
    return a + ((b - a) * m);
};
TK.Draw.EaseBack = function (a, b, r) {
    return a + ((b - a) * (r * r * ((2.70158) * r - 1.70158)));
};
TK.Draw.EaseCircular = function(a, b, r) {
    return a + ((b - a) * -(Math.sqrt(1 - r * r) - 1.0));
};
TK.Draw.EaseBounce = function (a, b, r) {
    var multiplier = 1;
    if (r < (1 / 2.75)) {
        multiplier = 7.5625 * r * r;
    } else if (r < (2 / 2.75)) {
        var t = r - (1.5 / 2.75);
        multiplier = 7.5625 * t * t + 0.75;
    } else if (r < (2.5 / 2.75)) {
        var t = r - (2.25 / 2.75);
        multiplier = 7.5625 * t * t + 0.9375;
    } else {
        var t = r - (2.625 / 2.75);
        multiplier = 7.5625 * t * t + 0.984375;
    }
    return a + ((b - a) * multiplier);
};
TK.Draw.EaseCubic = function (a, b, r) {
    return a + ((b - a) * (r * r * r));
};
TK.Draw.EaseElastic = function (a, b, r) {                  
    return a + ((b - a) * (1 + Math.pow(2, -10 * r) * Math.sin((r - (0.3 / 4)) * (Math.PI * 2) / 0.3)));
};
TK.Draw.EaseSine = function (a, b, r) {
    return a + ((b - a) * (-Math.cos(r * (Math.PI / 2)) + 1));
};
TK.Draw.EaseStrong = function (a, b, r) {
    return a + ((b - a) * (r * r * r * r * r));
};

TK.Draw.GetColor = function (s) {
    if (s.substr(0, 4) == "rgba") {
        return s.replace("rgba(", "").replace(")", "").split(",").Select(function (a) { return parseFloat(a); });
    } else if (s.substr(0, 3) == "rgb") {
        return (s.replace("rgb(", "").replace(")", "") + ",1").split(",").Select(function (a) { return parseFloat(a); });
    } else if (s.substr(0, 1) == "#") {
        var c = s.substring(1).split('');
        if (c.length == 3)
            c = [c[0], c[0], c[1], c[1], c[2], c[2]];
        c = '0x' + c.join('');
        return [(c >> 16) & 255, (c >> 8) & 255, c & 255, 1];
    }
};
TK.Draw.ColorToDifferentColor = function (s, s2, ratio) {
    s = TK.Draw.GetColor(s);
    s2 = TK.Draw.GetColor(s2);
    if (s.length < 4)
        s.push(1);
    if (s2.length < 4)
        s2.push(1);
    for (var i = 0; i < 4; i++) {
        s[i] = TK.Draw.EaseLinear(s[i], s2[i], ratio);
    }
    return "rgba(" + s.join(",") + ")";
};
TK.Draw.ValueToPx = function (v, curIsWidth, totalWidth, totalHeight) {
    if (!v.substr)
        return v;
    var total = curIsWidth ? totalWidth : totalHeight;

    if (v.indexOf("px") >= 0)
        return parseFloat(v.replace("px", ""));
    if (v.indexOf("%") >= 0)
        return total * (parseFloat(v.replace("%", "")) / 100);
    if (v.indexOf("vw") >= 0)
        return totalWidth * (parseFloat(v.replace("%", "")) / 100);
    if (v.indexOf("vh") >= 0)
        return totalHeight * (parseFloat(v.replace("%", "")) / 100);
    return parseFloat(v);
};
TK.Draw.SetPositionsUsingPositionProperty = function (drawableObject) {
    var t = drawableObject;
    if (!t._Position)
        return;
    var p = t.Parent;
    while (p !== undefined && p.ProcessAnimations === undefined) // find the TK.Draw component
        p = p.Parent;
    if (!p)
        return;

    var anchorV = TK.Draw.AnchorTop | TK.Draw.AnchorMiddle | TK.Draw.AnchorBottom;
    var anchorH = TK.Draw.AnchorLeft | TK.Draw.AnchorCenter | TK.Draw.AnchorRight;

    var p = window.TK.ParsePosition(t._Position);
    var totalWidth = t.Parent.Width;
    var totalHeight = t.Parent.Height;
    var isSet = function (v) {
        return !(v === undefined || v === null);
    };

    if (isSet(p[0]) && isSet(p[2])) {
        t.Y = TK.Draw.ValueToPx(p[0], false, totalWidth, totalHeight); // 50% -> 150px
        t.H = (totalHeight - TK.Draw.ValueToPx(p[2], false, totalWidth, totalHeight)) - t.Y; // 25% ->   (300 - 75) = 225 - 150 = 75
        t.Anchor = (t.Anchor & anchorH) | TK.Draw.AnchorTop;
    } else if (isSet(p[0])) {
        t.Y = TK.Draw.ValueToPx(p[0], false, totalWidth, totalHeight);
        t.Anchor = (t.Anchor & anchorH) | TK.Draw.AnchorTop;
    } else if (isSet(p[2])) {
        t.Y = totalHeight - TK.Draw.ValueToPx(p[2], false, totalWidth, totalHeight);
        t.Anchor = (t.Anchor & anchorH) | TK.Draw.AnchorBottom;
    }

    if (isSet(p[1]) && isSet(p[3])) {
        t.X = TK.Draw.ValueToPx(p[3], true, totalWidth, totalHeight);
        t.W = (totalWidth - TK.Draw.ValueToPx(p[1], true, totalWidth, totalHeight)) - t.X;
        t.Anchor = (t.Anchor & anchorV) | TK.Draw.AnchorLeft;
    } else if (isSet(p[1])) {
        t.X = totalWidth - TK.Draw.ValueToPx(p[1], true, totalWidth, totalHeight);
        t.Anchor = (t.Anchor & anchorV) | TK.Draw.AnchorRight;
    } else if (isSet(p[3])) {
        t.X = TK.Draw.ValueToPx(p[3], true, totalWidth, totalHeight);
        t.Anchor = (t.Anchor & anchorV) | TK.Draw.AnchorLeft;
    }

    if (isSet(p[4]))
        t.W = TK.Draw.ValueToPx(p[4], true, totalWidth, totalHeight);
    if (isSet(p[5]))
        t.H = TK.Draw.ValueToPx(p[5], false, totalWidth, totalHeight);

    if (isSet(p[6])) {
        if (p[6].indexOf("middle") >= 0)
            t.Anchor = (t.Anchor & anchorH) | TK.Draw.AnchorMiddle;
        if (p[6].indexOf("top") >= 0)
            t.Anchor = (t.Anchor & anchorH) | TK.Draw.AnchorTop;
        if (p[6].indexOf("bottom") >= 0)
            t.Anchor = (t.Anchor & anchorH) | TK.Draw.AnchorBottom;
        if (p[6].indexOf("left") >= 0)
            t.Anchor = (t.Anchor & anchorV) | TK.Draw.AnchorLeft;
        if (p[6].indexOf("center") >= 0)
            t.Anchor = (t.Anchor & anchorV) | TK.Draw.AnchorCenter;
        if (p[6].indexOf("right") >= 0)
            t.Anchor = (t.Anchor & anchorV) | TK.Draw.AnchorRight;
    }
};
// Draws all child elements
TK.Draw.Group = {
    DrawType: "Group",
    X: 0,
    Y: 0,

    // Optional, set these so all child elements can use anchor top/left, while the full group respects it's own anchor setting
    // This is useful to make self-contained drawable components, and required when wanting to use the _Positions tag
    _NormalizePositions: false,
    Anchor: null,
    W: null, H: null,
    Init: function () {
        if (this._NormalizePositions)
            TK.Draw.SetPositionsUsingPositionProperty(this);
    },
    Draw: function (c) {
        var x = 0;
        var y = 0;

        if (this._NormalizePositions && this.Anchor !== null && this.W && this.H) {
            if ((this.Anchor & TK.Draw.AnchorCenter) > 0) {
                x = -(this.W * 0.5);
            } else if ((this.Anchor & TK.Draw.AnchorRight) > 0) {
                x = -this.W;
            }

            if ((this.Anchor & TK.Draw.AnchorMiddle) > 0) {
                y = -(this.H * 0.5);
            } else if ((this.Anchor & TK.Draw.AnchorBottom) > 0) {
                y = -this.H;
            }        
        }

        c.OffsetX += this.X + x;
        c.OffsetY += this.Y + y;
        for (var i in this.Elements) {
            if (this.Elements[i].Draw)
                this.Elements[i].Draw(c);
        }
        c.OffsetX -= this.X + x;
        c.OffsetY -= this.Y + y;
    },
    GetRect: function () {
        return this._NormalizePositions ? TK.Draw.DrawableObject.GetRect.apply(this) : null;
    },
    Overlaps: function (otherDrawableObject) {
        return this._NormalizePositions ? TK.Draw.DrawableObject.Overlaps.apply(this, [otherDrawableObject]) : null;
    },
    Animate: function (propName, targetValue, ms, easing) {
        return TK.Draw.DrawableObject.Animate.apply(this, [propName, targetValue, ms, easing]);
    }
};
TK.Draw.DrawableObject = {
    DrawType: "DrawableObject",
    Fill: null, // Color
    Stroke: null, // Color
    BlendMode: null, // Any value of globalCompositeOperation
    LineWidth: 1,
    LineCap: null,
    Rotate: null,
    Shadow: null, // [X, Y, Size, Color]
    ShadowForLine: false,
    Anchor: TK.Draw.AnchorLeft | TK.Draw.AnchorTop,
    ZIndex: 1,
    X: 0, Y: 0, W: 0, H: 0,
    _Position: null, // Alternative way of setting positions, similar to the normal toolkit method, but with added anchor support
    Opacity: 1,
    Init: function () {
        TK.Draw.SetPositionsUsingPositionProperty(this);
    },
    
    Transform: function (c) {
        if (this.DrawAndTransformDisabled) {
            c.setTransform(c.Scale, 0, 0, c.Scale, c.OffsetX * c.Scale, c.OffsetY * c.Scale);
            return;
        }
        var x = 0;
        var y = 0;        

        if ((this.Anchor & TK.Draw.AnchorCenter) > 0) {
            x = -(this.W * 0.5);
        } else if ((this.Anchor & TK.Draw.AnchorRight) > 0) {
            x = -this.W;
        }

        if ((this.Anchor & TK.Draw.AnchorMiddle) > 0) {
            y = -(this.H * 0.5);
        } else if ((this.Anchor & TK.Draw.AnchorBottom) > 0) {
            y = -this.H;
        }        

        c.SetOffsetX = (c.OffsetX + x);
        c.SetOffsetY = (c.OffsetY + y);

        c.setTransform(c.Scale, 0, 0, c.Scale, (c.OffsetX + x) * c.Scale, (c.OffsetY + y) * c.Scale);        

        if (this.Rotate) {
            var translateX = this.X - x;
            var translateY = this.Y - y;
            
            c.translate(translateX, translateY);            
            //c.ellipse(0, 0, 35, 35, 0, 0, (2 * Math.PI));
            
            c.rotate(this.Rotate * Math.PI / 180);
            c.translate(-translateX, -translateY);
        }
    },
    DrawFS: function (c) {
        if (this.BlendMode) {
            c.globalCompositeOperation = this.BlendMode;
        }
        if (this.Shadow) {
            c.shadowOffsetX = this.Shadow[0];
            c.shadowOffsetY = this.Shadow[1];
            c.shadowBlur = this.Shadow[2];
            c.shadowColor = this.Shadow[3];
        } else {
            c.shadowColor = "rgba(0,0,0,0)";
            c.shadowBlur = 0;
        }

        c.globalAlpha = this.Opacity;

        if (this.Fill) {
            if (this.Fill.length > 7 && (this.Fill.substr(0, 7) == "radial " || this.Fill.substr(0, 7) == "linear ")) {
                // Support for gradients
                if (this._CachedFillStyleKey != this.Fill) {
                    this._CachedFillStyleKey = this.Fill;
                    var parts = this.Fill.split(/ /g);
                    var g = null;
                    var stopOffset = 5;

                    // TODO: Make sure positions and percentages are relative from the current drawableObject

                    if (parts[0] == "radial") {
                        g = c.createRadialGradient(
                            (this.X + TK.Draw.ValueToPx(parts[1], true, this.W, this.H)) /*- c.OffsetX*/, // inner circle X
                            (this.Y + TK.Draw.ValueToPx(parts[2], false, this.W, this.H)) /*- c.OffsetY*/, // inner circle Y
                            TK.Draw.ValueToPx(parts[3], true, this.W, this.H), // inner circle Radius
                            (this.X + TK.Draw.ValueToPx(parts[4], true, this.W, this.H)) /*- c.OffsetX*/, // outer circle X
                            (this.Y + TK.Draw.ValueToPx(parts[5], false, this.W, this.H)) /*- c.OffsetY*/, // outer circle Y
                            TK.Draw.ValueToPx(parts[6], true, this.W, this.H)); // outer circle Radius
                        stopOffset = 7;
                    } else {
                        g = c.createLinearGradient(
                            (this.X + TK.Draw.ValueToPx(parts[1], true, this.W, this.H)) /*- c.OffsetX*/, // Start gradient X
                            (this.Y + TK.Draw.ValueToPx(parts[2], false, this.W, this.H)) /*- c.OffsetY*/, // Start gradient Y
                            (this.X + TK.Draw.ValueToPx(parts[3], true, this.W, this.H)) /*- c.OffsetX*/, // End gradient X
                            (this.Y + TK.Draw.ValueToPx(parts[4], false, this.W, this.H)) /*- c.OffsetY*/); // End gradient Y
                    }
                    for (var i = stopOffset; i + 1 < parts.length; i += 2) {
                        g.addColorStop(parseFloat(parts[i]), parts[i + 1]);
                    }
                    this._CachedFillStyle = g;
                }
                c.fillStyle = this._CachedFillStyle;
            } else {
                c.fillStyle = this.Fill;
            }
            if (!this.DrawAndTransformDisabled)
                c.fill();
        }
        if (this.LineCap) {
            c.lineCap = this.LineCap;
        }

        if (!this.ShadowForLine) {
            c.shadowColor = "rgba(0,0,0,0)";
            c.shadowBlur = 0;
        }        

        c.lineWidth = this.LineWidth;
        if (this.Stroke) {
            c.strokeStyle = this.Stroke;
            if (!this.DrawAndTransformDisabled)
                c.stroke();
        }

        c.globalAlpha = 1;
        if (this.BlendMode) {
            c.globalCompositeOperation = "source-over"; // default
        }
    },
    Animate: function (propName, targetValue, ms, easing) {
        if (!easing)
            easing = TK.Draw.EaseLinear;
        var p = this.Parent;
        while (p !== undefined && p.ProcessAnimations === undefined) // find the TK.Draw component
            p = p.Parent;
        if (!TK.Draw.AnimationsEnabled) {
            this[propName] = targetValue;
            if (this.AnimationEnded)
                this.AnimationEnded();
            if (p)
                p.Refresh();
            return this;
        }

        if (p) {
            var s = new Date().getTime();
            if (p.Animations.length > 100) // Clear all deleted animations from the array
                p.Animations = p.Animations.Where(function (a) { return a; });

            var animObj = null;
            for (var i = 0; i < p.Animations.length; i++) {
                if (p.Animations[i] && p.Animations[i].I == this && p.Animations[i].P == propName) {
                    animObj = p.Animations[i];
                    break;
                }
            }
            if (animObj == null) {
                animObj = {
                    I: this,
                    P: propName,
                };
                p.Animations.push(animObj);
            }
            animObj.L = ms; // Total animation length
            animObj.E = easing; 
            animObj.S = s; // Start time

            if (typeof this[propName] === 'string' && typeof targetValue === 'string') {
                // Colors                      
                animObj.O = TK.Draw.GetColor(this[propName]);
                animObj.T = TK.Draw.GetColor(targetValue);

                //p.Animations.push({ I: this, P: propName, O: TK.Draw.GetColor(this[propName]), T: TK.Draw.GetColor(targetValue), L: ms, E: easing, S: s });
            } else if (Array.isArray(this[propName])) {
                animObj.O = JSON.parse(JSON.stringify(this[propName]));
                animObj.T = targetValue;
                //p.Animations.push({ I: this, P: propName, O: JSON.parse(JSON.stringify(this[propName])), T: targetValue, L: ms, E: easing, S: s });                
            } else {
                animObj.O = parseFloat(this[propName]);
                animObj.T = targetValue;
                //p.Animations.push({ I: this, P: propName, O: parseFloat(this[propName]), T: targetValue, L: ms, E: easing, S: s });                
            }
            p.Refresh();
        }
        return this;
    },
    GetRect: function () {
        var x = this.X;
        var y = this.Y;
        
        if ((this.Anchor & TK.Draw.AnchorCenter) > 0) {
            x -= this.W * 0.5;
        } else if ((this.Anchor & TK.Draw.AnchorRight) > 0) {
            x -= this.W;
        }

        if ((this.Anchor & TK.Draw.AnchorMiddle) > 0) {
            y -= this.H * 0.5;
        } else if ((this.Anchor & TK.Draw.AnchorBottom) > 0) {
            y -= this.H;
        }

        return [x, y, this.W, this.H];
    },
    Overlaps: function (otherDrawableObject) {
        var rectA = this.GetRect();
        var rectB = otherDrawableObject.GetRect();
        
        return (rectA[0] < (rectB[0] + rectB[2]) && (rectA[0] + rectA[2]) > rectB[0] && rectA[1] < (rectB[1] + rectB[3]) && (rectA[1] + rectA[3]) > rectB[1]);
    },
    Invalidate: function () {
        // Called whenever a property is changed
    }
};
"use strict";
/* Minify Skip */
/* Minify Order(155) */

TK.Draw.Circle = {
    DrawType: "Circle",
    _: TK.Draw.DrawableObject,
    Angle: 0, Size: null, DonutSize: null, Extrude: 0,
    Draw: function (c) {
        c.beginPath();
        this.Transform(c);

        if (this.Size || this.DonutSize) {

            // Complicated (slower) method for partial circles
            var outerRadius = this.W * 0.5;
            var innerRadius = outerRadius * this.DonutSize;

            var centerPosX = this.X + this.W * 0.5;
            var centerPosY = this.Y + this.H * 0.5;


            if (this.Extrude) {
                var extrudeAngle = (this.Angle + (this.Size * 0.5)) * Math.PI / 180;
                centerPosX += Math.cos(extrudeAngle) * this.Extrude;
                centerPosY += Math.sin(extrudeAngle) * this.Extrude;
            }

            var th1 = this.Angle * Math.PI / 180; // 0 = begin angle
            var th2 = (this.Size + this.Angle) * Math.PI / 180; // 45 = end angle
            var startOfOuterArcX = outerRadius * Math.cos(th2) + centerPosX;
            var startOfOuterArcY = outerRadius * Math.sin(th2) + centerPosY;


            c.arc(centerPosX, centerPosY, innerRadius, th1, th2, false);
            c.lineTo(startOfOuterArcX, startOfOuterArcY);
            c.arc(centerPosX, centerPosY, outerRadius, th2, th1, true);
        } else {
            // Simple (faster) method for simple circles
            c.ellipse(this.X + this.W * 0.5, this.Y + this.H * 0.5, this.W * 0.5, this.H * 0.5, 0, 0, (2 * Math.PI));
        }
        this.DrawFS(c);
        c.closePath();
    },
    CheckMouseOver: function (x, y) {
        var cx = (this.Anchor & TK.Draw.AnchorLeft) ? this.X + (this.W / 2) : (this.Anchor & TK.Draw.AnchorRight) ? this.X - (this.W / 2) : this.X;
        var cy = (this.Anchor & TK.Draw.AnchorTop) ? this.Y + (this.H / 2) : (this.Anchor & TK.Draw.AnchorBottom) ? this.Y - (this.H / 2) : this.Y;
        if (this.Extrude) {
            var extrudeAngle = (this.Angle + (this.Size * 0.5)) * Math.PI / 180;
            cx += Math.cos(extrudeAngle) * this.Extrude;
            cy += Math.sin(extrudeAngle) * this.Extrude;
        }
        if (this.Size && this.Size < 360) {
            var deg = Math.atan2(y - cy, x - cx) * 180.0 / Math.PI;
            if (deg < 0)
                deg = 360 + deg; // Turn into a value between 0 and 360

            var checkFrom = this.Angle % 360;
            if (checkFrom < 0)
                checkFrom = 360 + checkFrom; // Start is also in a value between 0 and 360
            var checkTo = (checkFrom + this.Size) % 360;

            if (deg < checkFrom && (checkTo > checkFrom || deg > checkTo))
                return false;
            if (deg > checkTo && (checkFrom < checkTo || deg < checkTo))
                return false;

        }
        var dist = Math.sqrt(Math.pow(x - cx, 2) + Math.pow(y - cy, 2));
        if (this.DonutSize && dist <= (this.W / 2) * this.DonutSize)
            return false;
        return (dist <= this.W / 2);
    }
};
"use strict";
/* Minify Skip */
/* Minify Order(155) */

TK.Draw.Image = {
    DrawType: "Image",
    _: TK.Draw.DrawableObject,
    //RoundCorners: [15,15,15,15],
    Img: null,
    Src: null,
    Scaling: 0, // 0 Scretch to fit, 1 Contain, 2 Cover
    ImageAlign: TK.Draw.AnchorCenter | TK.Draw.AnchorMiddle,
    Draw: function (c) {
        var obj = this;
        if (!this.Img && this.Src) {
            this.Img = new Image();
            this.Img.onload = function () {
                // Refresh draw
                c.CanvasObj.Refresh();
            };
            this.Img.src = this.Src;
            return;
        }
        if (!this.Img)
            return;

        c.beginPath();
        this.Transform(c);
        this.DrawFS(c);
        try {
            c.globalAlpha = this.Opacity;
            var drawX = this.X;
            var drawY = this.Y;
            var drawWidth = this.W;
            var drawHeight = this.H;
            var sourceX = 0;
            var sourceY = 0;
            var sourceWidth = this.Img.width;
            var sourceHeight = this.Img.height;
            if (this.Scaling == 1) {
                // Get the aspect ratios  
                var imgAspectRatio = this.Img.width / this.Img.height;
                var boxAspectRatio = this.W / this.H;

                if (imgAspectRatio > boxAspectRatio) {
                    // Image is wider relative to the box  
                    drawWidth = this.W;
                    drawHeight = this.W / imgAspectRatio;


                    if ((this.ImageAlign & TK.Draw.AnchorMiddle) != 0)
                        drawY = this.Y + (this.H - drawWidth) / 2;
                    else if ((this.ImageAlign & TK.Draw.AnchorBottom) != 0)
                        drawY = this.Y + (this.H - drawWidth);
                } else {
                    // Image is taller (or same aspect ratio) relative to the box  
                    drawHeight = this.H;
                    drawWidth = this.H * imgAspectRatio;

                    if ((this.ImageAlign & TK.Draw.AnchorCenter) != 0)
                        drawX = this.X + (this.W - drawWidth) / 2;
                    else if ((this.ImageAlign & TK.Draw.AnchorRight) != 0)
                        drawX = this.X + (this.W - drawWidth);
                }

            } else if (this.Scaling == 2) {
                // Get the aspect ratios  
                var imgAspectRatio = this.Img.width / this.Img.height;
                var boxAspectRatio = this.W / this.H;

                if (imgAspectRatio > boxAspectRatio) {
                    sourceWidth = (sourceWidth / imgAspectRatio) / 2;

                    if ((this.ImageAlign & TK.Draw.AnchorCenter) != 0)
                        sourceX = (this.Img.width - sourceWidth) / 2;
                    else if ((this.ImageAlign & TK.Draw.AnchorRight) != 0)
                        sourceX = this.Img.width - sourceWidth;
                } else {
                    sourceHeight = (sourceHeight * imgAspectRatio) / 2;

                    if ((this.ImageAlign & TK.Draw.AnchorMiddle) != 0)
                        sourceY = (this.Img.height - sourceHeight) / 2;
                    else if ((this.ImageAlign & TK.Draw.AnchorBottom) != 0)
                        sourceY = this.Img.height - sourceHeight;
                }
            }
            c.drawImage(this.Img, sourceX, sourceY, sourceWidth, sourceHeight,  drawX, drawY, Math.round(drawWidth), Math.round(drawHeight));
            c.globalAlpha = 1;
        } catch (errie) { }
        c.closePath();
    }
};"use strict";
/* Minify Skip */
/* Minify Order(155) */

TK.Draw.Line = {
    DrawType: "Line",
    _: TK.Draw.DrawableObject,
    Draw: function (c) {
        c.beginPath();
        this.Transform(c);
        c.moveTo(this.X, this.Y);
        if (this.X2 != undefined) {
            c.lineTo(this.X2, this.Y2);
        } else {
            c.lineTo(this.X + this.W, this.Y + this.H);
        }

        this.DrawFS(c);
        c.closePath();
    }
};

"use strict";
/* Minify Skip */
/* Minify Order(155) */

TK.Draw.LineThroughPoints = {
    DrawType: "LineThroughPoints",
    _: TK.Draw.DrawableObject,
    Points: [], // [ [x,y], [x, y] ], optionally a third parameter (direction) can be passed as well [x, y, direction]
    Heights: [], // Array with heights for each point, for creating an area chart or sankey lines
    Smoothing: TK.Draw.SmoothNone,
    DefaultDirection: TK.Draw.DirectionRight, // Default direction if not set at point level, used for smoothing
    CornerRadius: 10,
    Draw: function (c) {
        c.beginPath();
        if (!this.W) {
            this.W = 0;
            for (var i = 0; i < this.Points.length; i++) {
                if (this.Points[i][0] > this.W)
                    this.W = this.Points[i][0];
                if (this.Points[i][1] > this.H)
                    this.H = this.Points[i][1];
            }
        }
        this.Transform(c);
        var obj = this;

        var passes = this.Heights && this.Heights.length >= this.Points.length ? 2 : 1;
        var points = this.Points.slice();
        var cornersEndPos = function (point, otherPoint, reverseDir) {
            point = point.slice();
            var dir = point.length > 2 && point[2] !== null && point[2] !== undefined ? point[2] : obj.DefaultDirection;
            var cornerSize = obj.CornerRadius;

            if (reverseDir)
                dir = (dir + 2) % 4;
            if (dir == TK.Draw.DirectionTop) {
                point[2] = otherPoint[0] >= point[0] ? TK.Draw.DirectionRight : TK.Draw.DirectionLeft;
                point[1] -= cornerSize;
                point[0] += otherPoint[0] >= point[0] ? cornerSize : -cornerSize;
            } else if (dir == TK.Draw.DirectionRight) {
                point[2] = otherPoint[1] >= point[1] ? TK.Draw.DirectionBottom : TK.Draw.DirectionTop;
                point[1] += otherPoint[1] >= point[1] ? cornerSize : -cornerSize;
                point[0] += cornerSize;
            } else if (dir == TK.Draw.DirectionBottom) {
                point[2] = otherPoint[0] >= point[0] ? TK.Draw.DirectionRight : TK.Draw.DirectionLeft;
                point[1] += cornerSize;
                point[0] += otherPoint[0] >= point[0] ? cornerSize : -cornerSize;
            } else if (dir == TK.Draw.DirectionLeft) {
                point[2] = otherPoint[1] >= point[1] ? TK.Draw.DirectionBottom : TK.Draw.DirectionTop;
                point[1] += otherPoint[1] >= point[1] ? cornerSize : -cornerSize;
                point[0] -= cornerSize;
            }
            return point;
        };
        var cornersDrawCurve = function (point, otherPoint, dir) {
            // Dir should be the direction after the curve
            if (dir == TK.Draw.DirectionTop || dir == TK.Draw.DirectionBottom) {
                c.quadraticCurveTo(otherPoint[0] + obj.X, point[1] + obj.Y, otherPoint[0] + obj.X, otherPoint[1] + obj.Y);
            } else {
                c.quadraticCurveTo(point[0] + obj.X, otherPoint[1] + obj.Y, otherPoint[0] + obj.X, otherPoint[1] + obj.Y);
            }
            //c.lineTo(otherPoint[0], otherPoint[1]);
        };
        for (var pass = 0; pass < passes; pass++) {
            if (pass == 1) {
                // If the heights for all points is set, we will loop through the points a second time
                // in reverse order with the added heights and reversed directions so we can make a full closed loop.
                points = points.map(function (p, index) {
                    var newP = p.slice();
                    newP[1] += obj.Heights[index];
                    newP[2] = ((newP[2] !== undefined && newP[2] !== null ? newP[2] : obj.DefaultDirection) + 2) % 4;
                    return newP;
                });
                points = points.reverse();
            }

            for (var i = 0; i < points.length; i++) {
                var p = points[i];
                var dir = p.length >= 3 && p[2] !== null && p[2] !== undefined ? p[2] : this.DefaultDirection;

                if (i == 0) {
                    if (pass == 0)
                        c.moveTo(p[0] + this.X, p[1] + this.Y);
                    else
                        c.lineTo(p[0] + this.X, p[1] + this.Y);
                    continue;
                }
                var lp = points[i - 1];
                var ldir = lp.length >= 3 && lp[2] !== null && lp[2] !== undefined ? lp[2] : this.DefaultDirection;

                var x_mid = (lp[0] + p[0]) / 2;
                var y_mid = (lp[1] + p[1]) / 2;

                if (!this.Smoothing) {
                    c.lineTo(p[0] + this.X, p[1] + this.Y);
                } else if (this.Smoothing == TK.Draw.SmoothQuadratic) {
                    if (ldir == TK.Draw.DirectionRight || ldir == TK.Draw.DirectionLeft) {
                        var cp_x1 = (x_mid + lp[0]) / 2;
                        var cp_x2 = (x_mid + p[0]) / 2;
                        c.quadraticCurveTo(cp_x1 + this.X, lp[1] + this.Y, x_mid + this.X, y_mid + this.Y);
                        c.quadraticCurveTo(cp_x2 + this.X, p[1] + this.Y, p[0] + this.X, p[1] + this.Y);
                    } else if (ldir == TK.Draw.DirectionTop || ldir == TK.Draw.DirectionBottom) {
                        var cp_y1 = (y_mid + lp[1]) / 2;
                        var cp_y2 = (y_mid + p[1]) / 2;
                        c.quadraticCurveTo(lp[0] + this.X, cp_y1 + this.Y, x_mid + this.X, y_mid + this.Y);
                        c.quadraticCurveTo(p[0] + this.X, cp_y2 + this.Y, p[0] + this.X, p[1] + this.Y);
                    }
                } else if (this.Smoothing == TK.Draw.SmoothCorners) {
                    // TODO:
                    // - Check if it's nearby, we might need to reduce the corner radius
                    // - Do multiple corners if we are not in the correct direction yet
                    //var startPoint = cornersEndPos(lp, p);
                    var startPoint = [lp[0], lp[1], ldir];
                    var endPoint = cornersEndPos(p, lp, true);
                    var revDirEnd = (endPoint[2] + 2) % 4;


                    var max = 100;
                    while (startPoint[0] != endPoint[0] || startPoint[1] != endPoint[1]) {
                        max--;
                        if (max == 0) {
                            console.log("max reached");
                            break;
                        }
                        var startDirHorizontal = startPoint[2] == TK.Draw.DirectionLeft || startPoint[2] == TK.Draw.DirectionRight;
                        if (startPoint[2] == revDirEnd && startDirHorizontal && startPoint[1] == endPoint[1]) {
                            // If already at the right height, just need 1 line to connect
                            c.lineTo(endPoint[0] + this.X, endPoint[1] + this.Y);
                            break;
                        } else if (startPoint[2] == revDirEnd && !startDirHorizontal && startPoint[0] == endPoint[0]) {
                            // If already at the right x pos, just need 1 line to connect
                            c.lineTo(endPoint[0] + this.X, endPoint[1] + this.Y);
                            break;
                        } else {
                            // Make a line towards the right direction
                            var newPos = startPoint.slice();
                            if (startPoint[2] == TK.Draw.DirectionRight) {
                                if (endPoint[2] == TK.Draw.DirectionLeft)
                                    newPos[0] = endPoint[0] - (2 * this.CornerRadius);
                                else if (endPoint[2] == TK.Draw.DirectionTop || endPoint[2] == TK.Draw.DirectionBottom)
                                    newPos[0] = endPoint[0] - this.CornerRadius;
                                else
                                    newPos[0] = endPoint[0];
                                startPoint[0] = newPos[0] > startPoint[0] ? newPos[0] : startPoint[0];
                            } else if (startPoint[2] == TK.Draw.DirectionLeft) {
                                if (endPoint[2] == TK.Draw.DirectionRight)
                                    newPos[0] = endPoint[0] + (2 * this.CornerRadius);
                                else if (endPoint[2] == TK.Draw.DirectionTop || endPoint[2] == TK.Draw.DirectionBottom)
                                    newPos[0] = endPoint[0] + this.CornerRadius;
                                else
                                    newPos[0] = endPoint[0];
                                startPoint[0] = newPos[0] < startPoint[0] ? newPos[0] : startPoint[0];
                            } else if (startPoint[2] == TK.Draw.DirectionBottom) {
                                if (endPoint[2] == TK.Draw.DirectionTop)
                                    newPos[1] = endPoint[1] - (2 * this.CornerRadius);
                                else if (endPoint[2] == TK.Draw.DirectionLeft || endPoint[2] == TK.Draw.DirectionRight)
                                    newPos[1] = endPoint[1] - this.CornerRadius;
                                else
                                    newPos[1] = endPoint[1];
                                startPoint[1] = newPos[1] > startPoint[1] ? newPos[1] : startPoint[1];
                            } else if (startPoint[2] == TK.Draw.DirectionTop) {
                                if (endPoint[2] == TK.Draw.DirectionRight)
                                    newPos[1] = endPoint[1] + (2 * this.CornerRadius);
                                else if (endPoint[2] == TK.Draw.DirectionLeft || endPoint[2] == TK.Draw.DirectionRight)
                                    newPos[1] = endPoint[1] + this.CornerRadius;
                                else
                                    newPos[1] = endPoint[1];
                                startPoint[1] = newPos[1] < startPoint[1] ? newPos[1] : startPoint[1];
                            }

                            c.lineTo(startPoint[0] + this.X, startPoint[1] + this.Y);

                            // Corner into the right direction and update our start pos
                            var newStartPoint = cornersEndPos(startPoint, p);
                            cornersDrawCurve(startPoint, newStartPoint, newStartPoint[2]);
                            startPoint = newStartPoint;
                        }
                    }
                    //c.moveTo(p[0],p[1])
                    cornersDrawCurve(startPoint, p, dir);
                }
            }
            if (pass == 1 && this.Points.length > 0) {
                c.lineTo(this.Points[0][0] + this.X, this.Points[0][1] + this.Y);
            }
        }

        this.DrawFS(c);
        c.closePath();
    }
};
"use strict";
/* Minify Skip */
/* Minify Order(155) */

TK.Draw.Rect = {
    DrawType: "Rect",
    _: TK.Draw.DrawableObject,
    //RoundCorners: [15,15,15,15],
    ShadeSize: 0,
    ShadePosition: 1,
    Extrude: 0, // Does not work with RoundCorners yet
    DrawRoundedRect: function (c, x, y, w, h, corners) {
        if (!corners || (corners[0] == 0 && corners[1] == 0 && corners[2] == 0 && corners[3] == 0)) {
            c.rect(x, y, w, h);
            return;
        }

        c.moveTo(x + corners[0], y);
        c.lineTo(x + w - corners[1], y);
        c.quadraticCurveTo(x + w, y, x + w, y + corners[1]);
        c.lineTo(x + w, y + h - corners[2]);
        c.quadraticCurveTo(x + w, y + h, x + w - corners[2], y + h);
        c.lineTo(x + corners[3], y + h);
        c.quadraticCurveTo(x, y + h, x, y + h - corners[3]);
        c.lineTo(x, y + corners[0]);
        c.quadraticCurveTo(x, y, x + corners[0], y);
    },
    Draw: function (c) {
        c.beginPath();
        this.Transform(c);


        var corners = null;
        if (this.RoundCorners && this.RoundCorners.length == 4) {
            corners = this.RoundCorners.slice();
            var w = this.W;
            var h = this.H;
            var f = 2;
            if (corners[0] * f > w || corners[1] * f > w || corners[2] * f > w || corners[3] * f > w || corners[0] * f > h || corners[1] * f > h || corners[2] * f > h || corners[3] * f > h)
                corners = null;
        }

        this.DrawRoundedRect(c, this.X, this.Y, this.W, this.H, corners);

        this.DrawFS(c);
        c.closePath();

        if (this.Extrude) {
            if (this.Extrude > 0) {
                // Outside, Draw lighter color above, darker color on the right
                c.beginPath();
                c.fillStyle = this.FillExtrudeLightColor ? this.FillExtrudeLightColor : TK.Draw.ColorToDifferentColor(this.Fill, "#FFF", 0.4);
                c.moveTo(this.X, this.Y);
                c.lineTo(this.X + this.Extrude, this.Y - this.Extrude);
                c.lineTo(this.X + this.W + this.Extrude, this.Y - this.Extrude);
                c.lineTo(this.X + this.W, this.Y);
                c.lineTo(this.X, this.Y);
                c.fill();
                c.closePath();

                c.beginPath();
                c.fillStyle = this.FillExtrudeDarkColor ? this.FillExtrudeDarkColor : TK.Draw.ColorToDifferentColor(this.Fill, "#000", 0.4);
                c.moveTo(this.X + this.W, this.Y);
                c.lineTo(this.X + this.W + this.Extrude, this.Y - this.Extrude);
                c.lineTo(this.X + this.W + this.Extrude, this.Y + this.H - this.Extrude);
                c.lineTo(this.X + this.W, this.Y + this.H);
                c.lineTo(this.X + this.W, this.Y);
                c.fill();
                c.closePath();
            } else if (this.Extrude < 0) {
                // Inside
                c.beginPath();
                //c.fillStyle = colorToDifferentColor(this.Fill, "#FFF", 0.4);
                c.fillStyle = this.FillExtrudeDarkColor ? this.FillExtrudeDarkColor : TK.Draw.ColorToDifferentColor(this.Fill, "#000", 0.4);
                c.moveTo(this.X, this.Y);
                c.lineTo(this.X + -this.Extrude, this.Y);
                c.lineTo(this.X + -this.Extrude, this.Y + this.H - -this.Extrude);
                c.lineTo(this.X, this.Y + this.H);
                c.lineTo(this.X, this.Y);
                c.fill();
                c.closePath();

                c.beginPath();
                c.fillStyle = this.FillExtrudeLightColor ? this.FillExtrudeLightColor : TK.Draw.ColorToDifferentColor(this.Fill, "#000", 0.1);
                c.moveTo(this.X, this.Y + this.H);
                c.lineTo(this.X + -this.Extrude, this.Y + this.H - -this.Extrude);
                c.lineTo(this.X + this.W, this.Y + this.H - -this.Extrude);
                c.lineTo(this.X + this.W, this.Y + this.H);
                c.lineTo(this.X, this.Y + this.H);
                c.fill();
                c.closePath();
            }
        }

        if (this.ShadeSize) {
            c.beginPath();
            this.Transform(c);
            var origFill = this.Fill;
            var origStroke = this.Stroke;
            this.Fill = "rgba(0,0,0,0.2)";
            this.Stroke = null;

            if (!corners)
                corners = [0, 0, 0, 0];

            if (this.ShadePosition == 0)
                this.DrawRoundedRect(c, this.X, this.Y, this.W, this.ShadeSize, [corners[0], corners[1], 0, 0]);
            else if (this.ShadePosition == 1)
                this.DrawRoundedRect(c, (this.X + this.W) - this.ShadeSize, this.Y, this.ShadeSize, this.H, [0, corners[1], corners[2], 0]);
            else if (this.ShadePosition == 2)
                this.DrawRoundedRect(c, this.X, (this.Y + this.H) - this.ShadeSize, this.W, this.ShadeSize, [0, 0, corners[2], corners[3]]);
            else if (this.ShadePosition == 3)
                this.DrawRoundedRect(c, this.X, this.Y, this.ShadeSize, this.H, [corners[1], 0, 0, 0]);

            this.DrawFS(c);
            c.closePath();
            this.Fill = origFill;
            this.Stroke = origStroke;
        }
    }
};
"use strict";
/* Minify Skip */
/* Minify Order(155) */

TK.Draw.TextScalingNormal = 0; // None
TK.Draw.TextScalingWhiteSpaceBreak = 1; // Continue on next line to make text fit
TK.Draw.TextScalingResize = 2; // Always resize to fit the full frame, while keeping aspect ratio
TK.Draw.TextScalingResizeIfNeeded = 3; // Only resize if the text doesn't fit, while keeping aspect ratio


TK.Draw.Text = {
    DrawType: "Text",
    _: TK.Draw.DrawableObject,
    BlockedText: false, // Static TK.Draw.Text.BlockedText, If set to true only colored rects will be drawed instead of text, useful for testing or visual censoring
    Text: "Text", Font: "30pt Arial",
    Scaling: TK.Draw.TextScalingNormal,
    LineSpacingRatio: 1.1,
    WidthPadding: 2,
    HeightPadding: 2,
    TextAlign: TK.Draw.AnchorCenter | TK.Draw.AnchorMiddle,
    Invalidate: function () {
        this.CachedImage = null;
    },
    Draw: function (c) {
        if (this.Text === null || this.Text === undefined)
            return;
        if (this.Text.substring === undefined)
            this.Text = this.Text.toString();
        c.beginPath();

        if (!this.W) {
            this.W = this.MeasureWidth(this.Text);
        }
        if (!this.H) {
            this.H = this.MeasureHeight(this.Text, this.Font);
        }

        if (this.Rotate) {
            var translateX = this.X;
            var translateY = this.Y;

            c.translate(translateX, translateY);
            //c.ellipse(0, 0, 35, 35, 0, 0, (2 * Math.PI));

            c.rotate(this.Rotate * Math.PI / 180);
            c.translate(-translateX, -translateY);
        }

        this.Transform(c);
        if (TK.Draw.Text.BlockedText) {
            c.fillRect(this.X, this.Y, this.W, this.H);
        } else {
            if (!this.CachedImage) {
                this.CachedImage = document.createElement("CANVAS");
                this.CachedImage.width = Math.round(this.W * c.Scale);
                this.CachedImage.height = Math.round(this.H * c.Scale);
                this.CachedImage.style.width = Math.round(this.W * c.Scale) + "px";
                this.CachedImage.style.width = Math.round(this.H * c.Scale) + "px";
                var text = this.Text;
                var scaleFactor = 1;
                var lineHeight = this.MeasureHeight(this.Text, this.Font);
                if (this.Scaling == TK.Draw.TextScalingWhiteSpaceBreak) {
                    // Try to insert line breaks
                    // TODO: Support text with provided linebreaks
                    var parts = this.Text.split(/ /g);
                    var newText = "";
                    var sentenceLength = 0;
                    for (var i = 0; i < parts.length; i++) {
                        var curText = parts[i] + (i + 1 == parts.length ? "" : " ");
                        var curWidth = Math.ceil(this.MeasureWidth(curText, this.Font)); 
                        if (sentenceLength > 0 && sentenceLength + curWidth >= this.W) {
                            newText += "\n";
                            sentenceLength = curWidth;
                        } else {
                            sentenceLength += curWidth;
                        }
                        newText += curText;
                    }
                    text = newText;
                } else if (this.Scaling == TK.Draw.TextScalingResize || this.Scaling == TK.Draw.TextScalingResizeIfNeeded) {
                    // Calculate factor the font size needs to be changed to make it fill the frame
                    // TODO: Support text with provided linebreaks
                    var widthRatio = this.W / this.MeasureWidth(this.Text, this.Font);
                    var heightRatio = this.H / lineHeight;

                    if (this.Scaling == TK.Draw.TextScalingResize || widthRatio < 1 || heightRatio < 1) {
                        scaleFactor = Math.min(widthRatio, heightRatio);
                        lineHeight *= scaleFactor;
                    }
                }
                lineHeight = Math.ceil(lineHeight); // unscaled

                var cachedContext = this.CachedImage.getContext("2d");
                cachedContext.imageSmoothingEnabled = false;
                cachedContext.textAlign = "left";
                cachedContext.textBaseline = "top";
                cachedContext.font = this.Font;
                this.DrawFS(cachedContext);
                cachedContext.setTransform(c.Scale * scaleFactor, 0, 0, c.Scale * scaleFactor, 0, 0);
                var correctionFactor = 1 / scaleFactor;

                var lines = text.split(/\n/g);
                var curY = 0;
                var totalHeight = lines.length == 0 ? 0 : ((lines.length - 1) * lineHeight * this.LineSpacingRatio) + lineHeight;
                
                if ((this.TextAlign & TK.Draw.AnchorMiddle) > 0) {
                    curY = (this.H / 2) - (totalHeight / 2);
                } else if ((this.TextAlign & TK.Draw.AnchorBottom) > 0) {
                    curY = this.H - totalHeight;
                }
                curY = Math.ceil(curY * correctionFactor);

                for (var i = 0; i < lines.length; i++) {
                    var curX = 0;
                    var lineWidth = this.MeasureWidth(lines[i], this.Font);

                    if (scaleFactor == 1 && (this.TextAlign & TK.Draw.AnchorCenter) > 0)
                        curX = (this.W / 2) - (lineWidth / 2);
                    else if (scaleFactor == 1 && (this.TextAlign & TK.Draw.AnchorRight) > 0)
                        curX = this.W - lineWidth;
                    else if (scaleFactor != 1 && lineWidth * scaleFactor >= this.H && (this.TextAlign & TK.Draw.AnchorCenter) > 0) {
                        // Make sure its centered after scaling
                        curX = ((this.W / 2) - ((lineWidth * scaleFactor) / 2)) * correctionFactor;
                    } else if (scaleFactor != 1 && lineWidth * scaleFactor >= this.H && (this.TextAlign & TK.Draw.AnchorRight) > 0) {
                        // Make sure its centered after scaling
                        curX = (this.W - (lineWidth * scaleFactor)) * correctionFactor;
                    }

                    if (this.Fill)
                        cachedContext.fillText(lines[i], curX, curY);
                    if (this.Stroke) {
                        cachedContext.miterLimit = 3;
                        cachedContext.strokeText(lines[i], curX, curY);
                    }

                    curY += Math.ceil(lineHeight * this.LineSpacingRatio * correctionFactor);
                }
            }            
            c.drawImage(this.CachedImage, Math.floor(this.X), Math.floor(this.Y), Math.round(this.W), Math.round(this.H));
        }
        c.closePath();
    },
    FillWidthHeight: function () {
        this.W = this.MeasureWidth(this.Text, this.Font);
        this.H = this.MeasureHeight(this.Text, this.Font);
    },
    MeasureHeight: function (txt, font) {
        var extra = this.HeightPadding + (this.LineWidth ? this.LineWidth * 2 : 0);
        var m = this.MeasureText(txt, font);
        if (m.actualBoundingBoxDescent !== undefined)
            return Math.ceil(m.actualBoundingBoxAscent + m.actualBoundingBoxDescent) + extra;

        var height = 16;
        var f = font.split(' ');
        if (f.length > 1) {
            height = parseInt(f[0]);
            if (f[0].indexOf("pt") > 0) {
                height *= 1.34; // TODO: Fix for different user settings
            } else if (f[0].indexOf("em") > 0) {
                height *= 16;
            }
        }
        return Math.ceil(height) + extra;
    },
    MeasureWidth: function (txt, font) {
        var extra = this.WidthPadding + (this.LineWidth ? this.LineWidth * 2 : 0);
        var m = this.MeasureText(txt, font);
        if (m.actualBoundingBoxRight !== undefined)
            return Math.ceil(m.actualBoundingBoxLeft + m.actualBoundingBoxRight) + extra;
        return Math.ceil(m.width) + extra; // fallback
    },
    MeasureText: function (txt, font) {
        if (txt == undefined)
            txt = this.Text;
        if (font == undefined)
            font = this.Font;

        if (!TK.Draw.Text.MeasuringCanvas) {
            TK.Draw.Text.MeasuringCanvas = document.createElement("CANVAS");
            TK.Draw.Text.MeasuringCanvasContext = TK.Draw.Text.MeasuringCanvas.getContext("2d");
        }
        var c = TK.Draw.Text.MeasuringCanvasContext;
        c.textAlign = "left";
        c.textBaseline = "top";
        c.font = font;

        return c.measureText(txt);
    }
};
"use strict";

/* Minify Order(200) */
window.TK.ButtonSwitcher = {
    className: "toolkitButtonSwitcher",
    Data: null,
    Init: function () {
        if (!this.DataSettings) {
            this.DataSettings = {
                Options: this.Options,
                Multiple: this.Multiple,
                MultipleCheck: this.MultipleCheck
            };
            
        }
        
        var obj = this;
        for (var i = 0; i < this.DataSettings.Options.length; i++) {
            var isActive = this.DataSettings.Multiple ? this.Data && this.Data.indexOf(this.DataSettings.Options[i].Value) >= 0 : this.Data == this.DataSettings.Options[i].Value;
            this.Add({
                style: {
                    backgroundImage: this.DataSettings.Options[i].Image ? "url('" + this.DataSettings.Options[i].Image + "')" : null
                },
                className: "toolkitButtonSwitchOption " + (isActive ? "toolkitButtonSwitchActive" : ""),
                title: this.DataSettings.Options[i].Title ? this.DataSettings.Options[i].Title : "",
                innerHTML: this.DataSettings.Options[i].Text ? this.DataSettings.Options[i].Text : "&nbsp;",
                Value: this.DataSettings.Options[i].Value,
                onclick: function () {
                    var buttons = obj.Elements.ToArray();
                    var multiple = obj.DataSettings.Multiple;
                    var currentChecked = this.className.indexOf("toolkitButtonSwitchActive") >= 0;
                    if (obj.DataSettings.MultipleCheck && !currentChecked) {
                        var curSelected = obj.GetValue();
                        if (curSelected == null)
                            curSelected = [];
                        if (!obj.DataSettings.MultipleCheck(curSelected, this.Value)) {
                            multiple = false; // deselect rest as this combination isn't allowed
                        }
                    }

                    if (!multiple) {
                        for (var i = 0; i < buttons.length; i++) {
                            buttons[i].className = buttons[i].className.replace(/toolkitButtonSwitchActive/g, "");
                        }
                        this.className += " toolkitButtonSwitchActive";
                    } else {
                        if (currentChecked) {
                            var curSelected = obj.GetValue();
                            if (!obj.DataSettings.Required || (curSelected && curSelected.length > 1))
                                this.className = this.className.replace(/toolkitButtonSwitchActive/g, "");
                        } else
                            this.className += " toolkitButtonSwitchActive";
                    }

                    obj.Data = this.Value;
                    if (obj.onchange)
                        obj.onchange();
                }
            });
        }
    },
    GetValue: function () {
        if (this.DataSettings.Multiple) {
            var buttons = this.Elements.ToArray();
            var selected = [];
            for (var i = 0; i < buttons.length; i++) {
                if (buttons[i].className.indexOf("toolkitButtonSwitchActive") >= 0) {
                    selected.push(buttons[i].Value);
                }
            }
            return selected.length > 0 ? selected : null;
        }
        return this.Data;
    }
};

if (window.TK.Form) {
    window.TK.Form.DefaultTemplates.buttonSwitcher = {
        _: TK.ButtonSwitcher
    };
}"use strict";
/* Minify Skip */
/* Minify Order(200) */

TK.Chart = {
    _: "div",
    DefaultColors: ["#0081D5", "#FF9947", "#03BD5B", "#A939B9", "#D1335B", "#53657D", "#339999", "#999933", "#993399", "#333399", "#999933"],
    Width: 700,
    Height: 400,
    __RecursivePropertiesSeries: true,
    Series: [
        // Style (flags): 1 Line, 2 Bar, 4 Points, 8 Area, 16 Text with line and point to the value position
        // Data is array with X,Y values, X value can be a number, or date-string, or a color
        //{ Title: "Test series 1", Axis: "X,Y1", Color: "#0081D5",StackGroup: "b",  Style: 2, Smoothing: 1, Data: [["2010-01-01", 100], ["2010-01-02", 100], ["2010-01-03", 50], ["2010-01-04", 100], ["2010-01-05", 75]] },
        //{ Title: "Test series 2", Axis: "X,Y1", Color: "#FF9947", StackGroup: "b", Style: 2, Smoothing: 1, LineWidth: 2, Data: [["2010-01-01", 10], ["2010-01-02", 20], ["2010-01-03", 10], ["2010-01-04", 10], ["2010-01-05", 20]] },
        //{ Title: "Test series 3", Axis: "X,Y1", Color: "#990000", Style: 2, Smoothing: 1, LineWidth: 2, Data: [["2010-01-01", 20], ["2010-01-02", 30], ["2010-01-03", 20], ["2010-01-04", 30], ["2010-01-05", 20]] },
    ],
    __RecursivePropertiesAxis: true,
    Axis: {
        X: {
            //Type: 0, // 0 - Numbers, 1 - DateTime
            Type: 1,
            Labels: 0, // 0 - Automatic
            Range: null, // [null, null]  Fixed min/max, null/undefined for automatic, values outside this range will be filtered
            LabelFormat: null,
            LabelFormatEdge: null,
            Title: "",
            Location: 2, // Bottom  ( Top,Right,Bottom,Left,Hidden X,Hidden Y,Size,Color)
        },
        Y1: {
            Type: 0, // 0 - Numbers, 1 - DateTime (Mapped on epoch), 2 - DateTime (Mapped on labels), 3 - Labels
            Labels: 0, // 0 - Automatic
            Range: null, // [null, null]  Fixed min/max, null/undefined for automatic, values outside this range will be filtered
            Title: null,
            ColorLine: "#1d1d1d",
            ColorSteps: "#999",
            ColorMinorSteps: "#CCC",
            ColorLabels: "#999",
            ColorTitle: "#999",
            FontTitle: "12pt Arial",
            Location: 3, // Left      
            Reverse: true,
            Title: ""
        },
        Size: {
            RangeResult: null, // [10, 25],
            Location: 8 
        },
        Color: {
            RangeResult: null, //["#CCC", "#F00"],
            Location: 7
        }
    },
    AxisPadding: 5,    
    LabelSpacing: 60,
    LegendLocation: 2,
    FontLegend: "10pt Arial",
    ColorLegend: "#333",
    TimeZone: "UTC",
    ShadeSize: 0.1,
    RoundCorners: [5, 5, 5, 5],
    Scale: 2,
    MinChartPadding: 35,
    EnableNavigator: false,
    NavigatorStartValue: null,
    NavigatorEndValue: null,
    FixedNavigator: false,
    Navigate: function (minValue, maxValue, final) {
        
    },
    NavigatorLineWidth: 1,
    ColorNavigatorActive: "#999",
    ColorNavigatorInactive: "#EEE",
    ColorNavigatorLine: "#333",
    ColorNavigatorOutside: "rgba(0,0,0,0.3)",
    LegendTemplate: {
        _: TK.Draw.Group,
        Series: null,
        Chart: null,
        Init: function () {
            this.Add({
                _: TK.Draw.Rect,
                X: 0, Y: 0, W: 14, H: 14,
                Fill: this.Series.Color,
                ShadePosition: 2,
                ShadeSize: 3,
                RoundCorners: [3, 3, 3, 3],
                Anchor: TK.Draw.AnchorLeft | TK.Draw.AnchorTop,
            });
            this.Add({
                _: TK.Draw.Text,
                X: 20, Y: 0,
                Fill: this.Chart.ColorLegend,
                Font: this.Chart.FontLegend,
                Text: this.Series.Title,
                Anchor: TK.Draw.AnchorLeft | TK.Draw.AnchorTop,
            });
        },
        GetWidth: function () {
            return TK.Draw.Text.MeasureWidth(this.Series.Title, this.Chart.FontLegend) + 40;
        }
    },

    FormatDate: function (timeStamp, format) {
        var disableAutoSmaller = false;
        if (format.substr(0, 1) == "!") {
            disableAutoSmaller = true;
            format = format.substr(1);
        }
        var date = new Date(timeStamp);
        var p = function (d) { return (d < 10 ? "0" + d : d.toString()); };
        if (this.TimeZone == "UTC") {
            format = format.replace("YYYY", date.getUTCFullYear()).replace("MM", date.getUTCMonth() + 1).replace("DD", date.getUTCDate()).replace("HH", p(date.getUTCHours())).replace("mm", p(date.getUTCMinutes())).replace("ss", p(date.getUTCSeconds()));
        } else {
            if (this.TimeZone != "Local" && window.moment && window.moment.tz) {
                format = moment(timeStamp).tz(this.TimeZone).format(format);
            } else {
                format = format.replace("YYYY", date.getFullYear()).replace("MM", date.getMonth() + 1).replace("DD", date.getDate()).replace("HH", p(date.getHours())).replace("mm", p(date.getMinutes())).replace("ss", p(date.getSeconds()));
            }
        }
        return disableAutoSmaller ? format : format.replace("00:00:00", "").replace(" 00:00", "").replace(/:00$/, "");
    }, 
    Init: function () {
        this.Refresh();
    },
    Refresh: function () {
        if (!this.Elements.Canvas) {
            this.Add({
                _: TK.Draw,
                Scale: this.Scale,
                Width: this.Width,
                Height: this.Height
            }, "Canvas");
        } else {
            this.Elements.Canvas.Clear();
            this.Elements.Canvas.Width = this.Width;
            this.Elements.Canvas.Height = this.Height;
            this.Elements.Canvas.Scale = this.Scale;
            this.Elements.Canvas.Init();
        }
        
        this.RefreshAxises();
        this.RefreshData();
        if (this.EnableNavigator) {
            this.AddNavigator(this.NavigatorStartValue, this.NavigatorEndValue);
        } else {
            delete this.AxisesDetected;
        }
        //console.log(this.AxisesDetected);
        //delete this.AxisesDetected;
        this.Elements.Canvas.Refresh();
    },
    
    AddNavigator: function (from, till) { // Add or set navigator points       
        var obj = this;
        var d = this.AxisesDetected["X"];

        var minPX = d.Position[0];
        var maxPX = d.Position[0] + d.Position[2];
        var heightPX = d.Position[1];
        if (heightPX == 0)
            heightPX = this.Height;

        var fromPX = minPX;
        var tillPX = maxPX;
        if (from !== undefined && from !== null)
            fromPX = d.ValueToPX(from);
        if (till !== undefined && till !== null)
            tillPX = d.ValueToPX(till);
        var cObj = this.Elements.Canvas.Elements;
        if (cObj.NavigatorCenterBlock) {
            // Already added, just update
            cObj.NavigatorMinBlock.X = fromPX;
            cObj.NavigatorMaxBlock.X = tillPX;
            cObj.NavigatorMinLine.X = fromPX;
            cObj.NavigatorMinOutside.W = fromPX - minPX;
            cObj.NavigatorMaxLine.X = tillPX;
            cObj.NavigatorMaxOutside.X = tillPX;
            cObj.NavigatorMaxOutside.W = maxPX - tillPX;
            this.Elements.Canvas.Refresh();
            return;
        }
        

        var outsideConfig = {
            _: TK.Draw.Rect,
            Fill: this.ColorNavigatorOutside,
            X: 0, Y: 0, W: 0, H: heightPX,
            Anchor: TK.Draw.AnchorLeft | TK.Draw.AnchorTop,
        };

        var lineConfig = {
            _: TK.Draw.Line,
            Stroke: this.ColorNavigatorLine,
            LineWidth: this.NavigatorLineWidth,
            X: 0, Y: 0, W: 1, H: heightPX,
            Anchor: TK.Draw.AnchorCenter | TK.Draw.AnchorTop,
        };
        var blockConfig = {
            _: TK.Draw.Rect,
            X: 0, Y: (heightPX / 2) - Math.round(heightPX * 0.15), W: 10, H: Math.round(heightPX * 0.3), Fill: this.ColorNavigatorInactive, Stroke: this.ColorNavigatorLine, LineWidth: this.NavigatorLineWidth,
            Anchor: TK.Draw.AnchorRight | TK.Draw.AnchorTop,
            MouseDown: function (x, y) {
                this.Fill = obj.ColorNavigatorActive;
                var offsetX = this.X - x;
                
                this.MouseMove = function (x2, y2) {
                    this.X = x2 + offsetX;
                    if (this.X < minPX)
                        this.X = minPX;
                    if (this.X > maxPX)
                        this.X = maxPX;

                    if (this.LeftSide && this.X > cObj.NavigatorMaxBlock.X) {
                        this.X = cObj.NavigatorMaxBlock.X;
                    } else if (!this.LeftSide && this.X < cObj.NavigatorMinBlock.X) {
                        this.X = cObj.NavigatorMinBlock.X;
                    }
                    //this.Y = y2 + offsetY;
                    if (this.LeftSide) {
                        cObj.NavigatorMinLine.X = this.X;
                        cObj.NavigatorMinOutside.W = this.X - minPX;
                    } else {
                        cObj.NavigatorMaxLine.X = this.X;
                        cObj.NavigatorMaxOutside.X = this.X;
                        cObj.NavigatorMaxOutside.W = maxPX - this.X;
                        
                    }
                    cObj.NavigatorCenterBlock.W = cObj.NavigatorMaxLine.X - cObj.NavigatorMinLine.X;
                    cObj.NavigatorCenterBlock.X = cObj.NavigatorMinLine.X;

                    if (obj.Navigate)
                        obj.Navigate(cObj.NavigatorMinBlock.GetPositionAsValue(), cObj.NavigatorMaxBlock.GetPositionAsValue(), false);
                    return true;
                };
            },
            MouseUp: function (x, y) {
                this.Fill = obj.ColorNavigatorInactive;
                this.MouseMove = null;
                
                if (obj.Navigate)
                    obj.Navigate(cObj.NavigatorMinBlock.GetPositionAsValue(), cObj.NavigatorMaxBlock.GetPositionAsValue(), true);
            },
            GetPositionAsValue: function () { // Convert X value to actual value
                var r = (this.X - minPX) / (maxPX - minPX);
                if (this.X - 3 < minPX) // If its near start end, pick the start value
                    r = 0;
                if (this.X + 3 > maxPX) // If its near the end, pick the end value
                    r = 1;
                return (r * (d.ScaleMax - d.ScaleMin)) + d.ScaleMin;                
            }
        };

        this.Elements.Canvas.Add({ _: outsideConfig, X: minPX, W: fromPX - minPX }, "NavigatorMinOutside");
        this.Elements.Canvas.Add({ _: outsideConfig, X: tillPX, W: maxPX - tillPX }, "NavigatorMaxOutside");
        this.Elements.Canvas.Add({ _: lineConfig, X: fromPX }, "NavigatorMinLine");
        this.Elements.Canvas.Add({ _: lineConfig, X: tillPX }, "NavigatorMaxLine");
        var minBlock, maxBlock;
        if (!this.FixedNavigator) {
            minBlock = this.Elements.Canvas.Add({ _: blockConfig, X: fromPX, LeftSide: true }, "NavigatorMinBlock");
            maxBlock = this.Elements.Canvas.Add({ _: blockConfig, Anchor: TK.Draw.AnchorLeft | TK.Draw.AnchorTop, X: tillPX, LeftSide: false }, "NavigatorMaxBlock");
        }

        this.Elements.Canvas.Add({
            _: TK.Draw.Rect,
            X: fromPX,
            Y: 0,
            W: (tillPX - fromPX),
            H: heightPX,
            Fill: "rgba(0,0,0,0)",
            MouseOver: function () {
                obj.Elements.Canvas.style.cursor = "grab";
            },
            MouseOut: function () {
                obj.Elements.Canvas.style.cursor = "";
            },
            MouseDown: function (x, y) {                
                var offsetX = this.X - x;
                obj.Elements.Canvas.style.cursor = "grabbing";
                this.MouseMove = function (x2, y2) {

                    this.X = x2 + offsetX;
                    if (this.X < minPX)
                        this.X = minPX;
                    if (this.X + this.W > maxPX)
                        this.X = maxPX - this.W;

                    cObj.NavigatorMinLine.X = this.X;
                    cObj.NavigatorMinOutside.W = this.X - minPX;
                    if (minBlock)
                        minBlock.X = this.X;
                    if (maxBlock)
                        maxBlock.X = this.X + this.W;

                    cObj.NavigatorMaxLine.X = this.X + this.W;
                    cObj.NavigatorMaxOutside.X = this.X + this.W;
                    cObj.NavigatorMaxOutside.W = maxPX - (this.X + this.W);
                    
                    if (obj.Navigate)
                        obj.Navigate(cObj.NavigatorCenterBlock.GetPositionAsValue(true), cObj.NavigatorCenterBlock.GetPositionAsValue(false), false);
                    return true;
                };
                return true;
            },
            MouseUp: function (x, y) {
                this.MouseMove = null;
                obj.Elements.Canvas.style.cursor = "grab";
                if (obj.Navigate)
                    obj.Navigate(this.GetPositionAsValue(true), this.GetPositionAsValue(false), true);
            },
            GetPositionAsValue: function (start) { // Convert X value to actual value
                var x = (this.X + (start ? 0 : this.W));

                var r = (x - minPX) / (maxPX - minPX);
                if (x - 3 < minPX) // If its near start end, pick the start value
                    r = 0;
                if (x + 3 > maxPX) // If its near the end, pick the end value
                    r = 1;
                return (r * (d.ScaleMax - d.ScaleMin)) + d.ScaleMin;
            }
        }, "NavigatorCenterBlock");
    },
    RefreshAxises: function () {
        var defaultColorIndex = 0;
        // Analyse data so we know what Axises we have to generate
        var detected = {};
        var stackGroupData = {};
        for (var i = 0; i < this.Series.length; i++) {            
            if (!this.Series[i].Data || this.Series[i].Data.length == 0 || !this.Series[i].Axis)
                continue;
            if (!this.Series[i].Color)
                this.Series[i].Color = this.DefaultColors[defaultColorIndex++];
            
            var sizePerValue = null;
            if ((this.Series[i].Style & 4) > 0)
                sizePerValue = 8;
            else if ((this.Series[i].Style & 2) == 0)
                sizePerValue = 1;

            var axisesUsed = this.Series[i].Axis.split(',');
            var axises = [];
            
            for (var j = 0; j < axisesUsed.length; j++) {
                var axisName = axisesUsed[j];

                if (!detected[axisName]) {
                    detected[axisName] = {
                        Min: this.Axis[axisName] && this.Axis[axisName].Range ? this.Axis[axisName].Range[0] : null,
                        Max: this.Axis[axisName] && this.Axis[axisName].Range ? this.Axis[axisName].Range[1] : null,
                        RangeResult: this.Axis[axisName] && this.Axis[axisName].RangeResult ? this.Axis[axisName].RangeResult : null,
                        Location: this.Axis[axisName] && this.Axis[axisName].Location !== undefined ? this.Axis[axisName].Location : axisName == "X" ? 2 : axisName == "Y1" ? 3 : 1,
                        Type: this.Axis[axisName] ? this.Axis[axisName].Type : 0,
                        Reverse: this.Axis[axisName] && this.Axis[axisName].Reverse !== undefined ? this.Axis[axisName].Reverse : axisName == "X" || axisName.length > 2 ? false : true,
                        Size: this.Axis[axisName] && this.Axis[axisName].Size ? this.Axis[axisName].Size : sizePerValue,
                        Color: this.Axis[axisName] && this.Axis[axisName].Color ? this.Axis[axisName].Color : "#999",
                        ColorLine: this.Axis[axisName] && this.Axis[axisName].ColorLine ? this.Axis[axisName].ColorLine : "#333",
                        ColorSteps: this.Axis[axisName] && this.Axis[axisName].ColorSteps ? this.Axis[axisName].ColorSteps : "#333",
                        ColorMinorSteps: this.Axis[axisName] && this.Axis[axisName].ColorMinorSteps ? this.Axis[axisName].ColorMinorSteps : "#999",
                        ColorLabels: this.Axis[axisName] && this.Axis[axisName].ColorLabels ? this.Axis[axisName].ColorLabels : "#999",
                        FontLabels: this.Axis[axisName] && this.Axis[axisName].FontLabels ? this.Axis[axisName].FontLabels : "9pt Arial",
                        ColorTitle: this.Axis[axisName] && this.Axis[axisName].ColorTitle ? this.Axis[axisName].ColorTitle : "#999",
                        FontTitle: this.Axis[axisName] && this.Axis[axisName].FontTitle ? this.Axis[axisName].FontTitle : "12pt Arial",
                        Title: this.Axis[axisName] && this.Axis[axisName].Title ? this.Axis[axisName].Title : "",
                        Labels: this.Axis[axisName] && this.Axis[axisName].Labels ? this.Axis[axisName].Labels : 0,
                        LabelFormat: this.Axis[axisName] && this.Axis[axisName].LabelFormat ? this.Axis[axisName].LabelFormat : "dd-MM-yyyy",
                        LabelFormatEdge: this.Axis[axisName] && this.Axis[axisName].LabelFormatEdge ? this.Axis[axisName].LabelFormatEdge : "dd-MM-yyyy",
                        ValueCount: this.Series[i].Data.length,
                        SizeBetweenValues: null,
                        Series: []
                    };
                }
                axises.push(detected[axisName]);
                detected[axisName].Series.push(i);
            }

            var primaryAxis = null;
            var secondaryAxis = null;
            if (this.Series[i].StackGroup) {
                if (!stackGroupData[this.Series[i].StackGroup])
                    stackGroupData[this.Series[i].StackGroup] = {};
                var sg = stackGroupData[this.Series[i].StackGroup];
            }

            // Find our primary axis and secondary axis
            for (var n = 0; n < axises.length; n++) {
                if (axises[n].Location >= 0 || axises[n].Location < 6) {
                    if (primaryAxis === null) {
                        primaryAxis = n;
                    } else if (secondaryAxis === null) {
                        secondaryAxis = n;
                    }
                }
            }

            if (this.Series[i].StackGroup) {
                // Merge with existing stackGroup
                this.Series[i].Offsets = [];

                for (var n = 0; n < this.Series[i].Data.length; n++) {
                    var item = this.Series[i].Data[n];
                    if (sg[item[primaryAxis]] === undefined) {
                        this.Series[i].Offsets.push(0);
                        sg[item[primaryAxis]] = item[secondaryAxis];
                    } else {
                        this.Series[i].Offsets.push(sg[item[primaryAxis]]);
                        sg[item[primaryAxis]] += item[secondaryAxis];
                    }
                }
            }

            for (var j = 0; j < axises.length; j++) {            
                var d = axises[j];

                var first = this.Series[i].Data[0][j];
                var isDate = first.toLowerCase && d.Location != 7 ? true : false;
                if (d.Location < 6 && first.toLowerCase && (d.Type === undefined || d.Type === null)) {
                    d.Type = 1;
                }
                if (d.Type == 3) { // Labels
                    if (!d.LabelMapping) {
                        d.LabelMapping = {};
                        d.CustomSteps = [];
                    }
                    d.Min = 0;
                    
                    for (var n = 0; n < this.Series[i].Data.length; n++) {
                        if (d.LabelMapping[this.Series[i].Data[n][j]] !== undefined)
                            continue;
                        d.LabelMapping[this.Series[i].Data[n][j]] = d.CustomSteps.length;
                        d.CustomSteps.push({ Text: this.Series[i].Data[n][j], Value: d.CustomSteps.length });
                        
                    }
                    d.Max = d.CustomSteps.length - 1;
                    continue;
                }
                
                for (var n = 0; n < this.Series[i].Data.length; n++) {
                    var value = isDate ? new Date(this.Series[i].Data[n][j]).getTime() : this.Series[i].Data[n][j];
                    if (value == null || isNaN(value))
                        continue;

                    if (j == secondaryAxis && this.Series[i].Offsets) {
                        value += this.Series[i].Offsets[n];

                    } else if (j == primaryAxis && n > 0) {
                        var difference = (this.Series[i].Data[n][j].toLowerCase) ? new Date(this.Series[i].Data[n][j]).getTime() - new Date(this.Series[i].Data[n - 1][j]).getTime() : this.Series[i].Data[n][j] - this.Series[i].Data[n - 1][j];
                        if (d.SizeBetweenValues === null || d.SizeBetweenValues > difference)
                            d.SizeBetweenValues = difference;
                    }                    
                    
                    if (d.Min === null || d.Min > value)
                        d.Min = value;
                    if (d.Max === null || d.Max < value)
                        d.Max = value;
                }
                
                if (d.Location >= 6 && !d.RangeResult) {
                    d.RangeResult = [d.Min, d.Max];
                }
            }            
        }

        // Calculated required widths/heights
        var offsets = [0, 0, 0, 0];  // top, right, bottom, left
        for (var axisName in detected) {
            var d = detected[axisName];

            if (d.Min == d.Max) {
                if (d.Max > 0)
                    d.Min = 0;
                else if (d.Min < 0)
                    d.Max = 0;
                else if (d.Min == 0)
                    d.Max += 1;
                else {
                    d.Min -= 1;
                    d.Max += 1;
                }
            }

            d.Position = [0, 0, 0, 0];  // left, top, width, height
            
            if (d.Location == 0 || d.Location == 2) { // Top, Bottom
                var reqSize = 35 + (this.LegendLocation % 2 == d.Location % 2 ? 25 : 0);
                d.Position[3] = reqSize;
                d.Position[1] = (d.Location == 0 ? 0 : this.Height - reqSize);
            } else if (d.Location == 1 || d.Location == 3) { // Right, Left
                var reqSize = 75 + (this.LegendLocation % 2 == d.Location % 2 ? 100 : 0);
                d.Position[2] = reqSize;
                d.Position[0] = (d.Location == 3 ? 0 : this.Width - reqSize);
            }
            offsets[d.Location] += reqSize;
        }        
        
        for (var i = 0; i < 4; i++)
            offsets[i] = offsets[i] == 0 ? this.MinChartPadding : offsets[i] + this.AxisPadding; // Generic axis padding

        for (var axisName in detected) {
            var d = detected[axisName];
            if (d.Location == 0 || d.Location == 2 || d.Location == 4) { // Top/Bottom, use max width minus any offsets claimed on the left/right
                d.Position[2] = this.Width - (offsets[1] + offsets[3]);
                d.Position[0] = offsets[3];

                if (!d.Size) {         
                    var pxPerValue = d.Position[2] / (d.Max - d.Min);
                    if (d.SizeBetweenValues && !isNaN(d.SizeBetweenValues)) {
                        d.Size = pxPerValue * d.SizeBetweenValues * 0.7;
                    } else if (d.CustomSteps) {
                        d.Size = (d.Position[2] / d.CustomSteps.length) * 0.7;
                    }

                    if (d.Size < 1)
                        d.Size = 1;
                    d.Position[0] += Math.ceil(d.Size / 1.2);
                    d.Position[2] -= Math.ceil(d.Size / 1.2) * 2;
                }
            } else if (d.Location == 1 || d.Location == 3 || d.Location == 5) { // Right/Left
                d.Position[3] = this.Height - (offsets[0] + offsets[2]);
                d.Position[1] = offsets[0];

                if (!d.Size) {
                    var pxPerValue = d.Position[3] / (d.Max - d.Min);
                    if (d.SizeBetweenValues && !isNaN(d.SizeBetweenValues)) {
                        d.Size = pxPerValue * d.SizeBetweenValues * 0.7;
                    } else if (d.CustomSteps) {
                        d.Size = (d.Position[3] / d.CustomSteps.length) * 0.7;
                    }

                    if (d.Size < 1)
                        d.Size = 1;
                    d.Position[1] += Math.ceil(d.Size / 1.2);
                    d.Position[3] -= Math.ceil(d.Size / 1.2) * 2;
                }
            } else if (d.Location >= 6) {
                continue;
            }           
            // Find out the optimal label count/step
            var stepCount = Math.floor(d.Position[(d.Location % 2) == 0 ? 2 : 3] / this.LabelSpacing); // Optimal(max) label count
            if (stepCount < 2)
                stepCount = 2;

            if (d.Type == 1 || d.Type == 2) { // DateTime, mapped on time || DateTime, mapped on labels
                // Date time                
                var labelFormat = d.LabelFormat;
                var labelFormatEdge = d.LabelFormatEdge;

                var timeDifference = (d.Max - d.Min) / 1000;
                if (d.Labels == 0) { // Automatic, find out what labels to use based on the time difference
                    if (timeDifference > 60 * 60 * 24 * 365) {
                        d.Labels = 1; // Years
                        labelFormatEdge = "DD-MM-YYYY";
                        labelFormat = "YYYY";
                    } else if (timeDifference > 60 * 60 * 24 * 35) {
                        d.Labels = 2; // Months
                        labelFormatEdge = "DD-MM-YYYY";
                        labelFormat = "DD-MM-YYYY";
                    } else if (timeDifference > 60 * 60 * 24 * 2) {
                        d.Labels = 4; // Days
                        labelFormatEdge = "DD-MM-YYYY HH:mm";
                        labelFormat = "DD";
                    } else if (timeDifference > 60 * 60 * 5) {
                        d.Labels = 8; // Hours
                        labelFormatEdge = "DD-MM-YYYY HH:mm";
                        labelFormat = "HH";
                    } else if (timeDifference > 60 * 2) {
                        d.Labels = 16; // Minutes
                        labelFormatEdge = "DD-MM-YYYY HH:mm:ss";
                        labelFormat = "HH:mm";
                    } else {
                        d.Labels = 32; // Seconds
                        labelFormatEdge = "DD-MM-YYYY HH:mm:ss";
                        labelFormat = "mm:ss";
                    }
                }

                d.CustomSteps = [];
                d.LabelMapping = {};

                d.ScaleMin = d.Min;
                var cur = d.Min;

                d.CustomSteps.push({ Text: this.FormatDate(d.Min, labelFormatEdge), Value: d.Min });



                while (cur < d.Max) {              
                    // Note: Make sure the labels will fall at exact day/month/year changes
                    if (d.Labels == 32) { // Seconds
                        cur += 1 * 1000;
                        cur = cur - (cur % 1000);
                    } else if (d.Labels == 16) { // Minutes
                        cur += 60 * 1000;
                        cur = cur - (cur % (60 * 1000)); // Round down
                    } else if (d.Labels == 8) { // Hours
                        cur += 60 * 60 * 1000;
                        cur = cur - (cur % (60 * 60 * 1000)); // Round down
                    } else if (d.Labels == 4) { // Days
                        var tmp = new Date(cur);
                        if (this.TimeZone == "UTC") {
                            tmp.setUTCDate(tmp.getUTCDate() + 1);
                            tmp.setUTCHours(0);
                            tmp.setUTCMinutes(0);
                            tmp.setUTCSeconds(0);
                        } else {
                            tmp.setDate(tmp.getDate() + 1);
                            tmp.setHours(0);
                            tmp.setMinutes(0);
                            tmp.setSeconds(0);
                        }
                        cur = tmp.getTime();
                    } else if (d.Labels == 2) { // Months
                        var tmp = new Date(cur);
                        if (this.TimeZone == "UTC") {
                            tmp.setUTCMonth(tmp.getUTCMonth() + 1);
                            tmp.setUTCDate(1);
                            tmp.setUTCHours(0);
                            tmp.setUTCMinutes(0);
                            tmp.setUTCSeconds(0);
                        } else {
                            tmp.setMonth(tmp.getMonth() + 1);
                            tmp.setDate(1);
                            tmp.setHours(0);
                            tmp.setMinutes(0);
                            tmp.setSeconds(0);
                        }
                        cur = tmp.getTime();
                    } else if (d.Labels == 1) { // Years
                        var tmp = new Date(cur);
                        if (this.TimeZone == "UTC") {
                            tmp.setUTCFullYear(tmp.getUTCFullYear() + 1);
                            tmp.setUTCMonth(0);
                            tmp.setUTCDate(1);
                            tmp.setUTCHours(0);
                            tmp.setUTCMinutes(0);
                            tmp.setUTCSeconds(0);
                        } else {                                                        
                            tmp.setFullYear(tmp.getFullYear() + 1);
                            tmp.setMonth(0);
                            tmp.setDate(1);
                            tmp.setHours(0);
                            tmp.setMinutes(0);
                            tmp.setSeconds(0);
                        }                        
                        cur = tmp.getTime();
                    } else {
                        cur = d.Max;
                    }                    
                    

                    d.LabelMapping[cur] = d.CustomSteps.length;
                    d.CustomSteps.push({ Text: this.FormatDate(cur >= d.Max ? d.Max : cur, (cur >= d.Max ? labelFormatEdge : labelFormat)), Value: cur >= d.Max ? d.Max : cur });
                    d.ScaleMax = cur >= d.Max ? d.Max : cur;                    
                }
                

                if (d.CustomSteps.length > stepCount) {
                    // Reduce amount of labels
                    // TODO: Try to make more logical/nicer steps
                    var stepAmount = Math.ceil(d.CustomSteps.length / stepCount);                                        
                    for (var i = 0; i < d.CustomSteps.length - 1; i += 1) {
                        if (i % stepAmount > 0 || i + stepAmount*0.8 > d.CustomSteps.length) {
                            d.CustomSteps[i].Text = "";
                        }
                    }                    
                }
            } 


            if (!d.CustomSteps || d.CustomSteps.length == 0) {
                // https://stackoverflow.com/questions/237220/tickmark-algorithm-for-a-graph-axis 
                var epsilon = (d.Max - d.Min) / 1e6;
                var max = d.Max/* + epsilon*/;
                var min = d.Min/* - epsilon*/;
                
                var range = max - min;
                var roughStep = range / (stepCount - 1);
                var goodNormalizedSteps = [1, 1.5, 2, 2.5, 5, 7.5, 10];

                Math.log10 = Math.log10 || function (x) {
                    return Math.log(x) * Math.LOG10E;
                };

                var stepPower = Math.pow(10, -Math.floor(Math.log10(Math.abs(roughStep))));
                var normalizedStep = roughStep * stepPower;
                var goodNormalizedStep = goodNormalizedSteps.First(function (n) { return n >= normalizedStep; });

                d.Step = goodNormalizedStep / stepPower;
                
                if (!d.Reverse) {
                    d.ScaleMax = Math.ceil(max / d.Step) * d.Step;
                    if (d.ScaleMax + d.Step <= d.Max) d.ScaleMax = d.Max;
                    d.ScaleMin = Math.floor(min / d.Step) * d.Step;
                    if (d.ScaleMin - d.Step >= d.Min) d.ScaleMin = d.Min;
                    d.StepCount = ((d.ScaleMax - d.ScaleMin) / d.Step) + 1;
                } else {
                    d.ScaleMax = Math.floor(min / d.Step) * d.Step;
                    if (d.ScaleMax + d.Step <= d.Min) d.ScaleMax = d.Min;
                    d.ScaleMin = Math.ceil(max / d.Step) * d.Step;
                    if (d.ScaleMin - d.Step >= d.Max) d.ScaleMin = d.Max;
                    d.StepCount = ((d.ScaleMin - d.ScaleMax) / d.Step) + 1;
                    d.Step = 0 - d.Step;
                }
                
                
            } else {
                d.StepCount = d.CustomSteps.length;
                if (d.ScaleMin === undefined) {
                    d.ScaleMin = d.Min;
                    d.ScaleMax = d.Max;
                }
                if (d.Reverse)
                    d.CustomSteps = d.CustomSteps.reverse();
            }            

            d.ValueToPX = function (value, excludeOwnPosition) {
                if (value && value.toLowerCase) {
                    if (this.LabelMapping[value] !== undefined) {
                        value = this.LabelMapping[value];
                    } else if (this.Type == 1 || this.Type == 2) {
                        value = new Date(value).getTime();
                    }
                }
                
                var sizePX = this.Position[(this.Location % 2) == 0 ? 2 : 3];
                if (this.Reverse) { // Reverse
                    var difference = (this.ScaleMin - this.ScaleMax);
                    return Math.round(sizePX - (((value - this.ScaleMax) / difference) * sizePX)
                        + (excludeOwnPosition ? 0 : this.Position[(this.Location % 2) == 0 ? 0 : 1]));    
                }
                return Math.round((((value - this.ScaleMin) / (this.ScaleMax - this.ScaleMin)) * sizePX)
                    + (excludeOwnPosition ? 0 : this.Position[(this.Location % 2) == 0 ? 0 : 1]));
            };
            
            // Draw axis and legend
            var stepTexts = [];
            if (d.Location == 2 || d.Location == 0) { // Bottom, Top
                var y = d.Location == 2 ? d.Position[1] : d.Position[3] + d.Position[1];

                if (d.Title) {
                    this.Elements.Canvas.Add({
                        _: TK.Draw.Text, X: d.Position[2] + d.Position[0], Y: (d.Location == 2 ? y + 30 : y - 30),
                        Anchor: TK.Draw.AnchorRight | (d.Location == 2 ? TK.Draw.AnchorTop : TK.Draw.AnchorBottom),
                        Fill: d.ColorTitle,
                        Font: d.FontTitle,
                        Text: d.Title 
                    });
                }
                
                this.Elements.Canvas.Add({
                    _: TK.Draw.Line, X: d.Position[0], Y: y, W: d.Position[2], H: 0, Stroke: d.ColorLine
                });
                
                for (var i = 0; i < d.StepCount; i++) {
                    var posX = (d.Position[0] + (d.Position[2] / (d.StepCount - 1)) * i);
                    if (d.CustomSteps && d.CustomSteps[i] && d.CustomSteps[i].Value !== null && d.CustomSteps[i].Value !== undefined)
                        posX = d.ValueToPX(d.CustomSteps[i].Value);

                    if (d.CustomSteps && d.CustomSteps[i] && d.CustomSteps[i].Text == "") {
                        this.Elements.Canvas.Add({
                            _: TK.Draw.Line, X: posX, Y: (d.Location == 2 ? y : y - 5), W: 0, H: 5, Stroke: d.ColorMinorSteps
                        });
                        continue;
                    }
                    this.Elements.Canvas.Add({
                        _: TK.Draw.Line, X: posX, Y: (d.Location == 2 ? y : y - 10), W: 0, H: 10, Stroke: d.ColorSteps
                    });
                    stepTexts[i] = this.Elements.Canvas.Add({
                        _: TK.Draw.Text,
                        X: posX, Y: (d.Location == 2 ? y + 15 : y - 15),
                        Fill: d.ColorLabels,
                        Font: d.FontLabels,
                        Text: d.CustomSteps && d.CustomSteps[i] ? d.CustomSteps[i].Text : Math.round((d.ScaleMin + (d.Step * i)) * 10000)/ 10000,                        
                        Anchor: TK.Draw.AnchorCenter | (d.Location == 2 ? TK.Draw.AnchorTop : TK.Draw.AnchorBottom),
                    });
                    
                    if (i + 1 == d.StepCount) {
                        var width = stepTexts[i].MeasureWidth();
                        // Move label if text goes outside the canvas
                        if (posX + width / 2 > (this.Width - 5))
                            stepTexts[i].X = this.Width - ((width / 2) + 5);

                        // Hide overlapping labels
                        for (var n = i - 1; n >= 0; n--) {
                            if (!stepTexts[n])
                                continue;
                            var curWidth = stepTexts[n].MeasureWidth();
                            if (stepTexts[n].X + (curWidth / 2) + 10 < stepTexts[i].X - (width / 2))
                                break;
                            stepTexts[n].Text = "";
                        }

                        if (stepTexts[0] && stepTexts[0].Text) {
                            width = stepTexts[0].MeasureWidth();
                            for (var n = 1; n < i - 1; n++) {
                                if (!stepTexts[n])
                                    continue;
                                var curWidth = stepTexts[n].MeasureWidth();
                                if (stepTexts[n].X - ((curWidth / 2) + 10) > stepTexts[0].X + (width / 2))
                                    break;
                                stepTexts[n].Text = "";
                            }
                        }
                    }
                }
                if (this.LegendLocation == 2 || this.LegendLocation == 0) {
                    var curPos = 25;
                    if (this.LegendLocation == 0)
                        y = -25;

                    for (var i = 0; i < this.Series.length; i++) {
                        if (!this.Series[i].Title || this.Series[i].Title == "" || this.Series[i].HiddenInLegend)
                            continue;

                        var legendBlock = this.Elements.Canvas.Add({
                            _: this.LegendTemplate,
                            X: curPos,
                            Y: y + 35,
                            Series: this.Series[i],
                            Chart: this
                        });
                        curPos += legendBlock.GetWidth();
                        
                    }
                }
            } else if (d.Location == 1 || d.Location == 3) { // Right, Left
                var x = d.Location == 1 ? d.Position[0] : d.Position[2] + d.Position[0];

                if (d.Title) {
                    this.Elements.Canvas.Add({
                        _: TK.Draw.Text, X: d.Location == 3 ? 5 : this.Width - 5, Y: d.Position[1] + (d.Position[3] / 2),
                        Anchor: TK.Draw.AnchorCenter | TK.Draw.AnchorTop,
                        Fill: d.ColorTitle,
                        Font: d.FontTitle,
                        Text: d.Title,
                        Rotate: d.Location == 3 ? -90 : 90
                    });
                }

                this.Elements.Canvas.Add({
                    _: TK.Draw.Line, X: x, Y: d.Position[1], W: 0, H: d.Position[3], Stroke: d.ColorLine
                });
                
                for (var i = 0; i < d.StepCount; i++) {           
                    var posY = (d.Position[1] + (d.Position[3] / (d.StepCount - 1)) * i);
                    if (d.CustomSteps && d.CustomSteps[i] && d.CustomSteps[i].Value !== null && d.CustomSteps[i].Value !== undefined)
                        posY = d.ValueToPX(d.CustomSteps[i].Value);

                    if (d.CustomSteps && d.CustomSteps[i] && d.CustomSteps[i].Text == "") {
                        this.Elements.Canvas.Add({
                            _: TK.Draw.Line, X: (d.Location == 1 ? x : x - 5), Y: posY, W: 5, H: 0, Stroke: d.ColorMinorSteps
                        });
                        continue;
                    }
                    this.Elements.Canvas.Add({
                        _: TK.Draw.Line, X: (d.Location == 1 ? x : x - 10), Y: posY, W: 10, H: 0, Stroke: d.ColorSteps
                    });
                    this.Elements.Canvas.Add({
                        _: TK.Draw.Text,
                        X: (d.Location == 1 ? x + 15 : x - 15), Y: posY,
                        Fill: d.ColorLabels,
                        Font: d.FontLabels,
                        Text: d.CustomSteps && d.CustomSteps[i] ? d.CustomSteps[i].Text : Math.round((d.ScaleMin + (d.Step * i)) * 10000) / 10000,
                        Anchor: (d.Location == 1 ? TK.Draw.AnchorLeft : TK.Draw.AnchorRight) | TK.Draw.AnchorMiddle,
                    });
                }
            }
        }
        this.AxisesDetected = detected;
    },
    RefreshData: function () {
        
        for (var i = 0; i < this.Series.length; i++) {
            var s = this.Series[i];
            if (!s.Data || s.Data.length == 0 || !s.Axis)
                continue;            
            var axisesUsed = s.Axis.split(',');
            var pos = [];
            var firstAxis = null;
            for (var j = 0; j < axisesUsed.length; j++) {
                var axisName = axisesUsed[j];
                
                var d = this.AxisesDetected[axisName];
                if (!d)
                    continue;
                if (!firstAxis)
                    firstAxis = d;

                for (var n = 0; n < s.Data.length; n++) {
                    var value = s.Data[n][j];
                    if (!pos[n])
                        pos[n] = [0, 0, d.Size, s.Color, 0, 15]; // X px center, Y px center, Size Primary, Color, Offset secondary axis,Size Secondary

                    if (d.Location < 6) {
                        var px = d.ValueToPX(value);
                        
                        if (!d.OffsetsPX)
                            d.OffsetsPX = {};
                        
                        if (firstAxis != d) {
                            if (s.Offsets) {
                                pos[n][4] = d.ValueToPX(s.Offsets[n] + d.ScaleMax) - d.ValueToPX(d.ScaleMax);
                            }

                            var key = ((d.Location % 2 == 1) ? pos[n][0] : pos[n][1]);
                            key += "-" + (s.StackGroup ? s.StackGroup : Math.random());
                            var max = firstAxis.Location == 0 || firstAxis.Location == 3 ? ((d.Location % 2 == 0) ? d.Position[0] : d.Position[1]) : ((d.Location % 2 == 1) ? d.Position[3] + d.Position[1] : d.Position[2] + d.Position[0]);
                            if (d.OffsetsPX[key] === undefined)
                                d.OffsetsPX[key] = max;

                            var height = 0;

                            if (firstAxis.Location == 0 || firstAxis.Location == 3) {
                                height = (px + pos[n][4]) - d.OffsetsPX[key];
                                d.OffsetsPX[key] += height;
                            } else {
                                height = d.OffsetsPX[key] - (px + pos[n][4]);
                                d.OffsetsPX[key] -= height;
                            }
                            pos[n][5] = height;
                        }

                        if (d.Location % 2 == 0) {
                            pos[n][0] = px;
                        } else {
                            pos[n][1] = px;
                        }
                    } else if (d.Location == 8) { // Size
                        if (d.Max == d.Min)
                            pos[n][2] = d.RangeResult[1];
                        else 
                            pos[n][2] = (((value - d.Min) / (d.Max - d.Min)) * (d.RangeResult[1] - d.RangeResult[0])) + d.RangeResult[0];
                    } else if (d.Location == 7) { // Color
                        if (value.toLowerCase) {
                            pos[n][3] = value;
                        } else {
                            var colorA = TK.Draw.GetColor(d.RangeResult[0]), colorB = TK.Draw.GetColor(d.RangeResult[1]);
                            
                            for (var n2 = 0; n2 < colorA.length; n2++) {
                                if (d.Max == d.Min) {
                                    colorA[n2] = colorB[n2];
                                } else {
                                    colorA[n2] = (((value - d.Min) / (d.Max - d.Min)) * (colorB[n2] - colorA[n2])) + colorA[n2];
                                }
                            }
                            pos[n][3] = "rgba(" + colorA.join(",") + ")";
                        }
                    }
                }
            }               

            var curStackGroups = {};
            var barCount = 0;
            var barIndex = 0;
            for (var j = 0; j < firstAxis.Series.length; j++) {
                var otherSerie = this.Series[firstAxis.Series[j]];
                if ((otherSerie.Style & 2) == 0) { // Check if this serie has bars
                    continue;
                }
                if (otherSerie.StackGroup && curStackGroups[otherSerie.StackGroup] !== undefined) {
                    if (firstAxis.Series[j] == i)
                        barIndex = curStackGroups[otherSerie.StackGroup];                               
                    continue;
                }

                if (otherSerie.StackGroup)
                    curStackGroups[otherSerie.StackGroup] = barCount;     

                if (firstAxis.Series[j] == i)
                    barIndex = barCount;                               
                barCount++;
            }
            
            for (var j = 0; j < pos.length; j++) {
                if ((s.Style & 4) > 0) { // Points
                    this.Elements.Canvas.Add({
                        _: TK.Draw.Circle,
                        X: pos[j][0], Y: pos[j][1] + pos[j][4], W: pos[j][2], H: pos[j][2],
                        Fill: pos[j][3],
                        Anchor: TK.Draw.AnchorCenter | TK.Draw.AnchorMiddle,
                        Click: s.Click,
                        MouseOver: s.MouseOver,
                        MouseOut: s.MouseOut
                    });
                }
                
                if ((s.Style & 2) > 0) { // Bars, We use our first axis as 'base'                     
                    var size = (pos[j][2] / barCount) * 0.8;                    
                    var offset = barIndex * size - (pos[j][2] / 2 - pos[j][2] * 0.1);
                    var barRect = {
                        _: TK.Draw.Rect,
                        Fill: pos[j][3],
                        Click: s.Click,
                        MouseOver: s.MouseOver,
                        MouseOut: s.MouseOut,
                        RoundCorners: this.RoundCorners,
                        ShadeSize: this.ShadeSize ? Math.round(size * this.ShadeSize) : 0
                    };

                    if (firstAxis.Location == 2 || firstAxis.Location == 0) {
                        barRect.X = pos[j][0] + offset;
                        barRect.Y = pos[j][1] + pos[j][4];
                        barRect.W = size;
                        barRect.H = pos[j][5];
                        barRect.ShadePosition = 1;
                        if (firstAxis.Location == 2)
                            barRect.Anchor = TK.Draw.AnchorLeft | TK.Draw.AnchorTop;
                        else
                            barRect.Anchor = TK.Draw.AnchorLeft | TK.Draw.AnchorBottom;
                    } else if (firstAxis.Location == 3 || firstAxis.Location == 1) {
                        barRect.X = (pos[j][0] + pos[j][4]);
                        barRect.Y = pos[j][1] + offset;
                        barRect.W = pos[j][5];
                        barRect.H = size;
                        barRect.ShadePosition = 2;
                        if (firstAxis.Location == 3)
                            barRect.Anchor = TK.Draw.AnchorRight | TK.Draw.AnchorTop;
                        else
                            barRect.Anchor = TK.Draw.AnchorLeft | TK.Draw.AnchorTop;               
                    }
                    this.Elements.Canvas.Add(barRect);
                }
            } 

            if ((s.Style & 1) > 0 || (s.Style & 8) > 0) {
                //console.log(pos);
                var heights = [];
                for (var n = 0; n < pos.length; n++) {
                    pos[n][(firstAxis.Location == 2 || firstAxis.Location == 0) ? 1 : 0] += pos[n][4];
                    if ((s.Style & 8) > 0) {
                        heights.push(pos[n][5]);
                    }
                }
                
                this.Elements.Canvas.Add({
                    _: TK.Draw.LineThroughPoints,
                    X: 0, Y: 0,
                    LineWidth: s.LineWidth,
                    Heights: heights,
                    Fill: s.Fill,
                    Points: pos.Select(function (a) { return [a[0], a[1]] }),
                    Stroke: pos[0][3],
                    Smoothing: s.Smoothing,
                    Anchor: TK.Draw.AnchorLeft | TK.Draw.AnchorTop                    
                });
            }
        }
    }
};

"use strict";
/* Minify Skip */
/* Minify Order(200) */

TK.Donut = {
    _: "div",
    Values: [
        /*
        { Name: "Value A", Color: "#F00", ColorLabel: "#F00", Value: 1, Extrude: 10, Label: "Label 123" },
        { Name: "Value B", Color: "#090", Value: 2 },
        { Name: "Value B", Color: "#009", Value: 2 } */
    ],

    Width: 400,
    Height: 200,
    Size: null,    
    DonutStartX: null,
    DonutStartY: null,
    FinalSizeRatio: 0.8,
    DonutSize: 0.5,
    StartAngle: -90,
    EnableLabels: true,
    FontLabels: "10pt Verdana",
    ColorLabels: "rgba(0,0,0,0.5)",
    ColorLabelLines: "rgba(0,0,0,0.5)",
    LabelStyle: 2,  // 0 = Name only, 1 = Value only, 2 = Both
    ShowValueAsPercentage: true,
    AnimationLength: 1000,
    HideZeroes: true,

    EnableLegend: false,
    LocationLegend: 1, // 0 = Top, 1 = Right, 2 = Bottom, 3 = Left
    ColorLegend: "rgba(0,0,0,0.8)",
    FontLegend: "10pt Verdana",
    LegendStyle: 0, // 0 = Name only, 1 = Value only, 2 = Both
    LegendSize: 0, // 0 = Auto
    LegendLineHeight: 25,
    Click: null, // function (valuePart) { },

    Init: function () {
        if (!this.Size)
            this.Size = (this.Width > this.Height ? this.Height : this.Width);
        this.Clear();
        this.Canvas = this.Add({
            _: TK.Draw,
            Width: this.Width,
            Height: this.Height
        }, "Canvas"); 
        this.Refresh();

    },
    Refresh: function () {
        this.Canvas.Clear();
        var obj = this;

        var total = 0;
        var countLegend = 0;
        for (var i = 0; i < this.Values.length; i++) {
            if (this.Values[i].Value && this.Values[i].Value < 0)
                this.Values[i].Value = 0;
            if (this.Values[i].HideZeroes && !this.Values[i].Value)
                continue;
            total += this.Values[i].Value;
            countLegend++;
        }
        var donutStartX = this.DonutStartX;
        var donutStartY = this.DonutStartY;

        if (donutStartX === null)
            donutStartX = Math.round((this.Width - this.Size) / 2);
        if (donutStartY === null)
            donutStartY = Math.round((this.Height - this.Size) / 2);



        if (this.EnableLegend) {
            if (this.LegendSize == 0) {
                if (this.LocationLegend == 0 || this.LocationLegend == 2) {
                    this.LegendSize = this.Width * 0.9;
                } else {
                    // Find max width of the legend labels
                    var maxWidth = 10;
                    for (var i = 0; i < this.Values.length; i++) {
                        var labelLegend = this.Values[i].Name;
                        if (this.LegendStyle != 0) {
                            labelLegend = (this.LegendStyle == 2 ? labelLegend + ": " : "") + (this.ShowValueAsPercentage ? "100 %" : this.Values[i].Value);
                        }
                        var curWidth = TK.Draw.Text.MeasureWidth(labelLegend, this.FontLegend);
                        if (curWidth > maxWidth)
                            maxWidth = curWidth;
                    }

                    this.LegendSize = maxWidth + 20; // Extra padding
                }
            }

            var legendSize = (this.LocationLegend == 0 || this.LocationLegend == 2) ? this.LegendLineHeight * countLegend : this.LegendSize;
            if ((this.LocationLegend == 0 || this.LocationLegend == 2) && this.Size > this.Height - legendSize) {
                this.Size = this.Height - legendSize;
                donutStartX = Math.round((this.Width - this.Size) / 2);
                donutStartY = Math.round((this.Height - this.Size) / 2);
            } else if ((this.LocationLegend == 1 || this.LocationLegend == 3) && this.Size > this.Width - legendSize) {
                this.Size = this.Width - legendSize;
                donutStartX = Math.round((this.Width - this.Size) / 2);
                donutStartY = Math.round((this.Height - this.Size) / 2);
            }

            if (this.LocationLegend == 0)
                donutStartY = legendSize + (((this.Height - legendSize) / 2) - (this.Size / 2));
            else if (this.LocationLegend == 1)
                donutStartX = ((this.Width - legendSize) - this.Size) / 2;
            else if (this.LocationLegend == 2)
                donutStartY = ((this.Height - legendSize) - this.Size) / 2;
            else if (this.LocationLegend == 3)
                donutStartX = legendSize + (((this.Width - legendSize) / 2) - (this.Size / 2));
        }
  
        var middlePointX = (this.Size * 0.5) + donutStartX;
        var middlePointY = (this.Size * 0.5) + donutStartY;

        var curAngle = this.StartAngle;
        var textElements = [];
        for (var i = 0; i < this.Values.length; i++) {
            if (this.Values[i].HideZeroes && !this.Values[i].Value)
                continue;
            var size = (this.Values[i].Value / total) * 360;
            
            var donutPart = this.Canvas.Add({
                _: TK.Draw.Circle,
                DonutSize: this.DonutSize,
                X: middlePointX, Y: middlePointY, W: this.Size, H: this.Size, Size: size, Angle: curAngle, Extrude: 10,
                Fill: this.Values[i].Color,
                Value: this.Values[i],
                Anchor: window.TK.Draw.AnchorCenter | window.TK.Draw.AnchorMiddle,
                MouseOver: function () {
                    if (obj.EnableLegend || obj.Click) {
                        if (this.Value.LegendElement)
                            this.Value.LegendElement.Elements.Text.Animate("X", 20, 150);
                        this.Animate("Extrude", 10, 150);
                    }
                },
                MouseOut: function () {
                    if (obj.EnableLegend || obj.Click) {
                        if (this.Value.LegendElement)
                            this.Value.LegendElement.Elements.Text.Animate("X", 15, 150);
                        this.Animate("Extrude", this.Value.Extrude ? this.Value.Extrude : 0, 150);
                    }
                },
                Click: function () {
                    if (obj.Click)
                        obj.Click(this.Value);
                }
            });            
            donutPart.Animate("W", this.Size * this.FinalSizeRatio, this.AnimationLength, window.TK.Draw.EaseBounce);

            donutPart.Animate("Extrude", this.Values[i].Extrude ? this.Values[i].Extrude : 0, this.AnimationLength, window.TK.Draw.EaseBounce);            

            // Generate labels (line from the middle)
            var label = this.Values[i].Name;
            if (this.LabelStyle != 0) {
                label = (this.LabelStyle == 2 ? label + ": " : "") + (this.ShowValueAsPercentage ? Math.round(this.Values[i].Value / total * 100) + " %" : this.Values[i].Value);
            }
            if (this.Values[i].Label) {
                label = this.Values[i].Label;
            }

            var labelLegend = this.Values[i].Name;
            if (this.LegendStyle != 0) {
                labelLegend = (this.LegendStyle == 2 ? labelLegend + ": " : "") + (this.ShowValueAsPercentage ? Math.round(this.Values[i].Value / total * 100) + " %" : this.Values[i].Value);
            }

            if (this.EnableLabels && label && !this.Values[i].DisableLabel) {                                                     
                var maxSizeFromMiddle = this.Size * this.FinalSizeRatio * 0.5;
                if (this.Values[i].Extrude) {
                    maxSizeFromMiddle += this.Values[i].Extrude;
                }

                var middleRad = (curAngle + (size * 0.5)) * Math.PI / 180;
                var x = Math.cos(middleRad) * maxSizeFromMiddle * (this.DonutSize * 1.5);
                var y = Math.sin(middleRad) * maxSizeFromMiddle * (this.DonutSize * 1.5);
                var xText = Math.cos(middleRad) * maxSizeFromMiddle * 1.1;
                var yText = Math.sin(middleRad) * maxSizeFromMiddle * 1.1;

                var middleCircle, line1, line2, text;

                middleCircle = this.Canvas.Add({
                    _: TK.Draw.Circle,
                    X: middlePointX + x, Y: middlePointY + y, W: 10, H: 10,
                    ZIndex: 10,
                    Fill: "rgba(0,0,0,0)",
                    Anchor: window.TK.Draw.AnchorCenter | window.TK.Draw.AnchorMiddle,
                });

                line1 = this.Canvas.Add({
                    _: TK.Draw.Line,
                    X: middlePointX + x, Y: middlePointY + y, X2: middlePointX + xText, Y2: middlePointY + yText,
                    ZIndex: 10,
                    Stroke: "rgba(0,0,0,0)",
                    Anchor: window.TK.Draw.AnchorTop | window.TK.Draw.AnchorLeft,
                });

                if (xText < 0) {
                    line2 = this.Canvas.Add({
                        _: TK.Draw.Line,
                        X: middlePointX + xText, Y: middlePointY + yText, X2: middlePointX + xText + -5, Y2: middlePointY + yText,
                        ZIndex: 10,
                        Stroke: "rgba(0,0,0,0)",
                        Anchor: window.TK.Draw.AnchorTop | window.TK.Draw.AnchorLeft,
                    });

                    text = this.Canvas.Add({
                        _: TK.Draw.Text,
                        X: middlePointX + xText + -10, Y: middlePointY + yText,
                        ZIndex: 100,
                        Fill: "rgba(0,0,0,0)",
                        Text: label,
                        Font: this.FontLabels,
                        Anchor: window.TK.Draw.AnchorMiddle | window.TK.Draw.AnchorRight,
                    });
                    
                } else {
                    line2 = this.Canvas.Add({
                        _: TK.Draw.Line,
                        X: middlePointX + xText, Y: middlePointY + yText, X2: middlePointX + xText + 5, Y2: middlePointY + yText,
                        ZIndex: 10,
                        Stroke: "rgba(0,0,0,0)",
                        Anchor: window.TK.Draw.AnchorTop | window.TK.Draw.AnchorLeft,
                    });

                    text = this.Canvas.Add({
                        _: TK.Draw.Text,
                        X: middlePointX + xText + 10, Y: middlePointY + yText, 
                        ZIndex: 100,
                        Fill: "rgba(0,0,0,0)",
                        Text: label,
                        Font: this.FontLabels,
                        Anchor: window.TK.Draw.AnchorMiddle | window.TK.Draw.AnchorLeft,
                    });
                }
                text.FillWidthHeight();
                //console.log(text.GetRect());
                for (var textI = 0; textI < textElements.length; textI++) {
                    while (text.Overlaps(textElements[textI])) {
                        if (xText < 0)
                            text.Y -= 1;
                        else 
                            text.Y += 1;

                        line1.Y2 = text.Y;
                        line2.Y = text.Y;
                        line2.Y2 = text.Y;
                    }
                }

                textElements.push(text);

                var finalColor = this.Values[i].ColorLabel ? this.Values[i].ColorLabel : this.ColorLabels;
                var finalColorLine = this.Values[i].ColorLabelLine ? this.Values[i].ColorLabelLine : this.ColorLabelLines;
                middleCircle.Animate("Fill", finalColorLine, this.AnimationLength, TK.Draw.EaseExponential);
                line1.Animate("Stroke", finalColorLine, this.AnimationLength, TK.Draw.EaseExponential);
                line2.Animate("Stroke", finalColorLine, this.AnimationLength, TK.Draw.EaseExponential);
                text.Animate("Fill", finalColor, this.AnimationLength, TK.Draw.EaseExponential);
            }

            if (this.EnableLegend) {
                var obj = this;
                var legend = {
                    _: TK.Draw.Group,
                    DonutPart: donutPart,
                    ValuesObj: this.Values[i],
                    X: 0, Y: i * 25,
                    Anchor: window.TK.Draw.AnchorMiddle | window.TK.Draw.AnchorLeft,
                    Elements: {
                        Circle: {
                            _: TK.Draw.Circle,
                            X: 0, Y: this.LegendLineHeight / 2, W: 10, H: 10,
                            Fill: this.Values[i].Color,
                            Anchor: window.TK.Draw.AnchorMiddle | window.TK.Draw.AnchorLeft,
                        },
                        Text: {
                            _: TK.Draw.Text,
                            X: 15, Y: this.LegendLineHeight / 2, 
                            Fill: this.ColorLegend,
                            Text: labelLegend,
                            Font: this.FontLegend,
                            Anchor: window.TK.Draw.AnchorMiddle | window.TK.Draw.AnchorLeft,
                        }
                    },
                    GetRect: function () {
                        return [this.X, this.Y, obj.LegendSize, obj.LegendLineHeight];
                    },
                    MouseOver: function () {                        
                        this.Elements.Text.Animate("X", 20, 150);
                        this.DonutPart.Animate("Extrude", 10, 150);
                    },
                    MouseOut: function () {
                        this.Elements.Text.Animate("X", 15, 150);
                        this.DonutPart.Animate("Extrude", this.ValuesObj.Extrude ? this.ValuesObj.Extrude : 0, 150);
                    }
                };
                if (this.LocationLegend == 0) {
                    legend.Y = (i * this.LegendLineHeight);
                    legend.X = (this.Width / 2) - (this.LegendSize / 2);
                    legend.Anchor = window.TK.Draw.AnchorTop | window.TK.Draw.AnchorLeft;
                } else if (this.LocationLegend == 1) {
                    legend.X = this.Width - this.LegendSize;
                    legend.Y = ((this.Height / 2) - ((this.LegendLineHeight * countLegend) / 2)) + (i * this.LegendLineHeight);
                } else if (this.LocationLegend == 2) {
                    legend.Y = (this.Height - (this.LegendLineHeight * countLegend)) + (i * this.LegendLineHeight);
                    legend.X = (this.Width / 2) - (this.LegendSize / 2);
                    legend.Anchor = window.TK.Draw.AnchorTop | window.TK.Draw.AnchorLeft;
                } else if (this.LocationLegend == 3) {
                    legend.Y = ((this.Height / 2) - ((this.LegendLineHeight * countLegend) / 2)) + (i * this.LegendLineHeight);
                }
                this.Values[i].LegendElement = this.Canvas.Add(legend);
            }

            curAngle += size;
        }

        this.Canvas.Refresh();
    }
};"use strict";
/* Minify Order(200) */
window.TK.Dropdown = {
    _: "div",
    className: "toolkitDropdown",
    Data: null, // Selected value(s)
    Options: [], // Array of { Value: ..., Text: ... }
    Multiple: false, // Allow multiple selections
    Placeholder: "Select...",
    SelectedText: "{0} selected",
    PaddingCheckSelectedFit: 10,
    MaxDisplayItems: 10, // Maximum items to show before scrolling
    SelectedClass: "toolkitDropdownSelected", // Class for selected items
    OpenClass: "toolkitDropdownOpen", // Class when dropdown is open
    ListItemTemplate: {
        _: "li",
        Dropdown: null,
        Data: null,
        Init: function () {
            this.innerText = this.Data.Text;
            this.Value = this.Data.Value;
            this.className = this.Dropdown.IsSelected(this.Data.Value) ? this.Dropdown.SelectedClass : "";  
        },
        onclick: function (a) {
            this.Dropdown.SelectItem(this.Value);
            if (!this.Dropdown.Multiple) {
                this.Dropdown.ToggleDropdown();
            }
        }
    },
    Init: function () {
        var obj = this;
        if (this.DataSettings) {
            var fields = ["Placeholder", "MaxDisplayItems", "Multiple", "Options", "SelectedClass", "OpenClass"];
            for (var i = 0; i < fields.length; i++) {
                if (this.DataSettings[fields[i]] !== undefined)
                    this[fields[i]] = this.DataSettings[fields[i]];
            }
        }

        this.Clear();
        this.Add({
            _: "div",
            className: "toolkitDropdownDisplay",
            onclick: function (a) { obj.ToggleDropdown() },
            Elements: {
                SelectedItems: {
                    _: "ul",
                    style: { listStyle: "none", padding: 0, margin: 0 },
                },
                Placeholder: {
                    _: "span",
                    innerText: this.Placeholder,
                    style: { display: this.Data ? "none" : "inline" },
                },
            },
        }, "Display");

        this.Add({
            _: "div",
            className: "toolkitDropdownOptions",
            style: { display: "none", maxHeight: this.MaxDisplayItems * 35 + "px" }, 
            Elements: {
                OptionsList: {
                    _: "ul",
                    style: { listStyle: "none", padding: 0, margin: 0 },
                },
            },
        }, "Options");

        this.RefreshOptions();
        this.UpdateDisplay();
    },

    RefreshOptions: function () {
        var obj = this;
        this.Elements.Options.Elements.OptionsList.Clear();
        for (var i = 0; i < this.Options.length;i++) {
            var option = this.Options[i];
            if (option.Text === undefined || option.Text === null)
                option.Text = option.Value;
            else if (option.Value === undefined || option.Value === null)
                option.Value = option.Text;

            if (option.Text === undefined || option.Text === null)
                continue;
            this.Elements.Options.Elements.OptionsList.Add({
                _: this.ListItemTemplate,
                Dropdown: this,
                Data: option
            });
        }
    },

    SelectItem: function (value) {
        if (this.Multiple) {
            if (!this.Data)
                this.Data = [];
            if (this.IsSelected(value)) {
                this.Data.splice(this.Data.indexOf(value), 1);
            } else {
                this.Data.push(value);
            }
        } else {
            this.Data = value;
        }
        this.RefreshOptions();
        this.UpdateDisplay();
        if (this.onchange) this.onchange();
    },

    IsSelected: function (value) {
        return this.Multiple ? this.Data && this.Data.indexOf(value) >= 0 : this.Data === value;
    },

    UpdateDisplay: function () {
        var obj = this;
        this.Elements.Display.Elements.SelectedItems.Clear();
        if (!this.Data)
            return;
        var bboxDisplay = this.Elements.Display.getBoundingClientRect();
        var first = true;
        if (this.Multiple && this.Data) {
            for (var i = 0; i < this.Data.length; i++) {
                var value = this.Data[i];
                var option = this.Options.First(function (a) {
                    return a.Value == value;
                });
                if (option) {
                    if (!first) {
                        this.Elements.Display.Elements.SelectedItems.Add({
                            _: "span",
                            innerText: ", ",
                        });
                    }
                    first = false;
                    var item = this.Elements.Display.Elements.SelectedItems.Add({
                        _: "li",
                        innerText: option.Text,
                    });
                    var bboxItem = item.getBoundingClientRect();

                    if (bboxItem.right > bboxDisplay.right - this.PaddingCheckSelectedFit) {
                        this.Elements.Display.Elements.SelectedItems.Clear();
                        this.Elements.Display.Elements.SelectedItems.Add({
                            _: "li",
                            innerText: this.SelectedText.replace(/\{0\}/g, this.Data.length),
                        });
                        break;
                    }
                    
                }
            }
        } else if (!this.Multiple && this.Data) {
            var option = this.Options.First(function (a) {
                return a.Value == obj.Data;
            });
            if (option) {
                first = false;
                this.Elements.Display.Elements.SelectedItems.Add({
                    _: "li",
                    innerText: option.Text,
                });
            }
        }
        if (first) {
            this.Elements.Display.Elements.SelectedItems.Add({
                _: "span",
                innerText: this.Placeholder,
            });
        }
        this.Elements.Display.Elements.Placeholder.style.display = this.Data ? "none" : "inline";
    },

    ToggleDropdown: function () {
        this.Elements.Options.style.display = this.Elements.Options.style.display === "none" ? "block" : "none";
        this.className = this.className.indexOf(this.OpenClass) >= 0 ? this.className.replace(this.OpenClass, "") : this.className + " " + this.OpenClass;
    },

    GetValue: function () {
        return this.Data;
    }
};


if (window.TK.Form) {
    window.TK.Form.DefaultTemplates.dropdown = {
        _: TK.Dropdown,
        
    };
}
"use strict";
/* Minify Skip */
/* Minify Order(200) */

TK.Gauge = {
    _: "div",
    Ranges: [
        /*
        { MinValue: 0, MaxValue: 5, Color: "#C00" },
        { MinValue: 5, MaxValue: 15, Color: "#FC0" },
        { MinValue: 15, MaxValue: 30, Color: "#090" }
        */
    ],

    Width: 400,
    Height: 200,
    Value: 0,
    StartAngle: -180,
    EndAngle: 0,
    DonutSize: 0.8,
    Label: "",
    EnableValue: true,
    ColorLabel: "#666",    
    FontLabel: "12pt Verdana",
    ColorValue: null, // Automatic (pick range color)
    FontValue: "14pt Verdana",
    TextValue: null, // Automatic (Use actual value)
    EnableShadow: true,
    ColorCursor: "#666",
    AnimationLength: 1000,
    ExtraSpacingBottom: 0,
    Style: 0,  // 0: Circular gauge, 1: Horizontal Gauge
    SizeBar: 20,

    Init: function () {
        this.Clear();
        this.Canvas = this.Add({
            _: TK.Draw,
            Width: this.Width,
            Height: this.Height
        }, "Canvas");
        this.Refresh();

    },
    Refresh: function () {
        this.Canvas.Clear();
        var centerX = this.Width / 2;
        var extraSpacingHeight = (this.Height * 0.1) + this.ExtraSpacingBottom;
        if (this.Label)
            extraSpacingHeight += 25;
        if (this.EnableValue)
            extraSpacingHeight += 25;        

        var centerY = this.Height - extraSpacingHeight;        
        
        var size = this.Width > centerY * 2 ? centerY * 2 : this.Width;
        this.MinValue = this.Ranges.Min(function (a) { return a.MinValue; });
        this.MaxValue = this.Ranges.Max(function (a) { return a.MaxValue; });
        
        this.Difference = this.MaxValue - this.MinValue;
        this.DifferenceAngles = this.EndAngle - this.StartAngle;

        for (var i = 0; i < this.Ranges.length; i++) {            

            if (this.Style == 0) {
                var startAngle = this.StartAngle + (((this.Ranges[i].MinValue - this.MinValue) / this.Difference) * this.DifferenceAngles);
                var sizeAngle = ((this.Ranges[i].MaxValue - this.Ranges[i].MinValue) / this.Difference) * this.DifferenceAngles;
                this.Canvas.Add({
                    _: TK.Draw.Circle,
                    X: centerX, Y: centerY, W: size, H: size,
                    Fill: this.Ranges[i].Color, DonutSize: this.DonutSize, Angle: startAngle, Size: sizeAngle,
                    Anchor: window.TK.Draw.AnchorCenter | window.TK.Draw.AnchorMiddle,
                });

                if (this.EnableShadow) {
                    this.Canvas.Add({
                        _: TK.Draw.Circle,
                        X: centerX, Y: centerY, W: size * (this.DonutSize + 0.05), H: size * (this.DonutSize + 0.05),
                        Fill: "rgba(0,0,0,0.1)", DonutSize: 0.85, Angle: startAngle, Size: sizeAngle,
                        Anchor: window.TK.Draw.AnchorCenter | window.TK.Draw.AnchorMiddle,
                    });
                }
            } else if (this.Style == 1) {
                var fromX = ((this.Ranges[i].MinValue - this.MinValue) / this.Difference) * this.Width;
                var widthX = ((this.Ranges[i].MaxValue - this.Ranges[i].MinValue) / this.Difference) * this.Width;
                this.Canvas.Add({
                    _: TK.Draw.Rect,
                    X: fromX, Y: 10, W: widthX, H: this.SizeBar,
                    Fill: this.Ranges[i].Color, 
                    Anchor: window.TK.Draw.AnchorLeft| window.TK.Draw.AnchorTop,
                });

                if (this.EnableShadow) {
                    this.Canvas.Add({
                        _: TK.Draw.Rect,
                        X: fromX, Y: this.SizeBar + 5, W: widthX, H: 5,
                        Fill: "rgba(0,0,0,0.1)",
                        Anchor: window.TK.Draw.AnchorLeft | window.TK.Draw.AnchorTop,
                    });
                }
            }
        }

        // Draw cursor

        if (this.Style == 0) {
            this.Cursor = this.Canvas.Add({
                _: TK.Draw.Rect,
                X: centerX, Y: centerY, W: size * 0.025, H: size * (0.5 - ((1 - this.DonutSize) * 0.25)),
                Fill: this.ColorCursor,
                Rotate: 0,
                Anchor: window.TK.Draw.AnchorCenter | window.TK.Draw.AnchorBottom,
            });

            this.Canvas.Add({
                _: TK.Draw.Circle,
                X: centerX, Y: centerY, W: size * 0.1, H: size * 0.1,
                Fill: this.ColorCursor,
                Anchor: window.TK.Draw.AnchorCenter | window.TK.Draw.AnchorMiddle,
            });
        } else {

            this.Cursor = this.Canvas.Add({
                _: TK.Draw.Rect,
                X: 0, Y: 0, W: 2, H: this.SizeBar + 20,
                Fill: this.ColorCursor,
                Anchor: window.TK.Draw.AnchorCenter | window.TK.Draw.AnchorTop,
            });
        }
        var curY = centerY + (size * 0.1);

        if (this.Label) {
            this.LabelText = this.Canvas.Add({
                _: TK.Draw.Text,
                X: centerX, Y: curY,
                Fill: this.ColorLabel,
                Font: this.FontLabel,
                Text: this.Label,
                Anchor: window.TK.Draw.AnchorCenter | window.TK.Draw.AnchorMiddle,
            });
            curY += 25;
        }

        if (this.EnableValue) {
            this.ValueText = this.Canvas.Add({
                _: TK.Draw.Text,
                X: centerX, Y: curY,
                Fill: this.ColorValue ? this.ColorValue : "#000",
                Font: this.FontValue,
                Text: this.Value,
                Anchor: window.TK.Draw.AnchorCenter | window.TK.Draw.AnchorMiddle,
            });
        }

        this.SetValue(this.Value);
        this.Canvas.Refresh();        
    },
    SetValue: function (newValue) {
        var animation = window.TK.Draw.EaseExponential;

        if (newValue >= this.MaxValue) {
            animation = window.TK.Draw.EaseBounce;
            newValue = this.MaxValue;
        } else if (newValue <= this.MinValue) {
            animation = window.TK.Draw.EaseBounce;
            newValue = this.MinValue;
        }

        if (this.EnableValue) {
            this.ValueText.Text = this.TextValue ? this.TextValue : newValue;
            var activeRange = this.Ranges.Where(function (a) { return a.MinValue <= newValue && a.MaxValue >= newValue; });

            if (activeRange.length > 0 && !this.ColorValue) {
                this.ValueText.Fill = activeRange[activeRange.length - 1].Color;
            }
        }
        if (this.Style == 0) {
            var valueAngle = this.StartAngle + (((newValue - this.MinValue) / this.Difference) * this.DifferenceAngles);
            this.Cursor.Animate("Rotate", valueAngle + 90, this.AnimationLength, animation);
        } else if (this.Style == 1) {
            var valueX = (((newValue - this.MinValue) / this.Difference) * this.Width - 2) + 1;
            this.Cursor.Animate("X", valueX, this.AnimationLength, animation);
        }
        // Move cursor
        this.Value = newValue;
    }
};"use strict";
/* Minify Skip */
/* Minify Order(200) */

TK.ImageEditor = {
    className: "toolkitImageEditor",    
    Data: null,
    SpecificSize: null, // TODO: Resize uploaded image to [x, y] and force aspect ratio
    ValueType: "dataUrl", // by default, a data:image/jpeg;base64 value is used. 
    Mime: "image/jpeg",
    Quality: 0.9,
    StorageClientId: undefined,
    StorageContainer: undefined,
    StoragePath: undefined,
    onchange: null,

    // Auto resize when image is larger than width and/or height
    MaxWidth: null, 
    MaxHeight: null,

    Init: function () {
        var obj = this;
        if (this.DataSettings) {
            if (this.DataSettings.Mime !== undefined)
                this.Mime = this.DataSettings.Mime;
            if (this.DataSettings.Quality !== undefined)
                this.Quality = this.DataSettings.Quality;
            if (this.DataSettings.ValueType !== undefined)
                this.ValueType = this.DataSettings.ValueType;
            if (this.DataSettings.StorageContainer !== undefined)
                this.StorageContainer = this.DataSettings.StorageContainer;
            if (this.DataSettings.StorageClientId !== undefined)
                this.StorageClientId = this.DataSettings.StorageClientId;
            if (this.DataSettings.StoragePath !== undefined)
                this.StoragePath = this.DataSettings.StoragePath;
        }

        if (this.Data == "loading") {
            this.Elements.DropArea.style.backgroundImage = "";
            this.Elements.DropArea.innerHTML = "Uploading...";
        } else if (this.Data) {            
            if (window.Blob && this.Data instanceof Blob) { 
                this.Elements.DropArea.style.backgroundImage = "";
                var fileReader = new FileReader();
                fileReader.onload = function (e) {
                    obj.Elements.DropArea.style.backgroundImage = "url('"+e.target.result+"')";
                };
                fileReader.readAsDataURL(this.Data);
            } else { // Url or dataUrl
                this.Elements.DropArea.style.backgroundImage = "url('" + this.Data + "')";
            }
            this.Elements.DropArea.innerHTML = "&nbsp;";
        } else {
            this.Elements.DropArea.style.backgroundImage = "";
            this.Elements.DropArea.innerHTML = Svg.Icons.Image;
        }
    },

    StorageHandlers: {
        dataUrl: function (imageEditor, canvas, callBackValue) {
            callBackValue(canvas.toDataURL(imageEditor.Mine, imageEditor.Quality));
        },
        url: function (imageEditor, canvas, callBackValue) {
            
            if (!TK.ServerStorage)
                return;
            var serverStorage = TK.Initialize({
                _: TK.ServerStorage,
                Container: imageEditor.StorageClientId,
                ClientId: imageEditor.ClientId
            });

            // Turn canvas into [Blob]
            canvas.toBlob(function (blob) {
                console.log(blob);
                var fileName = imageEditor.StoragePath ? imageEditor.StoragePath : imageEditor.Mime.replace("/", ".");
                serverStorage.Store(fileName, blob, function (fileMetaData) {
                    console.log(fileMetaData);
                    if (fileMetaData && fileMetaData.url)
                        callBackValue(fileMetaData.url);
                    else
                        alert('Error uploading image');
                });
            }, imageEditor.Mime, imageEditor.Quality);

            
            /*var fd = new FormData();
            fd.append("file", blob, "hello.txt");
            var xhr = new XMLHttpRequest();
            xhr.open('POST', '/server.php', true);
            xhr.onload = function(){
                alert('upload complete');
            };
            xhr.send(fd);*/
        },
        blob: function (imageEditor, canvas, callBackValue) {
            // Turn the value into a [Blob]
            canvas.toBlob(function (blob) {
                callBackValue(blob);
            }, imageEditor.Mime, imageEditor.Quality);
        }
    },
    
    PopupTemplate: {
        _: TK.Popup,
        EnableResize: false,
        Title: "Edit image",
        Width: 600,
        Height: 500,
        EnableBackDrop: true, 
        ImageEditorInstance: null,
        Template: {
            Elements: {
                CanvasContainer: {
                    Elements: {
                        Buttons: {
                            style: {
                                position: "relative",
                                height: "30px"
                            },
                            Elements: {
                                Slider: {
                                    _: "input",
                                    type: "range",
                                    min: 0,
                                    max: 360,
                                    value: 0,
                                    step: 5,
                                    style: {
                                        width: "99%"
                                    },
                                    onchange: function () {
                                        this.Parent.Parent.Elements.SelectionCanvas.Rotation = parseFloat(this.value.toString());
                                        this.Parent.Parent.Elements.SelectionCanvas.UpdateBoxPosition();
                                        this.Parent.Parent.Elements.SelectionCanvas.Refresh();
                                    },
                                    oninput: function () {
                                        this.onchange();
                                    }
                                }
                            }
                        },
                        SelectionCanvas: {
                            _: TK.Draw,
                            Width: 580,
                            Height: 370,
                            style: {
                                backgroundColor: "#000"
                            },
                            CropTL: [50, 50],
                            CropBR: [200, 200],
                            NavigationEnabled: true,
                            ZoomEnabled: true,
                            Rotation: 0, // 0 Normal, 1 CW, 2 Upside down, 3 CC

                            Init: function () {
                                // Draw bounding box
                                var obj = this;
                                this.Add({
                                    _: TK.Draw.Image,
                                    X: 10, Y: 10, W: 100, H: 100, Anchor: TK.Draw.AnchorCenter | TK.Draw.AnchorMiddle
                                }, "Image");
                                this.Add({
                                    _: TK.Draw.Rect, Stroke: "#CCC",
                                    MouseDown: function (x, y) {
                                        this.Dragging = true;
                                        this.StartPos = [x, y];                                        
                                    },
                                    MouseMove: function (x, y) {
                                        if (!this.Dragging)
                                            return;
                                        var differenceX = x - this.StartPos[0];
                                        var differenceY = y - this.StartPos[1];
                                        obj.CropTL[0] += differenceX;
                                        obj.CropTL[1] += differenceY;

                                        obj.CropBR[0] += differenceX;
                                        obj.CropBR[1] += differenceY;
                                        if (obj.CropBR[0] >= obj.Width) {
                                            obj.CropTL[0] -= (obj.CropBR[0] - obj.Width);
                                            obj.CropBR[0] = obj.Width;
                                        }
                                        if (obj.CropBR[1] >= obj.Height) {
                                            obj.CropTL[1] -= (obj.CropBR[1] - obj.Height);
                                            obj.CropBR[1] = obj.Height;
                                        }
                                        if (obj.CropTL[0] < 0) {
                                            obj.CropBR[0] += -obj.CropTL[0];
                                            obj.CropTL[0] = 0;
                                        }
                                        if (obj.CropTL[1] < 0) {
                                            obj.CropBR[1] += -obj.CropTL[1];
                                            obj.CropTL[1] = 0;
                                        }
                                        this.StartPos = [x, y];

                                        obj.UpdateBoxPosition();
                                    },
                                    MouseUp: function (x, y) {
                                        this.Dragging = false;
                                    }
                                }, "Box");
                                var boxSize = 15;

                                var boxes = ["TL", "TR", "BL", "BR"];
                                for (var i = 0; i < boxes.length; i++) {
                                    this.Add({
                                        _: TK.Draw.Rect,
                                        Box: boxes[i],
                                        Anchor: boxes[i] == "TL" ? TK.Draw.AnchorRight | TK.Draw.AnchorBottom : 
                                                boxes[i] == "TR" ? TK.Draw.AnchorLeft | TK.Draw.AnchorBottom : 
                                                boxes[i] == "BL" ? TK.Draw.AnchorRight | TK.Draw.AnchorTop : 
                                                boxes[i] == "BR" ? TK.Draw.AnchorLeft | TK.Draw.AnchorTop :
                                                        TK.Draw.AnchorCenter | TK.Draw.AnchorBottom,
                                        Fill: "#FFF",
                                        W: boxSize, H: boxSize,
                                        MouseDown: function (x, y) {
                                            this.Dragging = true;
                                        },
                                        MouseMove: function (x, y) {
                                            this.Fill = "#999";
                                            if (this.Box == "TL")
                                                obj.style.cursor = "nw-resize";
                                            else if (this.Box == "TR")
                                                obj.style.cursor = "ne-resize";
                                            else if (this.Box == "BL")
                                                obj.style.cursor = "sw-resize";
                                            else if (this.Box == "BR")
                                                obj.style.cursor = "se-resize";
                                            
                                            if (!this.Dragging)
                                                return;
                                            if (this.Box == "TL") {
                                                obj.CropTL[0] = x;
                                                obj.CropTL[1] = y;                                                
                                            } else if (this.Box == "TR") {
                                                obj.CropBR[0] = x;
                                                obj.CropTL[1] = y;
                                            } else if (this.Box == "BL") {
                                                obj.CropTL[0] = x;
                                                obj.CropBR[1] = y;
                                            } else if (this.Box == "BR") {
                                                obj.CropBR[0] = x;
                                                obj.CropBR[1] = y;
                                            }
                                            obj.UpdateBoxPosition();
                                        },
                                        MouseOut: function () {
                                            this.Fill = "#FFF";
                                            obj.style.cursor = "default";
                                        },
                                        MouseUp: function (x, y) {
                                            this.Dragging = false;
                                        }
                                    }, "Box"+boxes[i]);
                                }

                                this.UpdateBoxPosition();
                                this.Refresh();
                            },
                            UpdateBoxPosition: function () {
                                this.Elements.Image.Rotate = this.Rotation;
                                this.Elements.Box.X = this.CropTL[0];
                                this.Elements.Box.Y = this.CropTL[1];
                                this.Elements.Box.W = this.CropBR[0] - this.CropTL[0];
                                this.Elements.Box.H = this.CropBR[1] - this.CropTL[1];
                                this.Elements.BoxTL.X = this.CropTL[0];
                                this.Elements.BoxTL.Y = this.CropTL[1];
                                this.Elements.BoxTR.X = this.CropBR[0];
                                this.Elements.BoxTR.Y = this.CropTL[1];
                                this.Elements.BoxBL.X = this.CropTL[0];
                                this.Elements.BoxBL.Y = this.CropBR[1];
                                this.Elements.BoxBR.X = this.CropBR[0];
                                this.Elements.BoxBR.Y = this.CropBR[1];
                            },
                        }
                    }
                }
            }
        },
        Buttons: {
            Apply: function () {
                var popup = this.Parent.Parent;
                var canvas = popup.Elements.Content.Elements.CanvasContainer.Elements.SelectionCanvas;

                // Apply transformations to image, upload and return url
                popup.ImageEditorInstance.Data = "loading";
                popup.ImageEditorInstance.Init();
                setTimeout(function () {
                    var resizeAndCropCanvas = document.createElement("CANVAS");
                    //canvas.Scale; 
                    resizeAndCropCanvas.width = (canvas.CropBR[0] - canvas.CropTL[0]) / canvas.Ratio;
                    resizeAndCropCanvas.height = (canvas.CropBR[1] - canvas.CropTL[1]) / canvas.Ratio;

                    var offsetX = ((canvas.Elements.Image.X - canvas.Elements.Image.W / 2) - canvas.CropTL[0]) / canvas.Ratio;
                    var offsetY = ((canvas.Elements.Image.Y - canvas.Elements.Image.H / 2) - canvas.CropTL[1]) / canvas.Ratio;
                    var context = resizeAndCropCanvas.getContext("2d");
                    context.imageSmoothingQuality = 'high';
                    // TODO: Rotation canvas.Elements.Image.Rotate
                    if (canvas.Elements.Image.Rotate) {                        
                        var translateX = offsetX + (canvas.Elements.Image.Img.width / 2);
                        var translateY = offsetY + (canvas.Elements.Image.Img.height / 2);

                        context.translate(translateX, translateY);
                        context.rotate(canvas.Elements.Image.Rotate * Math.PI / 180);
                        context.translate(-translateX, -translateY);
                        //context.translate(offsetX, offsetY);
                    } 
                    context.drawImage(canvas.Elements.Image.Img, offsetX, offsetY, canvas.Elements.Image.Img.width, canvas.Elements.Image.Img.height);

                    var inst = popup.ImageEditorInstance;

                    // Resize if needed
                    if ((inst.MaxWidth !== null && canvas.Elements.Image.Img.width > inst.MaxWidth) || (inst.MaxHeight !== null && canvas.Elements.Image.Img.height > inst.MaxHeight)) {
                        var ratioW = 9999;
                        var ratioH = 9999;
                        var newWidth = 0;
                        var newHeight = 0;

                        if (inst.MaxWidth !== null)
                            ratioW = inst.MaxWidth / resizeAndCropCanvas.width ; // 200 / 800 = 0.25
                        if (inst.MaxHeight !== null)
                            ratioH = inst.MaxHeight / resizeAndCropCanvas.height; // 200 / 1000 = 0.2

                        if (ratioW < ratioH) {
                            newWidth = inst.MaxWidth;
                            newHeight = Math.floor(ratioW * resizeAndCropCanvas.height);
                        } else {
                            newWidth = Math.floor(ratioH * resizeAndCropCanvas.width);
                            newHeight = inst.MaxHeight;
                        }

                        var resizeAndCropCanvas2 = document.createElement("CANVAS");
                        resizeAndCropCanvas2.width = newWidth;
                        resizeAndCropCanvas2.height = newHeight;
                        var context2 = resizeAndCropCanvas2.getContext("2d");
                        context2.imageSmoothingQuality = 'high';
                        context2.drawImage(resizeAndCropCanvas, 0, 0, newWidth, newHeight);

                        resizeAndCropCanvas = resizeAndCropCanvas2;
                    }
                    
                    if (inst.ValueType && inst.StorageHandlers[inst.ValueType]) {
                        inst.StorageHandlers[inst.ValueType](inst, resizeAndCropCanvas, function (value) {
                            inst.Data = value;
                            inst.Init();
                            if (inst.onchange)
                                inst.onchange();
                        });
                    } else {
                        var url = resizeAndCropCanvas.toDataURL(inst.Mine, inst.Quality);
                        inst.Data = url;
                        inst.Init();
                        if (inst.onchange)
                            inst.onchange();
                    }
                }, 1);
            },
            Cancel: function () { }
        },
        ImageLoaded: function (dataUri) {
            var canvas = this.Elements.Content.Elements.CanvasContainer.Elements.SelectionCanvas;
            this.ImageUrl = dataUri;
            var img = new Image();
            img.onload = function () {
                canvas.Elements.Image.Img = this;
                var padding = 20;
                // Fill image into selection canvas (with some padding at the sides)
                var maxWidth = canvas.Width - (padding * 2), maxHeight = canvas.Height - (padding * 2);
                var imgWidth = this.width, imgHeight = this.height;
                var widthRatio = maxWidth / imgWidth, heightRatio = maxHeight / imgHeight;
                var bestRatio = Math.min(widthRatio, heightRatio);
                var newWidth = imgWidth * bestRatio, newHeight = imgHeight * bestRatio;
                canvas.Ratio = bestRatio;
                
                canvas.Elements.Image.X = (canvas.Width / 2);
                canvas.Elements.Image.Y = (canvas.Height / 2);
                canvas.Elements.Image.W = newWidth;
                canvas.Elements.Image.H = newHeight;
                canvas.CropTL = [canvas.Elements.Image.X - (newWidth / 2), canvas.Elements.Image.Y - (newHeight / 2)];
                canvas.CropBR = [canvas.Elements.Image.X + (newWidth / 2), canvas.Elements.Image.Y + (newHeight / 2)];
                canvas.UpdateBoxPosition();
                canvas.Refresh();
            };
            img.src = dataUri;
        }
    },
    GetValue: function () {
        if (this.Data == "loading")
            return null;
        return this.Data;
    },
    HandleFiles: function (files) {
        var file = files[0]; // TODO: Support multiple files in the future
        

        var popup = this.Add({
            _: this.PopupTemplate,
            ImageEditorInstance: this
        });

        var reader = new FileReader();
        reader.onload = function (e2) { popup.ImageLoaded(e2.target.result); };
        reader.readAsDataURL(file);
    },
    Elements: {
        DropArea: {
            onclick: function () {
                this.Near("FileUploadField").click();                
            },
            ondragover: function (ev) {
                this.style.borderColor = "#1d1d1d";
                ev.preventDefault();
            },
            ondragexit: function (ev) {
                this.style.borderColor = "";
                ev.preventDefault();
            },
            ondrop: function (ev) {
                ev.preventDefault();
                
                if (!ev.dataTransfer || !ev.dataTransfer.files)
                    return;
                this.Parent.HandleFiles(ev.dataTransfer.files);
            }
        },
        FileUploadField: {
            _: "input",
            type: "file",
            accept:"image/*",
            style: {
                display: "none"
            },
            onchange: function (e) {
                if (!e || !e.target || !e.target.files || e.target.files.length == 0)
                    return;
                //alert(e.target.files[0].name);
                this.Parent.HandleFiles(e.target.files);                
            }
        }
    }
};

if (window.TK.Form) {
    window.TK.Form.DefaultTemplates.image = {
        _: TK.ImageEditor
    };
}

if (window.TK.HtmlEditor) {
    window.TK.HtmlEditor.ButtonTemplates.InsertImage = {
        innerHTML: Svg.Icons.Image,
        title: "Insert image",
        onmousedown: function () {
            var randId = "img" + new Date().getTime();
            var html = "<img id=\"" + randId + "\" style=\"max-width: 100%;\" />";
            this.Near("Editor").focus();
            document.execCommand("insertHTML", false, html);            

            var img = document.getElementById(randId);
            if (img) {
                var tempEditor = TK.Initialize({
                    _: TK.ImageEditor,
                    style: { display: "none" },
                    onchange: function () {
                        var dataUrl = this.GetValue();
                        if (dataUrl) {
                            img.src = dataUrl;
                        }
                    }
                });
                tempEditor.Elements.FileUploadField.click();
            }
        }
    };
}"use strict";
/* Minify Order(200) */

TK.Interface = {
    CurrentUserTemplate: null,
    CurrentLogoTemplate: null,
    DefaultContent: "Index",
    className: "toolkitInterface",
    MenuIconSize: 50,
    MenuTextSize: 150,
    ResponsiveThreshold: 400,
    ResponsiveFullThreshold: 700,
    EnableMenu: true,
    Content: {},

    HamburgerIcon: null, // <svg> </svg> data

    Embedded: false,

    ShowMenu: false, // Show menu in mobile view (Hamburger menu icon toggles this)
    
    Init: function () {
        var obj = this;
        if (!this.EnableMenu) {
            this.MenuIconSize = 0;
            this.MenuTextSize = 0;
        }
        var header = this.Add({
            _Position: "0px,0px,,0px,,40px",
            style: {
                zIndex: "1000"
            },
            Elements: {
                CurrentUser: {
                    _Position: "0px,9px",
                    style: {
                        lineHeight: "40px"
                    }
                },
                CurrentLogo: {
                    _Position: "0px,,,9px",
                    style: {
                        lineHeight: "40px"
                    }
                }
            },
            Init: function() {
                if (obj.EnableMenu) {
                    this.Add({
                        innerHTML: obj.HamburgerIcon ? obj.HamburgerIcon : window.Svg && Svg.Icons && Svg.Icons.Hamburger ? Svg.Icons.Hamburger : "",
                        onclick: function() {
                            // Toggle menu
                            obj.ShowMenu = !obj.ShowMenu;
                            obj.ProcessResize();
                        },
                        _Position: "5px,,,5px,30px,30px"
                    }, "HamburgerMenu");
                }
            }
        }, "Header");

        var menu = null;
        if (this.EnableMenu) {
            var menu = this.Add({
                _: "ul",
                style: {
                    listStyle: "none",
                    margin: "0px",
                    padding: "0px",
                    zIndex: "1000",
                    display: "none"
                },
                _Position: "40px,,0px,0px," + (this.MenuIconSize + this.MenuTextSize) + "px,"
            }, "Menu");
        }

        var content = {
            _: TK.Navigator,
            _Position: "40px,0px,0px," + (this.MenuIconSize + this.MenuTextSize) +"px",
            style: {
                overflow: "auto"
            },
            Templates: {},
            DefaultHash: this.DefaultContent,
            Navigate: function(page) {
                if (!menu)
                    return;
                var menuItems = obj.Elements.Menu.Elements.ToArray();
                for (var i = 0; i < menuItems.length;i++) 
                    menuItems[i].className = menuItems[i].className.replace("toolkitActive", "");
                if (menu.Elements["MenuItem" + page])
                    menu.Elements["MenuItem" + page].className += " toolkitActive";
            }
        };
        if (!this.Embedded) {        
            content._Position = null;
            document.body.style.paddingTop = "40px";
            document.body.style.paddingLeft = (this.MenuIconSize + this.MenuTextSize) + "px";
            content.style.overflow = "";
            header.style.position = "fixed";
            if (menu)
                menu.style.position = "fixed";
        }

        for (var name in this.Content) {
            if (!this.Content[name].Hidden && menu) {
                var menuItem = menu.Add({
                    _: "li",
                    style: {
                        position: "relative",
                        //width: (this.MenuIconSize + this.MenuTextSize) + "px",
                        height: this.MenuIconSize + "px",
                        lineHeight: this.MenuIconSize + "px",
                        textAlign: "left",
                        overflow: "hidden"
                    },
                    title: this.Content[name].Name,
                    Hash: name,
                    onclick: function () {
                        if (obj.ShowMenu) {
                            obj.ShowMenu = !obj.ShowMenu;
                            obj.ProcessResize();
                        }
                        window.location.hash = "#" + this.Hash;
                    },
                    Elements: {}
                }, "MenuItem" + name);
                if (this.Content[name].Icon) {
                    menuItem.Add({
                        innerHTML: this.Content[name].Icon,
                        style: {
                            position: "absolute",
                            top: "5px",
                            left: "5px",
                            width: (this.MenuIconSize - 10) + "px",
                            height: (this.MenuIconSize - 10) + "px"
                        }
                    }, "Icon");
                }
                menuItem.Add({
                    _: "span",
                    style: {
                        position: "absolute",
                        top: "0px",
                        left: (this.MenuIconSize+5)+"px",
                        right: "0px",
                        height: this.MenuIconSize + "px"
                    },

                    innerHTML: this.Content[name].Name ? this.Content[name].Name : name
                }, "Title");
            }

            if (this.Content[name].Content) { // Divided in subpages           
                
                content.Templates[name] = {
                    _: "div",                    
                    className: "toolkitInterfaceSubPages",
                    Templates: {},
                    MenuTemplate: {
                        _: "ul",
                        style: {
                            position: !this.Embedded ? "fixed" : "absolute",
                            zIndex: "990",
                        },
                        Elements: {}
                    },
                    Elements: {                        
                        SubContent: {
                            _: TK.Navigator,
                            Templates: {},
                            NavigatorLevel: 1,
                            DefaultHash: this.Content[name].DefaultContent ? this.Content[name].DefaultContent : this.DefaultContent,
                            Navigate: function (page) {                                  
                                if (obj.SubMenu) {
                                    obj.SubMenu.Remove();
                                }
                                obj.SubMenu = obj.Add(this.Parent.MenuTemplate, "SubMenu");

                                var menuItems = obj.SubMenu.Elements.ToArray();
                                for (var i = 0; i < menuItems.length; i++)
                                    menuItems[i].className = menuItems[i].className.replace("toolkitActive", "");
                                if (obj.SubMenu.Elements["MenuItem" + page])
                                    obj.SubMenu.Elements["MenuItem" + page].className += " toolkitActive";
                                obj.ProcessResize();
                            },
                            Destroy: function () {
                                this.Navigate = null;
                                window.removeEventListener("hashchange", this.onHashChangeHandler);
                                if (obj.SubMenu)
                                    obj.SubMenu.Remove();                                
                                obj.ProcessResize();
                            }
                        }
                    }
                };
                for (var subName in this.Content[name].Content) {
                    var contentObj = this.Content[name].Content[subName];
                    if (!contentObj.Hidden) {
                        var menuItemTemplate = {
                            _: "li",
                            className: "toolkitActive",
                            innerHTML: contentObj.Name ? contentObj.Name : subName,
                            Hash: name + "/" + subName,
                            onclick: function () {
                                window.location.hash = "#" + this.Hash;
                            },
                            Elements: {

                            }
                        };

                        if (contentObj.Icon) {
                            menuItemTemplate.className += " menuButtonWithIcon";
                            menuItemTemplate.Elements.Icon = {
                                innerHTML: contentObj.Icon
                            };
                        }
                        content.Templates[name].MenuTemplate.Elements["MenuItem" + subName] = menuItemTemplate;
                    }
                    content.Templates[name].Elements.SubContent.Templates[subName] = contentObj.Template;
                }              
                
            } else {
                content.Templates[name] = this.Content[name].Template;
            }
        }

        this.Add(content, "Content");

        if (this.CurrentUserTemplate) {
            header.Elements.CurrentUser.Add(this.CurrentUserTemplate, "User");
        }
        if (this.CurrentLogoTemplate) {
            header.Elements.CurrentLogo.Add(this.CurrentLogoTemplate, "Logo");
        }

        this.OnResizeListener = function () {
            obj.ProcessResize();
        };
        window.addEventListener("resize", this.OnResizeListener);
        setTimeout(function () {
            obj.ProcessResize();
        },1);
    }, 
    ProcessResize: function () {
        var obj = this;
        var w = (this.Embedded ? this.offsetWidth : document.body.offsetWidth);        
        
        if (w < this.ResponsiveThreshold) { // Small view
            //this.Elements.Menu.style.width = (this.MenuIconSize + this.MenuTextSize) + "px";
            if (this.Elements.Menu) {
                this.Elements.Menu.style.width = "100%";
                this.Elements.Menu.style.display = this.ShowMenu ? "" : "none";

                if (this.Elements.Menu.className.indexOf("toolkitDocked") >= 0) {
                    this.Elements.Menu.className = this.Elements.Menu.className.replace(/toolkitDocked/g, "");
                }

                this.Elements.Header.Elements.HamburgerMenu.style.display = "";
                this.Elements.Header.Elements.HamburgerMenu.className = "Element-HamburgerMenu " + (this.ShowMenu ? "toolkitActive" : "");


                this.Elements.Header.Elements.CurrentLogo.style.left = "43px";
                if (this.Embedded) {
                    this.Elements.Content.style.left = "0px";
                } else {
                    document.body.style.paddingLeft = "0px";
                }
            }

            if (this.className.indexOf("toolkitSizeMedium") >= 0)
                this.className = this.className.replace(/toolkitSizeMedium/g, "");
            if (this.className.indexOf("toolkitSizeSmall") < 0)
                this.className += " toolkitSizeSmall";

            if (this.Embedded) {
                this.Elements.Content.style.top = this.Elements.Header.style.height;
            } else {
                document.body.style.paddingTop = this.Elements.Header.style.height;
            }
            if (this.Elements.SubMenu) {
                this.Elements.SubMenu.style.top = "";
                this.Elements.SubMenu.style.bottom = "0px";
                this.Elements.SubMenu.style.left = "0px";
                this.Elements.SubMenu.style.right = "0px";

                if (this.Embedded) {
                    this.Elements.Content.style.bottom = "60pt";
                } else {
                    document.body.style.paddingBottom = "60pt";
                }
            } else {
                if (this.Embedded) {
                    this.Elements.Content.style.bottom = "0px";
                } else {
                    document.body.style.paddingBottom = "0px";
                }
                
            }

            this.CurrentScrollElement = this.Embedded ? this.Elements.Content : window;
            this.CurrentScrollPosition = this.CurrentScrollElement.scrollY === undefined ? this.CurrentScrollElement.scrollTop : this.CurrentScrollElement.scrollY;
            if (!this.OnScrollListener) {
                var scrollUpCounter = 0;
                var scrollDownCounter = 0;
                this.OnScrollListener = function () {
                    obj.ShowMenu = false;
                    if (obj.Elements.Menu) {
                        obj.Elements.Menu.style.display = "none";
                        obj.Elements.Header.Elements.HamburgerMenu.className = "Element-HamburgerMenu";
                    }

                    if (obj.Embedded) {
                        var newScroll = obj.CurrentScrollElement.scrollTop;
                        var oldScroll = obj.CurrentScrollPosition;
                        obj.CurrentScrollPosition = newScroll;

                        if (newScroll + obj.CurrentScrollElement.offsetHeight + 50 > obj.CurrentScrollElement.scrollHeight)
                            return;
                        if (newScroll < oldScroll) {
                            scrollUpCounter += oldScroll - newScroll;
                            scrollDownCounter = 0;
                        } else {
                            scrollUpCounter = 0;
                            scrollDownCounter += newScroll - oldScroll;
                        }

                        if (scrollDownCounter > 40 && newScroll > 50) {
                            // Hide menu
                            obj.Elements.Header.style.height = "0px";
                            obj.Elements.Content.style.top = "0px";
                            if (obj.Elements.Menu)
                                obj.Elements.Menu.style.top = "0px";
                        } else if (scrollUpCounter > 40) {
                            obj.Elements.Header.style.height = "40px";
                            obj.Elements.Content.style.top = "40px";
                            if (obj.Elements.Menu)
                                obj.Elements.Menu.style.top = "40px";
                        }  
                    } else {
                        var newScroll = obj.CurrentScrollElement.scrollY;
                        var oldScroll = obj.CurrentScrollPosition;
                        obj.CurrentScrollPosition = newScroll;

                        if (newScroll + window.innerHeight + 50 > document.documentElement.scrollHeight)
                            return;

                        if (newScroll < oldScroll) {
                            scrollUpCounter += oldScroll - newScroll;
                            scrollDownCounter = 0;
                        } else {
                            scrollUpCounter = 0;
                            scrollDownCounter += newScroll - oldScroll;
                        }

                        if (scrollDownCounter > 40 && newScroll > 50) {
                            // Hide menu
                            obj.Elements.Header.style.height = "0px";
                        } else if (scrollUpCounter > 40) {
                            obj.Elements.Header.style.height = "40px";
                        }  
                    }
                  
                };
                this.CurrentScrollElement.addEventListener("scroll", this.OnScrollListener);
            }
        } else {
            this.ShowMenu = false;
            var paddingLeft = 0;
            if (this.className.indexOf("toolkitSizeSmall") >= 0)
                this.className = this.className.replace(/toolkitSizeSmall/g, "");

            if (w < this.ResponsiveFullThreshold) { // Medium view                
                paddingLeft = (this.MenuIconSize);                
                if (this.className.indexOf("toolkitSizeMedium") < 0)
                    this.className += " toolkitSizeMedium";
            } else { // Big/default view                
                if (this.className.indexOf("toolkitSizeMedium") >= 0)
                    this.className = this.className.replace(/toolkitSizeMedium/g, "");
                paddingLeft = (this.MenuIconSize + this.MenuTextSize);
            }

            if (this.Elements.Menu) {                
                this.Elements.Menu.style.display = "";
                this.Elements.Header.Elements.HamburgerMenu.style.display = "none";
                this.Elements.Header.Elements.CurrentLogo.style.left = "9px";                

                if (w < this.ResponsiveFullThreshold) { // Medium view
                    // Just show icons
                    if (this.Elements.Menu.className.indexOf("toolkitDocked") < 0)
                        this.Elements.Menu.className += " toolkitDocked";
                } else {
                    // Show icons and text
                    if (this.Elements.Menu.className.indexOf("toolkitDocked") >= 0)
                        this.Elements.Menu.className = this.Elements.Menu.className.replace(/toolkitDocked/g, "");
                }

                if (this.Embedded) {
                    this.Elements.Content.style.left = paddingLeft + "px";
                    this.Elements.Content.style.top = "40px";
                } else {
                    document.body.style.paddingLeft = paddingLeft + "px";
                    document.body.style.paddingTop = "40px";
                }

                this.Elements.Header.style.height = "40px";
                this.Elements.Menu.style.top = "40px";
                this.Elements.Menu.style.width = paddingLeft + "px";

            } else {
                paddingLeft = 0;
            }

            if (this.Elements.SubMenu) {
                this.Elements.SubMenu.style.bottom = "";
                this.Elements.SubMenu.style.top = "40px";
                this.Elements.SubMenu.style.left = paddingLeft + "px";
                this.Elements.SubMenu.style.right = "0px";
                if (this.Embedded) {
                    this.Elements.Content.style.top = "80px";
                } else {
                    document.body.style.paddingTop = "80px";
                }
            }
            if (this.Embedded) {
                this.Elements.Content.style.bottom = "0px";
            } else {
                document.body.style.paddingBottom = "0px";
            }

            if (this.OnScrollListener) {
                this.CurrentScrollElement.removeEventListener("scroll", this.OnScrollListener);
                this.OnScrollListener = null;
            }
        } 
    },
    Destroy: function () {
        window.removeEventListener("resize", this.OnResizeListener);
        if (this.OnScrollListener) {
            this.CurrentScrollElement.removeEventListener("scroll", this.OnScrollListener);
        }
        if (!this.Embedded) {
            document.body.style.paddingTop = "";
            document.body.style.paddingLeft = "";
        }
    },
    Elements: {}
};"use strict";
/* Minify Order(200) */
window.TK.Slider = {
    TextBefore: "",
    TextAfter: "",
    Min: 0,
    Max: 100,
    Width: 200,
    StepSize: 0, // 0 to disable
    ShowSteps: false,
    Data: 0,
    className: "toolkitSlider",
    readOnly: false,
    disabled: false,

    onchange: function () { },

    Init: function () {
        if (this.DataSettings) {
            var fields = ["TextBefore", "TextAfter", "Min", "Max", "StepSize", "ShowSteps"];
            for (var i = 0; i < fields.length; i++) {
                if (this.DataSettings[fields[i]] !== undefined)
                    this[fields[i]] = this.DataSettings[fields[i]];
            }
        }

        this.Elements.SliderContainer.Elements.Steps.style.display = this.ShowSteps && this.StepSize > 0 ? "" : "none";
        if (this.StepSize > 0) {
            var stepCount = Math.floor((this.Max - this.Min) / this.StepSize) + 1;


            this.Elements.SliderContainer.Elements.Steps.Clear();
            for (var i = 0; i < stepCount; i++) {
                var stepDataValue = this.Min + (this.StepSize * i);
                this.Elements.SliderContainer.Elements.Steps.Add({
                    style: {
                        left: this.DataValueToPX(stepDataValue) + "px"
                    },
                    className: stepDataValue <= this.Data ? "stepActive" : "stepInactive"
                }, "Step" + i);
            }

        } else {
            this.Elements.SliderContainer.Elements.Steps.Clear();
        }

        this.Elements.TextBefore.innerText = this.TextBefore;
        this.Elements.TextBefore.style.display = this.TextBefore ? "" : "none";
        this.Elements.TextAfter.innerText = this.TextAfter;
        this.Elements.TextAfter.style.display = this.TextAfter ? "" : "none";

        this.Elements.SliderContainer.style.width = this.Width + "px";
        var curPx = this.DataValueToPX(this.Data);
        this.Elements.SliderContainer.Elements.Indicator.style.left = curPx + "px";
        this.Elements.SliderContainer.Elements.FillBar.style.width = curPx + "px";

    },
    DataValueToPX: function (dataValue) {
        return Math.round(((dataValue - this.Min) / (this.Max - this.Min)) * this.Width);
    },
    PXToDataValue: function (px, roundStepSize) {
        if (roundStepSize) {

            var tmp = ((px / this.Width) * (this.Max - this.Min));
            tmp += (roundStepSize / 2);
            tmp = (tmp - (tmp % roundStepSize)) + this.Min;
            if (tmp > this.Max)
                tmp = this.Max;
            return tmp;
        }
        return ((px / this.Width) * (this.Max - this.Min)) + this.Min;
    },
    GetValue: function () {
        return this.Data;
    },
    Elements: {
        TextBefore: {},
        SliderContainer: {
            onmousdown: function (ev) {
                ev.preventDefault();
            },
            ontouchstart: function (e) {
                ev.preventDefault();
            },
            
            Elements: {
                Steps: {},
                FillBar: {},
                Indicator: {
                    ontouchstart: function (e) {
                        this.onmousedown(e.touches[0]);
                        e.stopPropagation();
                    },
                    onmousedown: function (e) {
                        var x, y;
                        try { x = e.clientX; y = e.clientY; } catch (errie) { var e2 = window.event; x = e2.clientX; y = e2.clientY; }
                        var startPos = this.Parent.Parent.DataValueToPX(this.Parent.Parent.Data);
                        var obj = this;
                        
                        window.onmousemove = function (e) {
                            var x2, y2;
                            try { x2 = e.clientX; y2 = e.clientY; } catch (errie) { var e2 = window.event; x2 = e2.clientX; y2 = e2.clientY; }

                            var newPos = startPos + (x2 - x);

                            if (newPos < 0)
                                newPos = 0;
                            else if (newPos > obj.Parent.Parent.Width)
                                newPos = obj.Parent.Parent.Width;

                            // Jump to the nearest step and calculate data value based on new pos
                            obj.Parent.Parent.Data = obj.Parent.Parent.PXToDataValue(newPos, obj.Parent.Parent.StepSize);

                            // Redraw elements
                            if (obj.Parent.Parent.onchange)
                                obj.Parent.Parent.onchange();
                            obj.Parent.Parent.Init();
                            
                        };
                        window.onmouseup = function () {
                            window.onmousemove = null;
                            window.onmouseup = null;
                            window.onselectstart = null;
                            window.ontouchmove = null;
                            window.ontouchend = null;
                        };
                        window.ontouchmove = function (e) {
                            if (window.onmousemove)
                                window.onmousemove(e.touches[0]);
                            e.stopPropagation();
                        };
                        window.ontouchend = function (e) {
                            if (window.onmouseup)
                                window.onmouseup();
                            e.stopPropagation();
                        };
                        window.onselectstart = function () { return false; };


                        if (e && e.preventDefault)
                            e.preventDefault();
                        else
                            window.event.returnValue = false;
                    },
                }
            }
        },
        TextAfter: {},
    }
};


if (window.TK.Form) {
    window.TK.Form.DefaultTemplates.slider = {
        _: TK.Slider
    };
}
"use strict";
/* Minify Order(200) */
window.TK.Switch = {
    TextBefore: "",
    TextAfter: "",
    Data: false,
    className: "toolkitSwitch",
    onchange: function () { },
    readOnly: false,
    disabled: false,

    onclick: function () {
        this.Toggle();
    },
    Toggle: function () {
        if (this.readOnly || this.disabled)
            return;
        this.Data = !this.Data;
        if (this.onchange)
            this.onchange();
        this.Init();
    },
    Init: function () {
        if (this.DataSettings) {
            if (this.DataSettings.TextBefore !== undefined)
                this.TextBefore = this.DataSettings.TextBefore;
            if (this.DataSettings.TextAfter !== undefined)
                this.TextAfter = this.DataSettings.TextAfter;
        }

        this.className = this.className.replace(/toolkitSwitchActive/g, "").replace(/toolkitSwitchInactive/g, "").replace(/toolkitSwitchDisabled/g, "").replace(/toolkitSwitchReadOnly/g, "") + " "
            + (this.disabled ? "toolkitSwitchDisabled" : "")
            + " " + (this.readOnly ? "toolkitSwitchReadOnly" : "")
            + " " + (this.Data ? "toolkitSwitchActive" : "toolkitSwitchInactive");
        this.Elements.TextBefore.innerText = this.TextBefore;
        this.Elements.TextBefore.style.display = this.TextBefore ? "" : "none";
        this.Elements.TextAfter.innerText = this.TextAfter;
        this.Elements.TextAfter.style.display = this.TextAfter ? "" : "none";
    },
    GetValue: function () {
        return this.Data;
    },
    Elements: {
        TextBefore: {},
        SwitchContainer: {
            Elements: {
                Indicator: {
                    _: "div"
                }
            }
        },
        TextAfter: {},
    }
};


if (window.TK.Form) {
    window.TK.Form.DefaultTemplates.switch = {
        _: TK.Switch
    };
}
